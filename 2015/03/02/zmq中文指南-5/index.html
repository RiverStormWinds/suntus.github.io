<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":"flase","async":true,"transition":{"post_block":"fadeIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"fadeIn","sidebar":"fadeIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第５章－高级发布－订阅模型">
<meta name="keywords" content="tr,zmq">
<meta property="og:type" content="article">
<meta property="og:title" content="zmq中文指南_5">
<meta property="og:url" content="http://suntus.github.io/2015/03/02/zmq中文指南-5/index.html">
<meta property="og:site_name" content="Morning~Sun。">
<meta property="og:description" content="第５章－高级发布－订阅模型">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://suntus.github.io/img/zmq56.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq57.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq58.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq59.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq60.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq61.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq62.png">
<meta property="og:image" content="http://suntus.github.io/img/zmq63.png">
<meta property="og:updated_time" content="2016-12-21T06:18:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zmq中文指南_5">
<meta name="twitter:description" content="第５章－高级发布－订阅模型">
<meta name="twitter:image" content="http://suntus.github.io/img/zmq56.png">



  <link rel="alternate" href="/atom.xml" title="Morning~Sun。" type="application/atom+xml">




  <link rel="canonical" href="http://suntus.github.io/2015/03/02/zmq中文指南-5/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>zmq中文指南_5 | Morning~Sun。</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=UA-55322469-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-55322469-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Morning~Sun。</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">ha</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://suntus.github.io/2015/03/02/zmq中文指南-5/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suntus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Morning~Sun。">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">zmq中文指南_5

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-03-02 17:40 17:40:37" itemprop="dateCreated datePublished" datetime="2015-03-02T17:40:37+08:00">2015-03-02 17:40</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2016-12-21 14:18 14:18:57" itemprop="dateModified" datetime="2016-12-21T14:18:57+08:00">2016-12-21 14:18</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第５章－高级发布－订阅模型"><a href="#第５章－高级发布－订阅模型" class="headerlink" title="第５章－高级发布－订阅模型"></a>第５章－高级发布－订阅模型</h2><a id="more"></a>
<p>　　在第３章－高级请求－回复模型和第４章－可靠的请求－回复模型中，我们讨论了zmq的高级请求－回复模型的使用。如果你已经全部掌握了，恭喜。本章我们会集中在发布－订阅模型和为了性能、可靠性、状态分发和监测使用更高级的模型对核心的pub-sub模型进行扩展。</p>
<p>　　我们会讲到：</p>
<ul>
<li>什么时候使用发布－订阅模型</li>
<li>怎么处理过慢的订阅者(慢性自杀模型 the Suicidal Snail pattern)</li>
<li>怎样设计高速订阅者(黑盒模型 the Black Box pattern)</li>
<li>怎样监测一个pub-sub网络(浓缩咖啡模型 the Espresso pattern)</li>
<li>怎样设计一个共享的键－值存储(克隆模型 the Clone pattern)</li>
<li>怎样使用反应器简化复杂的服务器设计</li>
<li>怎样使用双子星模型为一个服务器增加故障转移。</li>
</ul>
<p><strong>Pub-Sub的优缺点</strong></p>
<p>　　zmq的低级组合有它们各自不同的特性。pub-sub致力于解决一个消息传输的老问题：<em>广播</em>或<em>组播</em>。它有着跟zmq不同的一丝不苟的简单性和粗暴方式相结合的独特混合性质。它值得我们去了解pub-sub的优缺点，懂得怎么做会对我们有利，并且在需要的时候如何避免那些弊端。</p>
<p>　　首先，PUB会把每条message都发送给”所有的对端”，而不是PUSH和DEALER那样只发送给”所有对端中的某一个”。你不能简单的用PUB替换掉PUSH或者反过来又期望系统能正常工作。这个错误经常出现，因为人们真的经常建议这样做。</p>
<p>　　其次，pub-sub目标是可扩展性。这意味着大量数据快速发送给很多个接收者。如果你需要每秒给成千个节点发送百万级别的信息，你就非常需要pub-sub了。</p>
<p>　　为了可扩展性，pub-sub使用了跟push-pull相同的技巧，就是避免回复。也就是说接收者不会反过来跟发送者通信。也有些例外，比如，SUB socket会向PUB socket发送少量且匿名的订阅信息。</p>
<p>　　避免回复在实际的可扩展性中非常重要。使用pub-sub，它能清晰的映射到网络交换机处理的PGM多播协议。换句话说，订阅者并不会直接连接发布者，它们只是连接到交换机上的一个多播<em>组</em>上去，发布者会把信息发送到该组上。</p>
<p>　　因为避免了回复，我们所有的信息流都变得<em>非常</em>简单，这能让我们设计出更简单的API，更简单的协议，能让更多的人接触使用。但我们也移除了协同发送者和接收者的任何可能性。这意味着：</p>
<ul>
<li>发布者不能告诉订阅者什么时候双方成功建立了连接，不管是初始化连接还是网络故障修复后的重连接。</li>
<li>订阅者无法告诉发布者任何能让发布者控制发布的信息速度的信息。发布者只有一个配置，也就是<em>全速发送</em>，那订阅者或者能保存或者丢失信息了。</li>
<li>发布者无法知道订阅者什么时候因为进程挂掉、网络故障等原因而掉线。</li>
</ul>
<p>　　缺点是如果我们想设计可靠的多播这些就是必不可少的。zmq的pub-sub模型会在订阅者正在连接的时候、网络故障的时候或者订阅者或网络跟不上发布者发布速度的时候或者其他任意时候丢失message。</p>
<p>　　好处是仍有很多应用场景中<em>大致</em>可靠的多播就足够好了。当我们需要回复的时候，我们可以换成使用ROUTER-DEALER(对大多数常规应用场景中我推荐这种模型)，或者为同步增加一个单独的通道(本章稍后会看到)。</p>
<p>　　pub-sub就像个广播：在加入前你会错过所有东西，然后你能获取多少东西依赖于你的接收器的品质。让人高兴的是，该模型很有用，因为它完美的反映出了真实世界中信息的分发。想想Facebook和Twitter，BBC世界新闻和体育结果。</p>
<p>　　就像在请求－发布模型中做的那样，我们来根据能发生的错误来定义<em>可靠性</em>。下面是pub-sub会发生的经典错误：</p>
<ul>
<li>订阅者加入的晚了，错过了server已经发送的信息。</li>
<li>订阅者接收信息太慢了，缓存队列持续增加最后溢出。</li>
<li>订阅者在掉线的时候会丢失信息。</li>
<li>订阅者会挂掉和重启，并且丢掉它们已经接收到的信息。</li>
<li>网络会过载然后丢掉数据(特别是对PGM协议来说)。</li>
<li>网络会变得非常慢，因此发布者的缓存队列会溢出然后发布者挂掉。</li>
</ul>
<p>　　还有很多可能的故障，但这些是我们在实际系统中发现的比较典型的。从v3.x开始，zmq强制在内部缓冲区(被称作高水位或HWM)使用默认的限制，因此除非你把HWM设置为无限制，那发布者的崩溃会很少。</p>
<p>　　所有这些故障情况都有解决方案，尽管有些并不简单。对我们来说大多数时候并不需要很复杂的可靠性保证，这也是为什么zmq并不准备在外部提供可靠性保证的原因(即使可以有个全局的可靠性设计，但还是没有)。</p>
<p><strong>pub-sub跟踪(浓缩咖啡模型 Espresso Pattern)</strong></p>
<p>　　让我们从找到一种跟踪pub-sub网络的方法来开始本章内容。在第２章中我们已经看过了一个简单的proxy来做这些传输桥接。<code>zmq_proxy()</code>方法有三个参数：它桥接在一起的<em>frontend</em>和<em>backend</em> socket，和一个把所有信息都发过去的<em>capture</em>　socket。</p>
<p>　　代码相当简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  espresso: Espresso Pattern in C</span></span><br><span class="line"><span class="comment">//  Espresso Pattern</span></span><br><span class="line"><span class="comment">//  This shows how to capture data using a pub-sub proxy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  The subscriber thread requests messages starting with</span></span><br><span class="line"><span class="comment">//  A and B, then reads and counts incoming messages.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">subscriber_thread (<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Subscribe to "A" and "B"</span></span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_connect (subscriber, <span class="string">"tcp://localhost:6001"</span>);</span><br><span class="line">    zsocket_set_subscribe (subscriber, <span class="string">"A"</span>);</span><br><span class="line">    zsocket_set_subscribe (subscriber, <span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *<span class="built_in">string</span> = zstr_recv (subscriber);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Interrupted</span></span><br><span class="line">        <span class="built_in">free</span> (<span class="built_in">string</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    zsocket_destroy (ctx, subscriber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The publisher sends random messages starting with A-J:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">publisher_thread (<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:6000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">string</span> [<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">sprintf</span> (<span class="built_in">string</span>, <span class="string">"%c-%05d"</span>, randof (<span class="number">10</span>) + <span class="string">'A'</span>, randof (<span class="number">100000</span>));</span><br><span class="line">        <span class="keyword">if</span> (zstr_send (publisher, <span class="built_in">string</span>) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Interrupted</span></span><br><span class="line">        zclock_sleep (<span class="number">100</span>);     <span class="comment">//  Wait for 1/10th second</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The listener receives all messages flowing through the proxy, on its</span></span><br><span class="line"><span class="comment">//  pipe. In CZMQ, the pipe is a pair of ZMQ_PAIR sockets that connect</span></span><br><span class="line"><span class="comment">//  attached child threads. In other languages your mileage may vary:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">listener_thread (<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Print everything that arrives on pipe</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">zframe_t</span> *frame = zframe_recv (pipe);</span><br><span class="line">        <span class="keyword">if</span> (!frame)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Interrupted</span></span><br><span class="line">        zframe_print (frame, <span class="literal">NULL</span>);</span><br><span class="line">        zframe_destroy (&amp;frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The main task starts the subscriber and publisher, and then sets</span></span><br><span class="line"><span class="comment">//  itself up as a listening proxy. The listener runs as a child thread:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Start child threads</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    zthread_fork (ctx, publisher_thread, <span class="literal">NULL</span>);</span><br><span class="line">    zthread_fork (ctx, subscriber_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (ctx, ZMQ_XSUB);</span><br><span class="line">    zsocket_connect (subscriber, <span class="string">"tcp://localhost:6000"</span>);</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_XPUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:6001"</span>);</span><br><span class="line">    <span class="keyword">void</span> *listener = zthread_fork (ctx, listener_thread, <span class="literal">NULL</span>);</span><br><span class="line">    zmq_proxy (subscriber, publisher, listener);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">" interrupted"</span>);</span><br><span class="line">    <span class="comment">//  Tell attached threads to exit</span></span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　Espresso模型通过创建一个监听线程读取一个PAIR socket的信息然后打印出来它拿到的所有东西来工作。该PAIR socket是一个管道的一端；另一端(另一个PAIR)是我们传递给<code>zmq_proxy()</code>的socket。实际中，你需要过滤一下来拿到自己希望跟踪的信息(印证了该模型的名字)。</p>
<p>　　订阅者线程订阅了”A”和”B”类型的信息，收到５条message，然后关闭它的socket。当你运行该例子，监听者打印出两条订阅信息，５条数据message，两个未订阅的信息，然后静默：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">002</span>] <span class="number">0141</span></span><br><span class="line">[<span class="number">002</span>] <span class="number">0142</span></span><br><span class="line">[<span class="number">007</span>] B<span class="number">-91164</span></span><br><span class="line">[<span class="number">007</span>] B<span class="number">-12979</span></span><br><span class="line">[<span class="number">007</span>] A<span class="number">-52599</span></span><br><span class="line">[<span class="number">007</span>] A<span class="number">-06417</span></span><br><span class="line">[<span class="number">007</span>] A<span class="number">-45770</span></span><br><span class="line">[<span class="number">002</span>] <span class="number">0041</span></span><br><span class="line">[<span class="number">002</span>] <span class="number">0042</span></span><br></pre></td></tr></table></figure></p>
<p>　　该例子清楚的展示了发布者socket怎么在没有订阅者的时候停止发送数据的。发布线程仍然发送着信息，但该socket就静默地丢掉了这些信息。</p>
<p><strong>最后值缓存</strong></p>
<p>  如果你已经用过了商业的pub-sub系统，你会发现在zmq的pub-sub模型中没有了一些功能。其中一个就是<em>最后值缓存 last value caching(LVC)</em>。这解决了一个新的订阅者在它加入网络的时候怎么跟上的问题。该理论就是刚一个新的订阅者加入并订阅某些特定信息的时候发布者会得到通知。然后发布者就会重新广播这类特定信息的最后一条message。</p>
<p>　　我已经解释过了为什么在有新的订阅者加入的时候发布者得不到通知了，就是因为在大型pub-sub系统中，大量的数据让这件事变得不可能。为了构建真实的大规模pub-sub网络，你需要像PGM那样的协议能提升以太网交换机到一个新高度来广播信息给成千个订阅者。用tcp的单播连接发布者到成千个订阅者不具备可扩展性。你会陷入不公平的分发(一些订阅者会在其他订阅者之前得到message)，网络冲突和一些其他恼人的问题中。</p>
<p>　　PGM是单向协议：发布者向在交换机中的多播地址发送一条message，交换机会重新把该条message广播给所有对它感兴趣的订阅者。发布者永远不会看到订阅者什么时候加入或者离开：这些都发生在交换机中，我们也不想为这部分重新编码。</p>
<p>　　然而，在较少数据量少订阅者和有限个数的信息主题的网络中，我们可以使用TCP和XSUB、XPUB socket<em>真事的</em>跟每个订阅者通信，就像我们在Espresso模型中看到的那样。</p>
<p>　　能用zmq设计出一个LVC吗？答案是肯定的，只要我们在发布者和订阅者之间设计一个proxy:类似于PGM交换机的功能，但可以让我们自己控制。</p>
<p>　　我会从设计一个出现最坏情况的发布者和订阅者开始。该发布者是有缺陷的，它一启动就立即发送一千条不同主题的信息，然后每秒更新一条随机主题的信息。一个订阅者连接并订阅一个主题。没有LVC，一个订阅者可能必须等待平均500s才能得到一条数据。<em>To add some drama, let’s pretend there’s an escaped convict called Gregor threatening to rip the head off Roger the toy bunny if we can’t fix that 8.3 minutes’ delay.</em></p>
<p>　　下面是发布者的代码，注意它有连接到某个地址上的命令行选项，但同时也绑定到了一个地址上。我们会稍后在我们的LVC上使用这个东西：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//  pathopub: Pathologic Publisher <span class="keyword">in</span> C</span><br><span class="line">//  Pathological publisher</span><br><span class="line">//  Sends out <span class="number">1</span>,<span class="number">000</span> topics <span class="literal">and</span> <span class="keyword">then</span> one <span class="built_in">random</span> update per second</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"czmq.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main (<span class="built_in">int</span> argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *context = zctx_new ()<span class="comment">;</span></span><br><span class="line">    void *publisher = zsocket_new (context, ZMQ_PUB)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        zsocket_bind (publisher, argv [<span class="number">1</span>])<span class="comment">;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsocket_bind (publisher, <span class="string">"tcp://*:5556"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    //  Ensure subscriber connection has time <span class="keyword">to</span> complete</span><br><span class="line">    <span class="built_in">sleep</span> (<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    //  <span class="built_in">Send</span> out all <span class="number">1</span>,<span class="number">000</span> topic messages</span><br><span class="line">    <span class="built_in">int</span> topic_nbr<span class="comment">;</span></span><br><span class="line">    <span class="keyword">for</span> (topic_nbr = <span class="number">0</span><span class="comment">; topic_nbr &lt; 1000; topic_nbr++) &#123;</span></span><br><span class="line">        zstr_sendfm (publisher, <span class="string">"%03d"</span>, topic_nbr)<span class="comment">;</span></span><br><span class="line">        zstr_send (publisher, <span class="string">"Save Roger"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    //  <span class="built_in">Send</span> one <span class="built_in">random</span> update per second</span><br><span class="line">    <span class="built_in">srandom</span> ((unsigned) time (<span class="literal">NULL</span>))<span class="comment">;</span></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="built_in">sleep</span> (<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">        zstr_sendfm (publisher, <span class="string">"%03d"</span>, randof (<span class="number">1000</span>))<span class="comment">;</span></span><br><span class="line">        zstr_send (publisher, <span class="string">"Off with his head!"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;context)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是订阅者：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  pathosub: Pathologic Subscriber in C</span></span><br><span class="line"><span class="comment">//  Pathological subscriber</span></span><br><span class="line"><span class="comment">//  Subscribes to one random topic and prints received messages</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">zctx_t</span> *context = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (context, ZMQ_SUB);</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        zsocket_connect (subscriber, argv [<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsocket_connect (subscriber, <span class="string">"tcp://localhost:5556"</span>);</span><br><span class="line"></span><br><span class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span> subscription [<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">sprintf</span> (subscription, <span class="string">"%03d"</span>, randof (<span class="number">1000</span>));</span><br><span class="line">    zsocket_set_subscribe (subscriber, subscription);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *topic = zstr_recv (subscriber);</span><br><span class="line">        <span class="keyword">if</span> (!topic)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">char</span> *data = zstr_recv (subscriber);</span><br><span class="line">        assert (streq (topic, subscription));</span><br><span class="line">        <span class="built_in">puts</span> (data);</span><br><span class="line">        <span class="built_in">free</span> (topic);</span><br><span class="line">        <span class="built_in">free</span> (data);</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　试着编译运行这些东西：首先是订阅者，然后运行发布者。你会看到订阅者报告拿到了”Save Roger”：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./pathosub</span> &amp;</span><br><span class="line"><span class="string">./pathopub</span></span><br></pre></td></tr></table></figure></p>
<p>　　当你运行第二个订阅者的时候你才会发现Roger的困境。你必须留给它足够长的时间它才能报告得到数据。因此，下面就是我们的最后值缓存系统。就像我说的那样，它是一个绑定两个socket然后在两端都处理数据的proxy：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  lvcache: Last Value Caching Proxy in C</span></span><br><span class="line"><span class="comment">//  Last value cache</span></span><br><span class="line"><span class="comment">//  Uses XPUB subscription messages to re-send data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">zctx_t</span> *context = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *frontend = zsocket_new (context, ZMQ_SUB);</span><br><span class="line">    zsocket_bind (frontend, <span class="string">"tcp://*:5557"</span>);</span><br><span class="line">    <span class="keyword">void</span> *backend = zsocket_new (context, ZMQ_XPUB);</span><br><span class="line">    zsocket_bind (backend, <span class="string">"tcp://*:5558"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Subscribe to every single topic from publisher</span></span><br><span class="line">    zsocket_set_subscribe (frontend, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Store last instance of each topic in a cache</span></span><br><span class="line">    <span class="keyword">zhash_t</span> *cache = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  We route topic updates from frontend to backend, and</span></span><br><span class="line">    <span class="comment">//  we handle subscriptions by sending whatever we cached,</span></span><br><span class="line">    <span class="comment">//  if anything:</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</span><br><span class="line">            &#123; frontend, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</span><br><span class="line">            &#123; backend,  <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (zmq_poll (items, <span class="number">2</span>, <span class="number">1000</span> * ZMQ_POLL_MSEC) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Any new topic data we cache and then forward</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">char</span> *topic = zstr_recv (frontend);</span><br><span class="line">            <span class="keyword">char</span> *current = zstr_recv (frontend);</span><br><span class="line">            <span class="keyword">if</span> (!topic)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">char</span> *previous = zhash_lookup (cache, topic);</span><br><span class="line">            <span class="keyword">if</span> (previous) &#123;</span><br><span class="line">                zhash_delete (cache, topic);</span><br><span class="line">                <span class="built_in">free</span> (previous);</span><br><span class="line">            &#125;</span><br><span class="line">            zhash_insert (cache, topic, current);</span><br><span class="line">            zstr_sendm (backend, topic);</span><br><span class="line">            zstr_send (backend, current);</span><br><span class="line">            <span class="built_in">free</span> (topic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  When we get a new subscription, we pull data from the cache:</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">zframe_t</span> *frame = zframe_recv (backend);</span><br><span class="line">            <span class="keyword">if</span> (!frame)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//  Event is one byte 0=unsub or 1=sub, followed by topic</span></span><br><span class="line">            byte *event = zframe_data (frame);</span><br><span class="line">            <span class="keyword">if</span> (event [<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> *topic = zmalloc (zframe_size (frame));</span><br><span class="line">                <span class="built_in">memcpy</span> (topic, event + <span class="number">1</span>, zframe_size (frame) - <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"Sending cached topic %s\n"</span>, topic);</span><br><span class="line">                <span class="keyword">char</span> *previous = zhash_lookup (cache, topic);</span><br><span class="line">                <span class="keyword">if</span> (previous) &#123;</span><br><span class="line">                    zstr_sendm (backend, topic);</span><br><span class="line">                    zstr_send (backend, previous);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">free</span> (topic);</span><br><span class="line">            &#125;</span><br><span class="line">            zframe_destroy (&amp;frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;context);</span><br><span class="line">    zhash_destroy (&amp;cache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　现在运行proxy，然后是发布者：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./lvcache</span> &amp;</span><br><span class="line"><span class="string">./pathopub</span> tcp:<span class="string">//localhost</span><span class="function">:5557</span></span><br></pre></td></tr></table></figure></p>
<p>　　现在尽量多的运行订阅者实例，每次都连接proxy的端口5558:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/pathosub tcp:/</span>/<span class="string">localhost:</span><span class="number">5558</span></span><br></pre></td></tr></table></figure></p>
<p>　　每个订阅者都愉快的报告”Save Roger”，然后逃犯Gregor又潜回他的位子上吃饭喝茶，这是他最想做的事了。</p>
<p>　　一个要注意的：默认的，XPUB socket不会报告重复的订阅信息，这正是在你连接一个XPUB和一个XSUB的时候想要的。我们的例子偷偷绕过了这个，方法是使用随机主题，因此它不起作用的概率是百万分之一。在一个真实的LVC　proxy中，你会想用<code>ZMQ_XPUB_VERBOSE</code>选项做个练习。</p>
<p><strong>慢订阅者检测(慢性自杀模型) Slow Subscriber Detection (Suicidal Snail Pattern)</strong></p>
<p>　　实际中你可能遇到的一个常见问题是慢订阅者。在一个理想的情况中，数据流全速在发布者到订阅者之间流通。但实际上，订阅者应用经常是用解释性语言编写的，或者要做很多工作，或者程序被写的很烂，导致它们跟不上发布者的速度。</p>
<p>　　我们怎么处理一个慢订阅者呢？理想的补救措施是让订阅者更快些，但那可能需要很多工作和时间。一些处理慢订阅者的传统步骤有：</p>
<ul>
<li><strong>在发布者那里建立队列。</strong>这是Gmail在我几个小时没读邮件的时候做的。但在大数据量的应用中，把数据加入队列没什么用且有可能导致发布者耗尽内存崩溃的结果——特别是有很多的订阅者，但因为性能原因也不能把数据缓存到硬盘上的时候。</li>
<li><strong>在订阅者处建立队列。</strong>这要好得多，这是是zmq在网络能跟上的时候默认做的那样。如果有人会耗尽内存而崩溃，那也是订阅者而不是发布者，这就公平多了。这对应付”峰期”数据流相当有用，峰期的时候订阅者暂时跟不上速度，但在数据流慢下来的时候就能追上。然而，这对总是很慢的订阅者来说并不是个解决方案。</li>
<li><strong>暂时停止入队新数据。</strong>这是Gmail在我的邮箱超出存储空间的时候做的。只是拒绝接收新消息或者直接丢弃。从发布者的角度来说这是个很好的策略，这也是当发布者设置了一个HWM的时候zmq做的。然而，这也无法帮我们解决太慢的订阅者。现在我们只是得到了不完整的数据流</li>
<li><strong>断开太慢的订阅者以做惩罚。</strong>这是Hotmail(还记得它吗？)在我两周没登陆的时候干的事，我用了15个Hotmail账号了，这也就是为什么它让我想起来可能有个更好的解决方案。这是个很好的粗鲁的解决策略，能强制让订阅者注意起来，也相当理想，但zmq没这样做，也没办法把它放到高优先层通知订阅者，因为订阅者对发布者程序来说是看不见的。</li>
</ul>
<p>　　这些传统的策略没一个适合的，因此我们需要创造一个新的。不是断开发布者，我们来劝劝订阅者自杀吧。这就是慢性自杀模型(Suicidal Snail pattern)。当一个订阅者检测到它运行的太慢的时候(这里”太慢”大致是个配置选项，意味着”如果你变得慢到一定程度，就大声喊出来，因为我需要知道，然后我能修复它！”)，它就呜呼死掉。</p>
<p>　　订阅者怎么检测呢？一种方法是把信息顺序入队(按顺序编号)并在发布者那里设置一个HWM。现在，如果订阅者检测到一个缝隙(比如编号不连续)，它就知道有些事情弄错了。然后我们调整HWM到”如果你到这个程度就自杀”的水平。</p>
<p>　　该方案有两个问题。一是如果我们有很多发布者，我们怎么顺序排列数据呢？解决办法是给每个发布者一个唯一的ID，然后在编号上加上该ID。二是如果订阅者使用<code>ZMQ_SUBSCRIBE</code>过滤，它们会天然带有缝隙。我们宝贵的序列就什么用都没了。</p>
<p>　　一些应用场景并不使用过滤器，那排序就有意义。但一个更普遍的做法是发布者给每条信息都打上时间戳。当订阅者收到一条信息，它就检查时间，如果相差超过比如说1s，它就做”呜呼死掉”的事情，可能首先是对这一些操作窗口报警。</p>
<p>　　自杀模型特别用于那些订阅者有它们自己的client和服务级协议(service-level agreement)，并需要保证特定最小延迟的情况。中断订阅者并不像一个保证最小延迟的有效方法，而是一个断言模型。今天断掉，然后问题会被修复。让延迟的数据进入，在雷达上可能会造成更大的危害和更长时间的潜伏。</p>
<p>　　下面是一个很小的自杀模型的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  suisnail: Suicidal Snail in C</span></span><br><span class="line"><span class="comment">//  Suicidal Snail</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  This is our subscriber. It connects to the publisher and subscribes</span></span><br><span class="line"><span class="comment">//  to everything. It sleeps for a short time between messages to</span></span><br><span class="line"><span class="comment">//  simulate doing too much work. If a message is more than one second</span></span><br><span class="line"><span class="comment">//  late, it croaks.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ALLOWED_DELAY   1000    <span class="comment">//  msecs</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">subscriber (<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Subscribe to everything</span></span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (subscriber, <span class="string">""</span>);</span><br><span class="line">    zsocket_connect (subscriber, <span class="string">"tcp://localhost:5556"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Get and process messages</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *<span class="built_in">string</span> = zstr_recv (subscriber);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">int64_t</span> clock;</span><br><span class="line">        <span class="keyword">int</span> terms = <span class="built_in">sscanf</span> (<span class="built_in">string</span>, <span class="string">"%"</span> PRId64, &amp;clock);</span><br><span class="line">        assert (terms == <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span> (<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Suicide snail logic</span></span><br><span class="line">        <span class="keyword">if</span> (zclock_time () - clock &gt; MAX_ALLOWED_DELAY) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"E: subscriber cannot keep up, aborting\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Work for 1 msec plus some random additional time</span></span><br><span class="line">        zclock_sleep (<span class="number">1</span> + randof (<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    zstr_send (pipe, <span class="string">"gone and died"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This is our publisher task. It publishes a time-stamped message to its</span></span><br><span class="line"><span class="comment">//  PUB socket every millisecond:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">publisher (<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Prepare publisher</span></span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:5556"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//  Send current clock (msecs) to subscribers</span></span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">string</span> [<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">sprintf</span> (<span class="built_in">string</span>, <span class="string">"%"</span> PRId64, zclock_time ());</span><br><span class="line">        zstr_send (publisher, <span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">char</span> *signal = zstr_recv_nowait (pipe);</span><br><span class="line">        <span class="keyword">if</span> (signal) &#123;</span><br><span class="line">            <span class="built_in">free</span> (signal);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zclock_sleep (<span class="number">1</span>);            <span class="comment">//  1msec wait</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The main task simply starts a client and a server, and then</span></span><br><span class="line"><span class="comment">//  waits for the client to signal that it has died:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *pubpipe = zthread_fork (ctx, publisher, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span> *subpipe = zthread_fork (ctx, subscriber, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">free</span> (zstr_recv (subpipe));</span><br><span class="line">    zstr_send (pubpipe, <span class="string">"break"</span>);</span><br><span class="line">    zclock_sleep (<span class="number">100</span>);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是关于慢性自杀模型例子的一些说明：</p>
<ul>
<li>这里message只是简单的包含当前系统时钟的毫秒数。在实际应用中，你至少需要一个时间戳组成的message头和包含数据的message body。</li>
<li>本例子中订阅者和发布者只是一个单独进程中的两个线程。实际中，它们可能是单独的进程。使用线程只是便于展示。</li>
</ul>
<p><strong>高速订阅者 High-Speed Subscribers (Black Box Pattern)</strong></p>
<p>　　现在来看看一个让我们的订阅者变快的方法。pub-sub的一个常用场景是分发像股票变化的市场数据那样的大量数据流。典型的系统是有个连接股票变化的发布者，获取报价，然后发给很多订阅者。如果有比较少的订阅者，我们就可以使用TCP。如果有很多订阅者，就需要可靠的广播协议，例如PGM。</p>
<p><img src="/img/zmq56.png" alt="f56"></p>
<p>　　假设我们的订阅平均每秒有100,000条100btype的信息。这是经过过滤不需要的市场数据之后发送给订阅者的典型的速率。现在我们要记录一天的数据(可能在８小时中有250G)，然后把它发给一个模拟网络，比如说一小组订阅者。尽管对zmq应用来说每秒100k条数据很简单，但我们还想<em>更快些</em>。</p>
<p>　　我们需要一组节点来构建我们的框架——一个用来做发布者，然后每个订阅者一个。这些都是定制的节点——订阅者的8核，发布者的12个核心。</p>
<p>　　在我们给订阅者发布数据的时候，需要注意两个事情：</p>
<ol>
<li>即使对message进行非常非常微小的操作，也会降低订阅者的接受速度让它再也追不上发布者的速度。</li>
<li>我们会到达一个瓶颈，不管是发布者还是接收者，大约最多每秒6M的数据，即使很小心的进行优化和使用TCP通道。</li>
</ol>
<p>　　首先我们要做的是把订阅者拆成一个多线程的设计，好让一个线程读取数据的时候另外的一组线程去处理数据。特别是，我们并不想按照相同方式处理每条数据。另外，订阅者可能根据前缀关键字来筛选一些message。当message符合某种标准的时候，订阅者会调用一个worker去处理它。在zmq的语境中，这意味着给一个工作线程发送message。</p>
<p>　　因此订阅者看起来像一个队列的装置。我们可以用很多socket去连接订阅者和worker，如果我们假设的是单向通信并且worker全是不同的，就可以用PUSH和PULL，把所有路由工作都交给zmq去完成。这是最简单和最快的实现方式。</p>
<p>　　订阅者跟发布者通信是基于TCP或PGM。订阅者跟它的workers通信是基于inproc://，它们都在同一个线程中。</p>
<p><img src="/img/zmq57.png" alt="f57"></p>
<p>　　现在来打破瓶颈。订阅者线程会达到100%的CPU使用率，因为它是单线程的，不能使用多个核心。单线程总会到达一个瓶颈，最多每秒处理2M、6M或者更多点的数据。我们希望能把工作分摊到多个并行运行的线程中。</p>
<p>　　这种解决方法已经被很多高性能产品使用，被称作<em>分片 sharding</em>。使用分片，我们能把工作分散到并行和独立的处理流中，比如说一半的主题关键字放到这个处理流中，另一半放另一个中。我们可以使用很多个处理流，但除非有多余的核心，否则性能得不到提升。让我们来看看怎么分成两个处理流。</p>
<p>　　要使用两个处理流，都全速工作，我们可以这样配置zmq:</p>
<ul>
<li>两个I/O线程，而不是一个。</li>
<li>两个网络接口(NIC)，每个订阅者一个。</li>
<li>每个I/O线程绑定到一个指定的NIC上。</li>
<li>两个订阅者线程，绑定到指定的核心。</li>
<li>两个SUB　socket，每个订阅者线程一个。</li>
<li>剩余的核心分配给worker线程。</li>
<li>worker线程连接到两个订阅者的PUSH socket去。</li>
</ul>
<p>　　理想状况下，我们希望框架中满负荷的线程数跟核心数相匹配。当线程开始竞争核心和CPU循环，增加更多的线程数带来的开销要大于收益。例如，创建更多的I/O线程就没有多大意义。</p>
<p><strong>可靠的pub-sub Reliable Pub-Sub(Clone Pattern)</strong></p>
<p>　　基于大量已经工作的例子，现在我们来设计一个可靠的pub-sub框架。我们会一步步来开发。目标是让一组应用能共享某些状态。下面是我们的技术挑战：</p>
<ul>
<li>有一大组client应用，大概成千或上万个。</li>
<li>它们会随时加入和退出网络。</li>
<li>这些应用必须共享一个自始至终都一致的<em>状态(state)</em>。</li>
<li>任何client都能在任何时间更新该状态。</li>
</ul>
<p>　　假设更新很小数据量，我们也并不打算做到实时。整个状态信息可以放进内存。一些可能的应用场景是：</p>
<ul>
<li>一组云服务器共享的配置信息。</li>
<li>一组玩家共享的一些游戏信息。</li>
<li>实时更新的汇率信息。</li>
</ul>
<p><strong>中心式vs分布式 (Centralized Versus Decentralized)</strong></p>
<p>　　我们首先必须要做的一个决定是是否需要一个中心服务器。最终设计会有很大区别。优缺点如下：</p>
<ul>
<li>概念上来说，中心服务器理解起来更简单，因为网络并不是天然对称的。使用中心服务器，我们可以避免诸如服务发现、绑定还是连接等问题。</li>
<li>通常来说，一个完全分布式的架构更有技术挑战但会有更简单的协议。也就是说，每个节点都必须按照正确的方式既能当server又能当client，这相当精妙。等设计正确的话，结果会比一个中心服务器更简单清晰。我们在第四章的自由者模型中已经看过了。</li>
<li>一个中心服务器可能会在大数据量的应用场景中成为瓶颈。如果处理规模需要在每秒百万级别信息的话，我们就要朝着分布式的方向努力了。</li>
<li>反过来说，一个中心式的架构会比分布式的架构更容易扩展节点。把10,000个节点连接１台服务器要比这10,000个节点相互之间连接要容易的多。</li>
</ul>
<p><strong>把状态表示成键－值对</strong></p>
<p>　　我们会按步骤开发克隆模型，每次解决一个问题。首先，让我们看看怎么在一组client之间更新一个共享状态。我们需要决定怎么去表示我们的状态，也就是更新的信息。最简单的形式可能就是一个键－值对存储，每个键－值对代表共享状态改变的一个原子组合。</p>
<p>　　在第一章我们有个简单的pub-sub例子，天气预报server和client。我们来把server换成发送键－值对的数据，把client换成在一个hash表中存储这些数据。这样我们就可以使用传统的pub-sub模型从一个server向一组client发送更新。</p>
<p>　　一个更新可以是一个新的key-value对，一个对现有key修改的value或者一个删除的key。目前我们可以假设key-value对能整个放到内存中并且应用根据key来使用，比如使用一个hash表或字典。为了更大存储空间或持久化我们可以把状态放进数据库，但对这里没什么影响。</p>
<p>　　下面是server:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonesrv1: Clone server, Model One in C</span></span><br><span class="line"><span class="comment">//  Clone server Model One</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and publisher socket</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:5556"</span>);</span><br><span class="line">    zclock_sleep (<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="comment">//  Distribute as key-value message</span></span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (++sequence);</span><br><span class="line">        kvmsg_fmt_key  (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">10000</span>));</span><br><span class="line">        kvmsg_fmt_body (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">1000000</span>));</span><br><span class="line">        kvmsg_send     (kvmsg, publisher);</span><br><span class="line">        kvmsg_store   (&amp;kvmsg, kvmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages out\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是client:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonecli1: Clone client, Model One in C</span></span><br><span class="line"><span class="comment">//  Clone client Model One</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and updates socket</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *updates = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (updates, <span class="string">""</span>);</span><br><span class="line">    zsocket_connect (updates, <span class="string">"tcp://localhost:5556"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (updates);</span><br><span class="line">        <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">        kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">        sequence++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages in\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/zmq58.png" alt="f58"></p>
<p>　　对这第一个模型有一些说明：</p>
<ul>
<li>所有复杂的工作都在一个 kvmsg　类中做了。该类操作一个key-value　message　对象，该对象被组织成zmq的三帧message：一个key(一个zmq字符串)，一个序列号(64位值，按网络字节序)和一个二进制的body(包括所有其他的东西)。</li>
<li>该server使用一个随机的4位数字key生成message，它能让我们模拟一个大的但不是特别大的hash表(10k个条目)。</li>
<li>在这个版本中我们不去实现删除：所有的message都是插入或更新。</li>
<li>绑定它的socket之后server会做一个200毫秒的暂停，来避免由于<em>慢接入现象</em>导致的订阅者在连接的时候丢失信息的问题。在稍后版本的克隆模型代码中我们会移除它。</li>
<li>在代码中我们使用<em>publisher</em>和<em>subscriber</em>来代表socket，这在以后我们用多个socket做不同事情的时候会有帮助。</li>
</ul>
<p>　　下面是这个kvmsg类，暂时只是最简单的形式：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  kvsimple: Key-value message class in C</span></span><br><span class="line"><span class="comment">//  kvsimple class - key-value message class for example applications</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "kvsimple.h"</span></span><br><span class="line"><span class="comment">#include "zlist.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Keys are short strings</span></span><br><span class="line"><span class="comment">#define KVMSG_KEY_MAX   255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Message is formatted on wire as 4 frames:</span></span><br><span class="line"><span class="comment">//  frame 0: key (0MQ string)</span></span><br><span class="line"><span class="comment">//  frame 1: sequence (8 bytes, network order)</span></span><br><span class="line"><span class="comment">//  frame 2: body (blob)</span></span><br><span class="line"><span class="comment">#define FRAME_KEY       0</span></span><br><span class="line"><span class="comment">#define FRAME_SEQ       1</span></span><br><span class="line"><span class="comment">#define FRAME_BODY      2</span></span><br><span class="line"><span class="comment">#define KVMSG_FRAMES    3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  The kvmsg class holds a single key-value message consisting of a</span></span><br><span class="line"><span class="comment">//  list of 0 or more frames:</span></span><br><span class="line"></span><br><span class="line">struct _kvmsg &#123;</span><br><span class="line">    <span class="comment">//  Presence indicators for each frame</span></span><br><span class="line">    <span class="keyword">int</span> present [KVMSG_FRAMES];</span><br><span class="line">    <span class="comment">//  Corresponding 0MQ message frames, if any</span></span><br><span class="line">    zmq_msg_t frame [KVMSG_FRAMES];</span><br><span class="line">    <span class="comment">//  Key, copied into safe C string</span></span><br><span class="line">    <span class="keyword">char</span> key [KVMSG_KEY_MAX + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Here are the constructor and destructor for the class:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Constructor, takes a sequence number for the new kvmsg instance:</span></span><br><span class="line">kvmsg_t *</span><br><span class="line">kvmsg_new (int64_t sequence)</span><br><span class="line">&#123;</span><br><span class="line">    kvmsg_t</span><br><span class="line">        *<span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));</span><br><span class="line">    kvmsg_set_sequence (<span class="keyword">self</span>, sequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  zhash_free_fn callback helper that does the low level destruction:</span></span><br><span class="line">void</span><br><span class="line">kvmsg_free (void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        kvmsg_t *<span class="keyword">self</span> = (kvmsg_t *) ptr;</span><br><span class="line">        <span class="comment">//  Destroy message frames if any</span></span><br><span class="line">        <span class="keyword">int</span> frame_nbr;</span><br><span class="line">        <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr])</span><br><span class="line">                zmq_msg_close (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Free object itself</span></span><br><span class="line">        free (<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Destructor</span></span><br><span class="line">void</span><br><span class="line">kvmsg_destroy (kvmsg_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        kvmsg_free (*self_p);</span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method reads a key-value message from socket, and returns a new</span></span><br><span class="line"><span class="comment">//  kvmsg instance:</span></span><br><span class="line"></span><br><span class="line">kvmsg_t *</span><br><span class="line">kvmsg_recv (void *socket)</span><br><span class="line">&#123;</span><br><span class="line">    assert (socket);</span><br><span class="line">    kvmsg_t *<span class="keyword">self</span> = kvmsg_new (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Read all frames off the wire, reject if bogus</span></span><br><span class="line">    <span class="keyword">int</span> frame_nbr;</span><br><span class="line">    <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr])</span><br><span class="line">            zmq_msg_close (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line">        zmq_msg_init (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line">        <span class="keyword">self</span>-&gt;present [frame_nbr] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (zmq_msg_recv (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr], socket, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            kvmsg_destroy (&amp;<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Verify multipart framing</span></span><br><span class="line">        <span class="keyword">int</span> rcvmore = (frame_nbr &lt; KVMSG_FRAMES - <span class="number">1</span>)? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (zsocket_rcvmore (socket) != rcvmore) &#123;</span><br><span class="line">            kvmsg_destroy (&amp;<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method sends a multiframe key-value message to a socket:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_send (kvmsg_t *<span class="keyword">self</span>, void *socket)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    assert (socket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_nbr;</span><br><span class="line">    <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) &#123;</span><br><span class="line">        zmq_msg_t copy;</span><br><span class="line">        zmq_msg_init (&amp;copy);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr])</span><br><span class="line">            zmq_msg_copy (&amp;copy, &amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line">        zmq_msg_send (&amp;copy, socket,</span><br><span class="line">            (frame_nbr &lt; KVMSG_FRAMES - <span class="number">1</span>)? ZMQ_SNDMORE: <span class="number">0</span>);</span><br><span class="line">        zmq_msg_close (&amp;copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  These methods let the caller get and set the message key, as a</span></span><br><span class="line"><span class="comment">//  fixed string and as a printf formatted string:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">kvmsg_key (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_KEY]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!*<span class="keyword">self</span>-&gt;key) &#123;</span><br><span class="line">            size_t size = zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_KEY]);</span><br><span class="line">            <span class="keyword">if</span> (size &gt; KVMSG_KEY_MAX)</span><br><span class="line">                size = KVMSG_KEY_MAX;</span><br><span class="line">            memcpy (<span class="keyword">self</span>-&gt;key,</span><br><span class="line">                zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_KEY]), size);</span><br><span class="line">            <span class="keyword">self</span>-&gt;key [size] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_set_key (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_KEY];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_KEY])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    zmq_msg_init_size (msg, strlen (key));</span><br><span class="line">    memcpy (zmq_msg_data (msg), key, strlen (key));</span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_KEY] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_fmt_key (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *format, …)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> value [KVMSG_KEY_MAX + <span class="number">1</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    va_start (args, format);</span><br><span class="line">    vsnprintf (value, KVMSG_KEY_MAX, format, args);</span><br><span class="line">    va_end (args);</span><br><span class="line">    kvmsg_set_key (<span class="keyword">self</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  These two methods let the caller get and set the message sequence number:</span></span><br><span class="line"></span><br><span class="line">int64_t</span><br><span class="line">kvmsg_sequence (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_SEQ]) &#123;</span><br><span class="line">        assert (zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_SEQ]) == <span class="number">8</span>);</span><br><span class="line">        byte *source = zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_SEQ]);</span><br><span class="line">        int64_t sequence = ((int64_t) (source [<span class="number">0</span>]) &lt;&lt; <span class="number">56</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">1</span>]) &lt;&lt; <span class="number">48</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">2</span>]) &lt;&lt; <span class="number">40</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">3</span>]) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">4</span>]) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">5</span>]) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">6</span>]) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                         +  (int64_t) (source [<span class="number">7</span>]);</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_set_sequence (kvmsg_t *<span class="keyword">self</span>, int64_t sequence)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_SEQ];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_SEQ])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    zmq_msg_init_size (msg, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    byte *source = zmq_msg_data (msg);</span><br><span class="line">    source [<span class="number">0</span>] = (byte) ((sequence &gt;&gt; <span class="number">56</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">1</span>] = (byte) ((sequence &gt;&gt; <span class="number">48</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">2</span>] = (byte) ((sequence &gt;&gt; <span class="number">40</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">3</span>] = (byte) ((sequence &gt;&gt; <span class="number">32</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">4</span>] = (byte) ((sequence &gt;&gt; <span class="number">24</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">5</span>] = (byte) ((sequence &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">6</span>] = (byte) ((sequence &gt;&gt; <span class="number">8</span>)  &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">7</span>] = (byte) ((sequence)       &amp; <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_SEQ] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  These methods let the caller get and set the message body as a</span></span><br><span class="line"><span class="comment">//  fixed string and as a printf formatted string:</span></span><br><span class="line"></span><br><span class="line">byte *</span><br><span class="line">kvmsg_body (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_BODY])</span><br><span class="line">        <span class="keyword">return</span> (byte *) zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_BODY]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_set_body (kvmsg_t *<span class="keyword">self</span>, byte *body, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_BODY];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_BODY])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_BODY] = <span class="number">1</span>;</span><br><span class="line">    zmq_msg_init_size (msg, size);</span><br><span class="line">    memcpy (zmq_msg_data (msg), body, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_fmt_body (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *format, …)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> value [<span class="number">255</span> + <span class="number">1</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    va_start (args, format);</span><br><span class="line">    vsnprintf (value, <span class="number">255</span>, format, args);</span><br><span class="line">    va_end (args);</span><br><span class="line">    kvmsg_set_body (<span class="keyword">self</span>, (byte *) value, strlen (value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method returns the body size of the most recently read message,</span></span><br><span class="line"><span class="comment">//  if any exists:</span></span><br><span class="line"></span><br><span class="line">size_t</span><br><span class="line">kvmsg_size (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_BODY])</span><br><span class="line">        <span class="keyword">return</span> zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_BODY]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method stores the key-value message into a hash map, unless</span></span><br><span class="line"><span class="comment">//  the key and value are both null. It nullifies the kvmsg reference</span></span><br><span class="line"><span class="comment">//  so that the object is owned by the hash map, not the caller:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_store (kvmsg_t **self_p, zhash_t *hash)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        kvmsg_t *<span class="keyword">self</span> = *self_p;</span><br><span class="line">        assert (<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_KEY]</span><br><span class="line">        &amp;&amp;  <span class="keyword">self</span>-&gt;present [FRAME_BODY]) &#123;</span><br><span class="line">            zhash_update (hash, kvmsg_key (<span class="keyword">self</span>), <span class="keyword">self</span>);</span><br><span class="line">            zhash_freefn (hash, kvmsg_key (<span class="keyword">self</span>), kvmsg_free);</span><br><span class="line">        &#125;</span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method prints the key-value message to stderr for</span></span><br><span class="line"><span class="comment">//  debugging and tracing:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_dump (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">            fprintf (stderr, <span class="string">"NULL"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t size = kvmsg_size (<span class="keyword">self</span>);</span><br><span class="line">        byte  *body = kvmsg_body (<span class="keyword">self</span>);</span><br><span class="line">        fprintf (stderr, <span class="string">"[seq:%"</span> PRId64 <span class="string">"]"</span>, kvmsg_sequence (<span class="keyword">self</span>));</span><br><span class="line">        fprintf (stderr, <span class="string">"[key:%s]"</span>, kvmsg_key (<span class="keyword">self</span>));</span><br><span class="line">        fprintf (stderr, <span class="string">"[size:%zd] "</span>, size);</span><br><span class="line">        <span class="keyword">int</span> char_nbr;</span><br><span class="line">        <span class="keyword">for</span> (char_nbr = <span class="number">0</span>; char_nbr &lt; size; char_nbr++)</span><br><span class="line">            fprintf (stderr, <span class="string">"%02X"</span>, body [char_nbr]);</span><br><span class="line">        fprintf (stderr, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf (stderr, <span class="string">"NULL message\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  It's good practice to have a self-test method that tests the class; this</span></span><br><span class="line"><span class="comment">//  also shows how it's used in applications:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">kvmsg_test (<span class="keyword">int</span> verbose)</span><br><span class="line">&#123;</span><br><span class="line">    kvmsg_t</span><br><span class="line">        *kvmsg;</span><br><span class="line"></span><br><span class="line">    printf (<span class="string">" * kvmsg: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Prepare our context and sockets</span></span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *output = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    <span class="keyword">int</span> rc = zmq_bind (output, <span class="string">"ipc://kvmsg_selftest.ipc"</span>);</span><br><span class="line">    assert (rc == <span class="number">0</span>);</span><br><span class="line">    void *input = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    rc = zmq_connect (input, <span class="string">"ipc://kvmsg_selftest.ipc"</span>);</span><br><span class="line">    assert (rc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    zhash_t *kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Test send and receive of simple message</span></span><br><span class="line">    kvmsg = kvmsg_new (<span class="number">1</span>);</span><br><span class="line">    kvmsg_set_key  (kvmsg, <span class="string">"key"</span>);</span><br><span class="line">    kvmsg_set_body (kvmsg, (byte *) <span class="string">"body"</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        kvmsg_dump (kvmsg);</span><br><span class="line">    kvmsg_send (kvmsg, output);</span><br><span class="line">    kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line"></span><br><span class="line">    kvmsg = kvmsg_recv (input);</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        kvmsg_dump (kvmsg);</span><br><span class="line">    assert (streq (kvmsg_key (kvmsg), <span class="string">"key"</span>));</span><br><span class="line">    kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Shutdown and destroy all objects</span></span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line"></span><br><span class="line">    printf (<span class="string">"OK\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  以后我们会设计一个更复杂的kvmsg类来适应实际的工作。</p>
<p>　　server和client都会维持hash表，但这第一个模型只是在我们先启动所有的client然后启动server并且client从不会崩溃的情况下才能正常工作，这相当假。</p>
<p><strong>获取一个外带快照 Getting an Out-of-Band Snapshot</strong></p>
<p>　　现在我们就有了第二个问题：怎么解决慢接入的client和崩溃又重启的client。</p>
<p>　　为了让一个迟到的(或重新回来的)client跟上server，它必须获取一个server状态的快照。就像我们把”message”简化成”一个排好序的key-value对”，我们也可以把”状态”简化成”一个hash表”。为了拿到server的状态，一个client打开一个DEALER socekt然后明确地向server要这个状态。</p>
<p>　　要让它能正常工作，我们必须解决一个时间的问题。拿到一个状态的快照会花费一定的时间，如果快照很大时间会相当长。我们需要适当的更新快照。但server并不知道什么时候开始向我们发送更新。一个办法是开始接收，拿到第一个更新，然后再去要”更新N的状态”。这要求server为每个更新都存储一个快照，很不现实。</p>
<p><img src="/img/zmq59.png" alt="f59"></p>
<p>　　所以我们会在client中做同步，如下：</p>
<ul>
<li>client首先订阅更新然后做一个状态请求。这保证了现有的状态比它原有最老的状态要新(译注：感觉这句话错了。　<em>The client first subscribers to updates and then makes a state reques. This guarantees that the state is going to be newer than the oldest update it has.</em>)。</li>
<li>client等着server回复状态，同时把所有更新都放到队列中。它不读取它们：zmq会把它们都放到socket的队列中去的。</li>
<li>当client收到它的状态更新，就重新开始读取更新。然而，它会把所有比状态更新旧的更新给丢掉。因此如果状态更新最多包含到200，那client就会把直到201之前的更新都给丢掉。</li>
<li>client然后就把更新应用到它自己的状态快照中去。</li>
</ul>
<p>　　这是一个简单的模型，利用了zmq自身的内部队列。下面是server:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonesrv2: Clone server, Model Two in C</span></span><br><span class="line"><span class="comment">//  Clone server - Model Two</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s_send_single</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">void</span> *data, <span class="keyword">void</span> *args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">state_manager</span> <span class="params">(<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and sockets</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:5557"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Start state manager and wait for synchronization signal</span></span><br><span class="line">    <span class="keyword">void</span> *updates = zthread_fork (ctx, state_manager, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">free</span> (zstr_recv (updates));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="comment">//  Distribute as key-value message</span></span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (++sequence);</span><br><span class="line">        kvmsg_fmt_key  (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">10000</span>));</span><br><span class="line">        kvmsg_fmt_body (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">1000000</span>));</span><br><span class="line">        kvmsg_send     (kvmsg, publisher);</span><br><span class="line">        kvmsg_send     (kvmsg, updates);</span><br><span class="line">        kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages out\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Routing information for a key-value snapshot</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *socket;           <span class="comment">//  ROUTER socket to send to</span></span><br><span class="line">    <span class="keyword">zframe_t</span> *identity;     <span class="comment">//  Identity of peer who requested state</span></span><br><span class="line">&#125; <span class="keyword">kvroute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Send one state snapshot key-value pair to a socket</span></span><br><span class="line"><span class="comment">//  Hash item data is our kvmsg object, ready to send</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_send_single (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">void</span> *data, <span class="keyword">void</span> *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kvroute_t</span> *kvroute = (<span class="keyword">kvroute_t</span> *) args;</span><br><span class="line">    <span class="comment">//  Send identity of recipient first</span></span><br><span class="line">    zframe_send (&amp;kvroute-&gt;identity,</span><br><span class="line">        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);</span><br><span class="line">    <span class="keyword">kvmsg_t</span> *kvmsg = (<span class="keyword">kvmsg_t</span> *) data;</span><br><span class="line">    kvmsg_send (kvmsg, kvroute-&gt;socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The state manager task maintains the state and handles requests from</span></span><br><span class="line"><span class="comment">//  clients for snapshots:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">state_manager (<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    zstr_send (pipe, <span class="string">"READY"</span>);</span><br><span class="line">    <span class="keyword">void</span> *snapshot = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    zsocket_bind (snapshot, <span class="string">"tcp://*:5556"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</span><br><span class="line">        &#123; pipe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; snapshot, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;       <span class="comment">//  Current snapshot version number</span></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = zmq_poll (items, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span> &amp;&amp; errno == ETERM)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Context has been shut down</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Apply state update from main thread</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (pipe);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">            sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">            kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Execute state snapshot request</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">zframe_t</span> *identity = zframe_recv (snapshot);</span><br><span class="line">            <span class="keyword">if</span> (!identity)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Request is in second frame of message</span></span><br><span class="line">            <span class="keyword">char</span> *request = zstr_recv (snapshot);</span><br><span class="line">            <span class="keyword">if</span> (streq (request, <span class="string">"ICANHAZ?"</span>))</span><br><span class="line">                <span class="built_in">free</span> (request);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"E: bad request, aborting\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  Send state snapshot to client</span></span><br><span class="line">            <span class="keyword">kvroute_t</span> routing = &#123; snapshot, identity &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  For each entry in kvmap, send kvmsg to client</span></span><br><span class="line">            zhash_foreach (kvmap, s_send_single, &amp;routing);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Now send END message with sequence number</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"Sending state shapshot=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (sequence);</span><br><span class="line">            kvmsg_set_key  (kvmsg, <span class="string">"KTHXBAI"</span>);</span><br><span class="line">            kvmsg_set_body (kvmsg, (byte *) <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">            kvmsg_send     (kvmsg, snapshot);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是client：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonecli2: Clone client, Model Two in C</span></span><br><span class="line"><span class="comment">//  Clone client - Model Two</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and subscriber</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *snapshot = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (snapshot, <span class="string">"tcp://localhost:5556"</span>);</span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (subscriber, <span class="string">""</span>);</span><br><span class="line">    zsocket_connect (subscriber, <span class="string">"tcp://localhost:5557"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Get state snapshot</span></span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    zstr_send (snapshot, <span class="string">"ICANHAZ?"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (snapshot);</span><br><span class="line">        <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">        <span class="keyword">if</span> (streq (kvmsg_key (kvmsg), <span class="string">"KTHXBAI"</span>)) &#123;</span><br><span class="line">            sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"Received snapshot=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Done</span></span><br><span class="line">        &#125;</span><br><span class="line">        kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  Now apply pending updates, discard out-of-sequence messages</span></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (subscriber);</span><br><span class="line">        <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">        <span class="keyword">if</span> (kvmsg_sequence (kvmsg) &gt; sequence) &#123;</span><br><span class="line">            sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">            kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　关于这两个程序有些需要注意的：</p>
<ul>
<li>server用了两个任务。一个线程产生更新(随机的)然后送给主PUB socket，另一个线程在ROUTER socket上处理状态请求。这两个通过一个inproc://连接的PAIR socket通信。</li>
<li>client真的很简单。使用C，它只包含大概50行代码。很多复杂的工作都在kvmsg类中做了。即便如此，这个基本的克隆模型也比它一开始看起来实现要简单些。</li>
<li>我们没用任何序列化这些状态的措施。hash表维持了一组kvmsg对象，server把这些作为一组message发送给要求状态的client。如果多个client同时请求状态，每个都会得到不同的快照。</li>
<li>我们假设该client只跟一个server通信。该server必须运行着：我们并不去解决server挂掉的问题。</li>
</ul>
<p>　　现在，这两个程序并没做什么实际的工作，但它们正确的同步了状态。它是很好的例子来战士怎么去混合多种模型：PAIR-PAIR,PUB-SUB和ROUTER-DEALER。</p>
<p><strong>从client从新发布更新　 Rblishing Updates from Clients</strong></p>
<p>　　在我们的第二个模型中，key-value存储的改变来自server本身。这是个中心式的模型，对比如说我们有个中心配置文件需要分发，并且每个节点都有本地缓存的状况很有用。另一个更有趣的模型从client获取更新，而不是server。server因此成为一个无状态broker。这会有如下好处：</p>
<ul>
<li>我们可以更少关心server的可靠性。如果它挂掉了，我们可以重启一个新实例，给它新值。</li>
<li>我们可以用key-value存储在活跃的对端之间共享数据。</li>
</ul>
<p>　　要把更新从client发回给server，我们可以用很多种socket模型。最简单的就是PUSH-PULL组合。</p>
<p>　　为什么我们不让client直接向其他client发布更新呢？尽管这会减少延迟，但保证不了一致性。如果你允许更新的顺序根据是谁收到它们的而改变的话，就无法得到连续的共享状态。比如我们有两个client，改变两个不同的key的话，这会工作的很好，但如果这两个client想要在大致同一时间改变相同的key，它们会得到不同的值。</p>
<p>　　有几种不同的策略去保证在同一时间不同地方发生的变化的一致性。我们要使用的方法是把所有改变都集中起来。不管是client什么时候做出的更新，都会经过server被推送出去，这会强制让一个单独的序列按照它收到更新的顺序排列。</p>
<p><img src="/img/zmq60.png" alt="f60"></p>
<p>　　通过协调所有的更新，server就也能在所有的更新中添加一个唯一的序列编号了。有了唯一的序列，client就能检测严重故障了，包括网络冲突和队列溢出。如果一个client发现进入的数据流有个懂，它就会采取行动。client联系server去要缺失的数据看起来很合理，但在实际应用中却没什么用。如果存在”洞”，就是网络压力造成的，现在给网络增加更大的压力会让事情变得更糟。client能做的事就只是告诉用户”现在没办法继续”，停止，在有人手动检查过问题的原因之前不要重启。</p>
<p>　　现在我们就能在client保证状态更新了。下面是server:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonesrv3: Clone server, Model Three in C</span></span><br><span class="line"><span class="comment">//  Clone server - Model Three</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Routing information for a key-value snapshot</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *socket;           <span class="comment">//  ROUTER socket to send to</span></span><br><span class="line">    <span class="keyword">zframe_t</span> *identity;     <span class="comment">//  Identity of peer who requested state</span></span><br><span class="line">&#125; <span class="keyword">kvroute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Send one state snapshot key-value pair to a socket</span></span><br><span class="line"><span class="comment">//  Hash item data is our kvmsg object, ready to send</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_send_single (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">void</span> *data, <span class="keyword">void</span> *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kvroute_t</span> *kvroute = (<span class="keyword">kvroute_t</span> *) args;</span><br><span class="line">    <span class="comment">//  Send identity of recipient first</span></span><br><span class="line">    zframe_send (&amp;kvroute-&gt;identity,</span><br><span class="line">        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);</span><br><span class="line">    <span class="keyword">kvmsg_t</span> *kvmsg = (<span class="keyword">kvmsg_t</span> *) data;</span><br><span class="line">    kvmsg_send (kvmsg, kvroute-&gt;socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and sockets</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *snapshot = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    zsocket_bind (snapshot, <span class="string">"tcp://*:5556"</span>);</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:5557"</span>);</span><br><span class="line">    <span class="keyword">void</span> *collector = zsocket_new (ctx, ZMQ_PULL);</span><br><span class="line">    zsocket_bind (collector, <span class="string">"tcp://*:5558"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  The body of the main task collects updates from clients and</span></span><br><span class="line">    <span class="comment">//  publishes them back out to clients:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</span><br><span class="line">        &#123; collector, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; snapshot, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = zmq_poll (items, <span class="number">2</span>, <span class="number">1000</span> * ZMQ_POLL_MSEC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Apply state update sent from client</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (collector);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">            kvmsg_set_sequence (kvmsg, ++sequence);</span><br><span class="line">            kvmsg_send (kvmsg, publisher);</span><br><span class="line">            kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"I: publishing update %5d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Execute state snapshot request</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">zframe_t</span> *identity = zframe_recv (snapshot);</span><br><span class="line">            <span class="keyword">if</span> (!identity)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Request is in second frame of message</span></span><br><span class="line">            <span class="keyword">char</span> *request = zstr_recv (snapshot);</span><br><span class="line">            <span class="keyword">if</span> (streq (request, <span class="string">"ICANHAZ?"</span>))</span><br><span class="line">                <span class="built_in">free</span> (request);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"E: bad request, aborting\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  Send state snapshot to client</span></span><br><span class="line">            <span class="keyword">kvroute_t</span> routing = &#123; snapshot, identity &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  For each entry in kvmap, send kvmsg to client</span></span><br><span class="line">            zhash_foreach (kvmap, s_send_single, &amp;routing);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Now send END message with sequence number</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"I: sending shapshot=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (sequence);</span><br><span class="line">            kvmsg_set_key  (kvmsg, <span class="string">"KTHXBAI"</span>);</span><br><span class="line">            kvmsg_set_body (kvmsg, (byte *) <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">            kvmsg_send     (kvmsg, snapshot);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages handled\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是client:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonecli3: Clone client, Model Three in C</span></span><br><span class="line"><span class="comment">//  Clone client - Model Three</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and subscriber</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *snapshot = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (snapshot, <span class="string">"tcp://localhost:5556"</span>);</span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (subscriber, <span class="string">""</span>);</span><br><span class="line">    zsocket_connect (subscriber, <span class="string">"tcp://localhost:5557"</span>);</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUSH);</span><br><span class="line">    zsocket_connect (publisher, <span class="string">"tcp://localhost:5558"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  We first request a state snapshot:</span></span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    zstr_send (snapshot, <span class="string">"ICANHAZ?"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (snapshot);</span><br><span class="line">        <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">        <span class="keyword">if</span> (streq (kvmsg_key (kvmsg), <span class="string">"KTHXBAI"</span>)) &#123;</span><br><span class="line">            sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"I: received snapshot=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Done</span></span><br><span class="line">        &#125;</span><br><span class="line">        kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  Now we wait for updates from the server and every so often, we</span></span><br><span class="line">    <span class="comment">//  send a random key-value update to the server:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> alarm = zclock_time () + <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123; &#123; subscriber, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> tickless = (<span class="keyword">int</span>) ((alarm - zclock_time ()));</span><br><span class="line">        <span class="keyword">if</span> (tickless &lt; <span class="number">0</span>)</span><br><span class="line">            tickless = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rc = zmq_poll (items, <span class="number">1</span>, tickless * ZMQ_POLL_MSEC);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Context has been shut down</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (subscriber);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Discard out-of-sequence kvmsgs, incl. heartbeats</span></span><br><span class="line">            <span class="keyword">if</span> (kvmsg_sequence (kvmsg) &gt; sequence) &#123;</span><br><span class="line">                sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">                kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"I: received update=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  If we timed out, generate a random kvmsg</span></span><br><span class="line">        <span class="keyword">if</span> (zclock_time () &gt;= alarm) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (<span class="number">0</span>);</span><br><span class="line">            kvmsg_fmt_key  (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">10000</span>));</span><br><span class="line">            kvmsg_fmt_body (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">1000000</span>));</span><br><span class="line">            kvmsg_send     (kvmsg, publisher);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            alarm = zclock_time () + <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages in\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是关于第三版的一些说明：</p>
<ul>
<li>server整合进了一个任务。它管理一个负责接收更新的PULL socket，一个负责状态请求的ROUTER socket和一个负责发送更新的PUB socket。</li>
<li>client用一个无滴答的计时器向server每秒发送一个随机的更新。在实际实现中，我们会从应用代码中获取更新。</li>
</ul>
<p><strong>用子树工作  Working with Subtrees</strong></p>
<p>　　随着client数量的增加，我们的共享存储规模也会随之增大。向每个client都发送所有的信息会变得没有意义。这是pub-sub的一个传统问题：当你有很少的client的时候，你可以向所有的client发送所有的信息，随着规模的增长，这会变得很没效率。client在不同地方会很不一样。</p>
<p>　　因此即使当用一个共享的存储的时候，一些client也希望只用完整存储的一部分，我们称之为<em>子树 subtree</em>。client在它做出一个状态请求的时候必须请求该子树，并且当它订阅更新的时候也必须明确指定同一个子树。</p>
<p>　　对树来说有很多种常用的语法，一种就是<em>分层路径(path hierarchy)</em>，另一种是<em>主题树(topic tree)</em>。这些看起来像这样：</p>
<ul>
<li>分层路径：　/some/list/of/paths</li>
<li>主题树： some.list.of.topics</li>
</ul>
<p>　　我们会用分层路径，并扩展client和server好让client能用一个单独的子树工作。一旦你学会了怎么处理一个单独的子树，就会自己扩展去管理多子树了，当然是你的应用里需要的话。</p>
<p>　　下面是实现的server的子树，一个模型三的变体：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonesrv4: Clone server, Model Four in C</span></span><br><span class="line"><span class="comment">//  Clone server - Model Four</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Routing information for a key-value snapshot</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *socket;           <span class="comment">//  ROUTER socket to send to</span></span><br><span class="line">    <span class="keyword">zframe_t</span> *identity;     <span class="comment">//  Identity of peer who requested state</span></span><br><span class="line">    <span class="keyword">char</span> *subtree;          <span class="comment">//  Client subtree specification</span></span><br><span class="line">&#125; <span class="keyword">kvroute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Send one state snapshot key-value pair to a socket</span></span><br><span class="line"><span class="comment">//  Hash item data is our kvmsg object, ready to send</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_send_single (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">void</span> *data, <span class="keyword">void</span> *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kvroute_t</span> *kvroute = (<span class="keyword">kvroute_t</span> *) args;</span><br><span class="line">    <span class="keyword">kvmsg_t</span> *kvmsg = (<span class="keyword">kvmsg_t</span> *) data;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span> (kvroute-&gt;subtree) &lt;= <span class="built_in">strlen</span> (kvmsg_key (kvmsg))</span><br><span class="line">    &amp;&amp;  <span class="built_in">memcmp</span> (kvroute-&gt;subtree,</span><br><span class="line">                kvmsg_key (kvmsg), <span class="built_in">strlen</span> (kvroute-&gt;subtree)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//  Send identity of recipient first</span></span><br><span class="line">        zframe_send (&amp;kvroute-&gt;identity,</span><br><span class="line">            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);</span><br><span class="line">        kvmsg_send (kvmsg, kvroute-&gt;socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The main task is identical to clonesrv3 except for where it</span></span><br><span class="line"><span class="comment">//  handles subtrees.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and sockets</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *snapshot = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    zsocket_bind (snapshot, <span class="string">"tcp://*:5556"</span>);</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (publisher, <span class="string">"tcp://*:5557"</span>);</span><br><span class="line">    <span class="keyword">void</span> *collector = zsocket_new (ctx, ZMQ_PULL);</span><br><span class="line">    zsocket_bind (collector, <span class="string">"tcp://*:5558"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</span><br><span class="line">        &#123; collector, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; snapshot, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = zmq_poll (items, <span class="number">2</span>, <span class="number">1000</span> * ZMQ_POLL_MSEC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Apply state update sent from client</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (collector);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">            kvmsg_set_sequence (kvmsg, ++sequence);</span><br><span class="line">            kvmsg_send (kvmsg, publisher);</span><br><span class="line">            kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"I: publishing update %5d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Execute state snapshot request</span></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">zframe_t</span> *identity = zframe_recv (snapshot);</span><br><span class="line">            <span class="keyword">if</span> (!identity)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Request is in second frame of message</span></span><br><span class="line">            <span class="keyword">char</span> *request = zstr_recv (snapshot);</span><br><span class="line">            <span class="keyword">char</span> *subtree = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (streq (request, <span class="string">"ICANHAZ?"</span>)) &#123;</span><br><span class="line">                <span class="built_in">free</span> (request);</span><br><span class="line">                subtree = zstr_recv (snapshot);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"E: bad request, aborting\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  Send state snapshot to client</span></span><br><span class="line">            <span class="keyword">kvroute_t</span> routing = &#123; snapshot, identity, subtree &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  For each entry in kvmap, send kvmsg to client</span></span><br><span class="line">            zhash_foreach (kvmap, s_send_single, &amp;routing);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Now send END message with sequence number</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"I: sending shapshot=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (sequence);</span><br><span class="line">            kvmsg_set_key  (kvmsg, <span class="string">"KTHXBAI"</span>);</span><br><span class="line">            kvmsg_set_body (kvmsg, (byte *) subtree, <span class="number">0</span>);</span><br><span class="line">            kvmsg_send     (kvmsg, snapshot);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            <span class="built_in">free</span> (subtree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages handled\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面是相应的client:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clonecli4: Clone client, Model Four in C</span></span><br><span class="line"><span class="comment">//  Clone client - Model Four</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kvsimple.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  This client is identical to clonecli3 except for where we</span></span><br><span class="line"><span class="comment">//  handles subtrees.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUBTREE <span class="meta-string">"/client/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and subscriber</span></span><br><span class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">void</span> *snapshot = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (snapshot, <span class="string">"tcp://localhost:5556"</span>);</span><br><span class="line">    <span class="keyword">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (subscriber, <span class="string">""</span>);</span><br><span class="line">    zsocket_connect (subscriber, <span class="string">"tcp://localhost:5557"</span>);</span><br><span class="line">    zsocket_set_subscribe (subscriber, SUBTREE);</span><br><span class="line">    <span class="keyword">void</span> *publisher = zsocket_new (ctx, ZMQ_PUSH);</span><br><span class="line">    zsocket_connect (publisher, <span class="string">"tcp://localhost:5558"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">zhash_t</span> *kvmap = zhash_new ();</span><br><span class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  We first request a state snapshot:</span></span><br><span class="line">    <span class="keyword">int64_t</span> sequence = <span class="number">0</span>;</span><br><span class="line">    zstr_sendm (snapshot, <span class="string">"ICANHAZ?"</span>);</span><br><span class="line">    zstr_send  (snapshot, SUBTREE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (snapshot);</span><br><span class="line">        <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">        <span class="keyword">if</span> (streq (kvmsg_key (kvmsg), <span class="string">"KTHXBAI"</span>)) &#123;</span><br><span class="line">            sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"I: received snapshot=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            <span class="keyword">break</span>;          <span class="comment">//  Done</span></span><br><span class="line">        &#125;</span><br><span class="line">        kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int64_t</span> alarm = zclock_time () + <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123; &#123; subscriber, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> tickless = (<span class="keyword">int</span>) ((alarm - zclock_time ()));</span><br><span class="line">        <span class="keyword">if</span> (tickless &lt; <span class="number">0</span>)</span><br><span class="line">            tickless = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rc = zmq_poll (items, <span class="number">1</span>, tickless * ZMQ_POLL_MSEC);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Context has been shut down</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_recv (subscriber);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Discard out-of-sequence kvmsgs, incl. heartbeats</span></span><br><span class="line">            <span class="keyword">if</span> (kvmsg_sequence (kvmsg) &gt; sequence) &#123;</span><br><span class="line">                sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">                kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"I: received update=%d\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  If we timed out, generate a random kvmsg</span></span><br><span class="line">        <span class="keyword">if</span> (zclock_time () &gt;= alarm) &#123;</span><br><span class="line">            <span class="keyword">kvmsg_t</span> *kvmsg = kvmsg_new (<span class="number">0</span>);</span><br><span class="line">            kvmsg_fmt_key  (kvmsg, <span class="string">"%s%d"</span>, SUBTREE, randof (<span class="number">10000</span>));</span><br><span class="line">            kvmsg_fmt_body (kvmsg, <span class="string">"%d"</span>, randof (<span class="number">1000000</span>));</span><br><span class="line">            kvmsg_send     (kvmsg, publisher);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            alarm = zclock_time () + <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">" Interrupted\n%d messages in\n"</span>, (<span class="keyword">int</span>) sequence);</span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>临时值 Ephemeral Values</strong></p>
<p>　　临时值是那些不被定期更新就会自动过期的值。如果你想把克隆模型用于注册服务，那临时值就能让你做动态估计。一个节点加入网络，发布它的地址，然后按规律更新。如果该节点挂掉，它的地址最终就会被移除。</p>
<p>　　临时值的一个常用方法是把它们附加到一个<em>会话(session)</em>中，当会话结束的时候删除它们。在克隆模型中，会话由client定义，如果client死掉会话就会结束。一个简单点儿的实现是附加一个<em>剩余时间(time to live, TTL)</em>给临时值，该剩余时间由server使用去删除那些没有在指定时间内更新的数据。</p>
<p>　　不管什么时候我都尽可能使用的一个很好的设计原则是<em>不要在非必须的时候发明概念</em>。如果我们有很多个临时值，那会话会提供更好的行能。如果我们只有很少的临时值，那最好给每个都设置一个TTL。如果我们使用了大量的临时值，把它们附加到会话中并且适时过期会更有效。在目前这并不是一个问题，并且可能永远都不会遇到，因此会话就可以先不考虑了。</p>
<p>　　现在我们来实现临时值。首先，我们需要个在key-value　message中编码TTL的方法。可以增加个帧，但使用zmq帧结构的一个问题是每次我们想增加一个新属性，就必须改变message的结构。这破坏了兼容性。因此让我们给message增加个性质帧，写些能让我们存取属性值的代码。</p>
<p>　　其次，我们需要个方法，比如说”删除该key”。到目前为止，server和client都盲目的把新值插入或更新进它们的hash表。我们可以说如果value为空，就意味着”删除该key”。</p>
<p>　　下面是个更完整的kvmsg类的版本，它实现了属性帧(也增加了一个UUID帧，我们稍后会用到)。如果需要，它也处理了从hash表中删除key的任务：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  kvmsg: Key-value message class: full in C</span></span><br><span class="line"><span class="comment">//  kvmsg class - key-value message class for example applications</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "kvmsg.h"</span></span><br><span class="line"><span class="comment">#include &lt;uuid/uuid.h&gt;</span></span><br><span class="line"><span class="comment">#include "zlist.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Keys are short strings</span></span><br><span class="line"><span class="comment">#define KVMSG_KEY_MAX   255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Message is formatted on wire as 4 frames:</span></span><br><span class="line"><span class="comment">//  frame 0: key (0MQ string)</span></span><br><span class="line"><span class="comment">//  frame 1: sequence (8 bytes, network order)</span></span><br><span class="line"><span class="comment">//  frame 2: uuid (blob, 16 bytes)</span></span><br><span class="line"><span class="comment">//  frame 3: properties (0MQ string)</span></span><br><span class="line"><span class="comment">//  frame 4: body (blob)</span></span><br><span class="line"><span class="comment">#define FRAME_KEY       0</span></span><br><span class="line"><span class="comment">#define FRAME_SEQ       1</span></span><br><span class="line"><span class="comment">#define FRAME_UUID      2</span></span><br><span class="line"><span class="comment">#define FRAME_PROPS     3</span></span><br><span class="line"><span class="comment">#define FRAME_BODY      4</span></span><br><span class="line"><span class="comment">#define KVMSG_FRAMES    5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Structure of our class</span></span><br><span class="line">struct _kvmsg &#123;</span><br><span class="line">    <span class="comment">//  Presence indicators for each frame</span></span><br><span class="line">    <span class="keyword">int</span> present [KVMSG_FRAMES];</span><br><span class="line">    <span class="comment">//  Corresponding 0MQ message frames, if any</span></span><br><span class="line">    zmq_msg_t frame [KVMSG_FRAMES];</span><br><span class="line">    <span class="comment">//  Key, copied into safe C string</span></span><br><span class="line">    <span class="keyword">char</span> key [KVMSG_KEY_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//  List of properties, as name=value strings</span></span><br><span class="line">    zlist_t *props;</span><br><span class="line">    size_t props_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  These two helpers serialize a list of properties to and from a</span></span><br><span class="line"><span class="comment">//  message frame:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void</span><br><span class="line">s_encode_props (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_PROPS];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_PROPS])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line"></span><br><span class="line">    zmq_msg_init_size (msg, <span class="keyword">self</span>-&gt;props_size);</span><br><span class="line">    <span class="keyword">char</span> *prop = zlist_first (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    <span class="keyword">char</span> *dest = (<span class="keyword">char</span> *) zmq_msg_data (msg);</span><br><span class="line">    <span class="keyword">while</span> (prop) &#123;</span><br><span class="line">        strcpy (dest, prop);</span><br><span class="line">        dest += strlen (prop);</span><br><span class="line">        *dest++ = <span class="string">'\n'</span>;</span><br><span class="line">        prop = zlist_next (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_PROPS] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void</span><br><span class="line">s_decode_props (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_PROPS];</span><br><span class="line">    <span class="keyword">self</span>-&gt;props_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (zlist_size (<span class="keyword">self</span>-&gt;props))</span><br><span class="line">        free (zlist_pop (<span class="keyword">self</span>-&gt;props));</span><br><span class="line"></span><br><span class="line">    size_t remainder = zmq_msg_size (msg);</span><br><span class="line">    <span class="keyword">char</span> *prop = (<span class="keyword">char</span> *) zmq_msg_data (msg);</span><br><span class="line">    <span class="keyword">char</span> *eoln = memchr (prop, <span class="string">'\n'</span>, remainder);</span><br><span class="line">    <span class="keyword">while</span> (eoln) &#123;</span><br><span class="line">        *eoln = <span class="number">0</span>;</span><br><span class="line">        zlist_append (<span class="keyword">self</span>-&gt;props, strdup (prop));</span><br><span class="line">        <span class="keyword">self</span>-&gt;props_size += strlen (prop) + <span class="number">1</span>;</span><br><span class="line">        remainder -= strlen (prop) + <span class="number">1</span>;</span><br><span class="line">        prop = eoln + <span class="number">1</span>;</span><br><span class="line">        eoln = memchr (prop, <span class="string">'\n'</span>, remainder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Here are the constructor and destructor for the class:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Constructor, takes a sequence number for the new kvmsg instance:</span></span><br><span class="line">kvmsg_t *</span><br><span class="line">kvmsg_new (int64_t sequence)</span><br><span class="line">&#123;</span><br><span class="line">    kvmsg_t</span><br><span class="line">        *<span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));</span><br><span class="line">    <span class="keyword">self</span>-&gt;props = zlist_new ();</span><br><span class="line">    kvmsg_set_sequence (<span class="keyword">self</span>, sequence);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  zhash_free_fn callback helper that does the low level destruction:</span></span><br><span class="line">void</span><br><span class="line">kvmsg_free (void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        kvmsg_t *<span class="keyword">self</span> = (kvmsg_t *) ptr;</span><br><span class="line">        <span class="comment">//  Destroy message frames if any</span></span><br><span class="line">        <span class="keyword">int</span> frame_nbr;</span><br><span class="line">        <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr])</span><br><span class="line">                zmq_msg_close (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Destroy property list</span></span><br><span class="line">        <span class="keyword">while</span> (zlist_size (<span class="keyword">self</span>-&gt;props))</span><br><span class="line">            free (zlist_pop (<span class="keyword">self</span>-&gt;props));</span><br><span class="line">        zlist_destroy (&amp;<span class="keyword">self</span>-&gt;props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Free object itself</span></span><br><span class="line">        free (<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Destructor</span></span><br><span class="line">void</span><br><span class="line">kvmsg_destroy (kvmsg_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        kvmsg_free (*self_p);</span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method reads a key-value message from the socket and returns a</span></span><br><span class="line"><span class="comment">//  new kvmsg instance:</span></span><br><span class="line"></span><br><span class="line">kvmsg_t *</span><br><span class="line">kvmsg_recv (void *socket)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  This method is almost unchanged from kvsimple</span></span><br><span class="line">    assert (socket);</span><br><span class="line">    kvmsg_t *<span class="keyword">self</span> = kvmsg_new (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Read all frames off the wire, reject if bogus</span></span><br><span class="line">    <span class="keyword">int</span> frame_nbr;</span><br><span class="line">    <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr])</span><br><span class="line">            zmq_msg_close (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line">        zmq_msg_init (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line">        <span class="keyword">self</span>-&gt;present [frame_nbr] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (zmq_msg_recv (&amp;<span class="keyword">self</span>-&gt;frame [frame_nbr], socket, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            kvmsg_destroy (&amp;<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Verify multipart framing</span></span><br><span class="line">        <span class="keyword">int</span> rcvmore = (frame_nbr &lt; KVMSG_FRAMES - <span class="number">1</span>)? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (zsocket_rcvmore (socket) != rcvmore) &#123;</span><br><span class="line">            kvmsg_destroy (&amp;<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">        s_decode_props (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Send key-value message to socket; any empty frames are sent as such.</span></span><br><span class="line">void</span><br><span class="line">kvmsg_send (kvmsg_t *<span class="keyword">self</span>, void *socket)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    assert (socket);</span><br><span class="line"></span><br><span class="line">    s_encode_props (<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">//  The rest of the method is unchanged from kvsimple</span></span><br><span class="line">    <span class="keyword">int</span> frame_nbr;</span><br><span class="line">    <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) &#123;</span><br><span class="line">        zmq_msg_t copy;</span><br><span class="line">        zmq_msg_init (&amp;copy);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr])</span><br><span class="line">            zmq_msg_copy (&amp;copy, &amp;<span class="keyword">self</span>-&gt;frame [frame_nbr]);</span><br><span class="line">        zmq_msg_send (&amp;copy, socket,</span><br><span class="line">            (frame_nbr &lt; KVMSG_FRAMES - <span class="number">1</span>)? ZMQ_SNDMORE: <span class="number">0</span>);</span><br><span class="line">        zmq_msg_close (&amp;copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method duplicates a kvmsg instance, returns the new instance:</span></span><br><span class="line"></span><br><span class="line">kvmsg_t *</span><br><span class="line">kvmsg_dup (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    kvmsg_t *kvmsg = kvmsg_new (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> frame_nbr;</span><br><span class="line">    <span class="keyword">for</span> (frame_nbr = <span class="number">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [frame_nbr]) &#123;</span><br><span class="line">            zmq_msg_t *src = &amp;<span class="keyword">self</span>-&gt;frame [frame_nbr];</span><br><span class="line">            zmq_msg_t *dst = &amp;kvmsg-&gt;frame [frame_nbr];</span><br><span class="line">            zmq_msg_init_size (dst, zmq_msg_size (src));</span><br><span class="line">            memcpy (zmq_msg_data (dst),</span><br><span class="line">                    zmq_msg_data (src), zmq_msg_size (src));</span><br><span class="line">            kvmsg-&gt;present [frame_nbr] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kvmsg-&gt;props_size = zlist_size (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    <span class="keyword">char</span> *prop = (<span class="keyword">char</span> *) zlist_first (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    <span class="keyword">while</span> (prop) &#123;</span><br><span class="line">        zlist_append (kvmsg-&gt;props, strdup (prop));</span><br><span class="line">        prop = (<span class="keyword">char</span> *) zlist_next (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kvmsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The key, sequence, body, and size methods are the same as in kvsimple.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Return key from last read message, if any, else NULL</span></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">kvmsg_key (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_KEY]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!*<span class="keyword">self</span>-&gt;key) &#123;</span><br><span class="line">            size_t size = zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_KEY]);</span><br><span class="line">            <span class="keyword">if</span> (size &gt; KVMSG_KEY_MAX)</span><br><span class="line">                size = KVMSG_KEY_MAX;</span><br><span class="line">            memcpy (<span class="keyword">self</span>-&gt;key,</span><br><span class="line">                zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_KEY]), size);</span><br><span class="line">            <span class="keyword">self</span>-&gt;key [size] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set message key as provided</span></span><br><span class="line">void</span><br><span class="line">kvmsg_set_key (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_KEY];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_KEY])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    zmq_msg_init_size (msg, strlen (key));</span><br><span class="line">    memcpy (zmq_msg_data (msg), key, strlen (key));</span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_KEY] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set message key using printf format</span></span><br><span class="line">void</span><br><span class="line">kvmsg_fmt_key (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *format, …)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> value [KVMSG_KEY_MAX + <span class="number">1</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    va_start (args, format);</span><br><span class="line">    vsnprintf (value, KVMSG_KEY_MAX, format, args);</span><br><span class="line">    va_end (args);</span><br><span class="line">    kvmsg_set_key (<span class="keyword">self</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Return sequence nbr from last read message, if any</span></span><br><span class="line">int64_t</span><br><span class="line">kvmsg_sequence (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_SEQ]) &#123;</span><br><span class="line">        assert (zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_SEQ]) == <span class="number">8</span>);</span><br><span class="line">        byte *source = zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_SEQ]);</span><br><span class="line">        int64_t sequence = ((int64_t) (source [<span class="number">0</span>]) &lt;&lt; <span class="number">56</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">1</span>]) &lt;&lt; <span class="number">48</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">2</span>]) &lt;&lt; <span class="number">40</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">3</span>]) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">4</span>]) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">5</span>]) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                         + ((int64_t) (source [<span class="number">6</span>]) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                         +  (int64_t) (source [<span class="number">7</span>]);</span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set message sequence number</span></span><br><span class="line">void</span><br><span class="line">kvmsg_set_sequence (kvmsg_t *<span class="keyword">self</span>, int64_t sequence)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_SEQ];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_SEQ])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    zmq_msg_init_size (msg, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    byte *source = zmq_msg_data (msg);</span><br><span class="line">    source [<span class="number">0</span>] = (byte) ((sequence &gt;&gt; <span class="number">56</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">1</span>] = (byte) ((sequence &gt;&gt; <span class="number">48</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">2</span>] = (byte) ((sequence &gt;&gt; <span class="number">40</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">3</span>] = (byte) ((sequence &gt;&gt; <span class="number">32</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">4</span>] = (byte) ((sequence &gt;&gt; <span class="number">24</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">5</span>] = (byte) ((sequence &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">6</span>] = (byte) ((sequence &gt;&gt; <span class="number">8</span>)  &amp; <span class="number">255</span>);</span><br><span class="line">    source [<span class="number">7</span>] = (byte) ((sequence)       &amp; <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_SEQ] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Return body from last read message, if any, else NULL</span></span><br><span class="line">byte *</span><br><span class="line">kvmsg_body (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_BODY])</span><br><span class="line">        <span class="keyword">return</span> (byte *) zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_BODY]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set message body</span></span><br><span class="line">void</span><br><span class="line">kvmsg_set_body (kvmsg_t *<span class="keyword">self</span>, byte *body, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_BODY];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_BODY])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_BODY] = <span class="number">1</span>;</span><br><span class="line">    zmq_msg_init_size (msg, size);</span><br><span class="line">    memcpy (zmq_msg_data (msg), body, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set message body using printf format</span></span><br><span class="line">void</span><br><span class="line">kvmsg_fmt_body (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *format, …)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> value [<span class="number">255</span> + <span class="number">1</span>];</span><br><span class="line">    va_list args;</span><br><span class="line"></span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    va_start (args, format);</span><br><span class="line">    vsnprintf (value, <span class="number">255</span>, format, args);</span><br><span class="line">    va_end (args);</span><br><span class="line">    kvmsg_set_body (<span class="keyword">self</span>, (byte *) value, strlen (value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Return body size from last read message, if any, else zero</span></span><br><span class="line">size_t</span><br><span class="line">kvmsg_size (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_BODY])</span><br><span class="line">        <span class="keyword">return</span> zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_BODY]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  These methods get and set the UUID for the key-value message:</span></span><br><span class="line"></span><br><span class="line">byte *</span><br><span class="line">kvmsg_uuid (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_UUID]</span><br><span class="line">    &amp;&amp;  zmq_msg_size (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_UUID]) == sizeof (uuid_t))</span><br><span class="line">        <span class="keyword">return</span> (byte *) zmq_msg_data (&amp;<span class="keyword">self</span>-&gt;frame [FRAME_UUID]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Sets the UUID to a randomly generated value</span></span><br><span class="line">void</span><br><span class="line">kvmsg_set_uuid (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmq_msg_t *msg = &amp;<span class="keyword">self</span>-&gt;frame [FRAME_UUID];</span><br><span class="line">    uuid_t uuid;</span><br><span class="line">    uuid_generate (uuid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_UUID])</span><br><span class="line">        zmq_msg_close (msg);</span><br><span class="line">    zmq_msg_init_size (msg, sizeof (uuid));</span><br><span class="line">    memcpy (zmq_msg_data (msg), uuid, sizeof (uuid));</span><br><span class="line">    <span class="keyword">self</span>-&gt;present [FRAME_UUID] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  These methods get and set a specified message property:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Get message property, return "" if no such property is defined.</span></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">kvmsg_get_prop (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    assert (strchr (name, <span class="string">'='</span>) == <span class="keyword">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> *prop = zlist_first (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    size_t namelen = strlen (name);</span><br><span class="line">    <span class="keyword">while</span> (prop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strlen (prop) &gt; namelen</span><br><span class="line">        &amp;&amp;  memcmp (prop, name, namelen) == <span class="number">0</span></span><br><span class="line">        &amp;&amp;  prop [namelen] == <span class="string">'='</span>)</span><br><span class="line">            <span class="keyword">return</span> prop + namelen + <span class="number">1</span>;</span><br><span class="line">        prop = zlist_next (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set message property. Property name cannot contain '='. Max length of</span></span><br><span class="line"><span class="comment">//  value is 255 chars.</span></span><br><span class="line">void</span><br><span class="line">kvmsg_set_prop (kvmsg_t *<span class="keyword">self</span>, <span class="keyword">char</span> *name, <span class="keyword">char</span> *format, …)</span><br><span class="line">&#123;</span><br><span class="line">    assert (strchr (name, <span class="string">'='</span>) == <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value [<span class="number">255</span> + <span class="number">1</span>];</span><br><span class="line">    va_list args;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    va_start (args, format);</span><br><span class="line">    vsnprintf (value, <span class="number">255</span>, format, args);</span><br><span class="line">    va_end (args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Allocate name=value string</span></span><br><span class="line">    <span class="keyword">char</span> *prop = malloc (strlen (name) + strlen (value) + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Remove existing property if any</span></span><br><span class="line">    sprintf (prop, <span class="string">"%s="</span>, name);</span><br><span class="line">    <span class="keyword">char</span> *existing = zlist_first (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    <span class="keyword">while</span> (existing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memcmp (prop, existing, strlen (prop)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>-&gt;props_size -= strlen (existing) + <span class="number">1</span>;</span><br><span class="line">            zlist_remove (<span class="keyword">self</span>-&gt;props, existing);</span><br><span class="line">            free (existing);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        existing = zlist_next (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  Add new name=value property string</span></span><br><span class="line">    strcat (prop, value);</span><br><span class="line">    zlist_append (<span class="keyword">self</span>-&gt;props, prop);</span><br><span class="line">    <span class="keyword">self</span>-&gt;props_size += strlen (prop) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method stores the key-value message into a hash map, unless</span></span><br><span class="line"><span class="comment">//  the key and value are both null. It nullifies the kvmsg reference</span></span><br><span class="line"><span class="comment">//  so that the object is owned by the hash map, not the caller:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_store (kvmsg_t **self_p, zhash_t *hash)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        kvmsg_t *<span class="keyword">self</span> = *self_p;</span><br><span class="line">        assert (<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">if</span> (kvmsg_size (<span class="keyword">self</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;present [FRAME_KEY]</span><br><span class="line">            &amp;&amp;  <span class="keyword">self</span>-&gt;present [FRAME_BODY]) &#123;</span><br><span class="line">                zhash_update (hash, kvmsg_key (<span class="keyword">self</span>), <span class="keyword">self</span>);</span><br><span class="line">                zhash_freefn (hash, kvmsg_key (<span class="keyword">self</span>), kvmsg_free);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zhash_delete (hash, kvmsg_key (<span class="keyword">self</span>));</span><br><span class="line"></span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method extends the kvsimple implementation with support for</span></span><br><span class="line"><span class="comment">//  message properties:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvmsg_dump (kvmsg_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">            fprintf (stderr, <span class="string">"NULL"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t size = kvmsg_size (<span class="keyword">self</span>);</span><br><span class="line">        byte  *body = kvmsg_body (<span class="keyword">self</span>);</span><br><span class="line">        fprintf (stderr, <span class="string">"[seq:%"</span> PRId64 <span class="string">"]"</span>, kvmsg_sequence (<span class="keyword">self</span>));</span><br><span class="line">        fprintf (stderr, <span class="string">"[key:%s]"</span>, kvmsg_key (<span class="keyword">self</span>));</span><br><span class="line">        fprintf (stderr, <span class="string">"[size:%zd] "</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (zlist_size (<span class="keyword">self</span>-&gt;props)) &#123;</span><br><span class="line">            fprintf (stderr, <span class="string">"["</span>);</span><br><span class="line">            <span class="keyword">char</span> *prop = zlist_first (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">            <span class="keyword">while</span> (prop) &#123;</span><br><span class="line">                fprintf (stderr, <span class="string">"%s;"</span>, prop);</span><br><span class="line">                prop = zlist_next (<span class="keyword">self</span>-&gt;props);</span><br><span class="line">            &#125;</span><br><span class="line">            fprintf (stderr, <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> char_nbr;</span><br><span class="line">        <span class="keyword">for</span> (char_nbr = <span class="number">0</span>; char_nbr &lt; size; char_nbr++)</span><br><span class="line">            fprintf (stderr, <span class="string">"%02X"</span>, body [char_nbr]);</span><br><span class="line">        fprintf (stderr, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf (stderr, <span class="string">"NULL message\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This method is the same as in kvsimple with added support</span></span><br><span class="line"><span class="comment">//  for the uuid and property features of kvmsg:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">kvmsg_test (<span class="keyword">int</span> verbose)</span><br><span class="line">&#123;</span><br><span class="line">    kvmsg_t</span><br><span class="line">        *kvmsg;</span><br><span class="line"></span><br><span class="line">    printf (<span class="string">" * kvmsg: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Prepare our context and sockets</span></span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *output = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    <span class="keyword">int</span> rc = zmq_bind (output, <span class="string">"ipc://kvmsg_selftest.ipc"</span>);</span><br><span class="line">    assert (rc == <span class="number">0</span>);</span><br><span class="line">    void *input = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    rc = zmq_connect (input, <span class="string">"ipc://kvmsg_selftest.ipc"</span>);</span><br><span class="line">    assert (rc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    zhash_t *kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Test send and receive of simple message</span></span><br><span class="line">    kvmsg = kvmsg_new (<span class="number">1</span>);</span><br><span class="line">    kvmsg_set_key  (kvmsg, <span class="string">"key"</span>);</span><br><span class="line">    kvmsg_set_uuid (kvmsg);</span><br><span class="line">    kvmsg_set_body (kvmsg, (byte *) <span class="string">"body"</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        kvmsg_dump (kvmsg);</span><br><span class="line">    kvmsg_send (kvmsg, output);</span><br><span class="line">    kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line"></span><br><span class="line">    kvmsg = kvmsg_recv (input);</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        kvmsg_dump (kvmsg);</span><br><span class="line">    assert (streq (kvmsg_key (kvmsg), <span class="string">"key"</span>));</span><br><span class="line">    kvmsg_store (&amp;kvmsg, kvmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Test send and receive of message with properties</span></span><br><span class="line">    kvmsg = kvmsg_new (<span class="number">2</span>);</span><br><span class="line">    kvmsg_set_prop (kvmsg, <span class="string">"prop1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    kvmsg_set_prop (kvmsg, <span class="string">"prop2"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    kvmsg_set_prop (kvmsg, <span class="string">"prop2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    kvmsg_set_key  (kvmsg, <span class="string">"key"</span>);</span><br><span class="line">    kvmsg_set_uuid (kvmsg);</span><br><span class="line">    kvmsg_set_body (kvmsg, (byte *) <span class="string">"body"</span>, <span class="number">4</span>);</span><br><span class="line">    assert (streq (kvmsg_get_prop (kvmsg, <span class="string">"prop2"</span>), <span class="string">"value2"</span>));</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        kvmsg_dump (kvmsg);</span><br><span class="line">    kvmsg_send (kvmsg, output);</span><br><span class="line">    kvmsg_destroy (&amp;kvmsg);</span><br><span class="line"></span><br><span class="line">    kvmsg = kvmsg_recv (input);</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        kvmsg_dump (kvmsg);</span><br><span class="line">    assert (streq (kvmsg_key (kvmsg), <span class="string">"key"</span>));</span><br><span class="line">    assert (streq (kvmsg_get_prop (kvmsg, <span class="string">"prop2"</span>), <span class="string">"value2"</span>));</span><br><span class="line">    kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">    <span class="comment">//  Shutdown and destroy all objects</span></span><br><span class="line">    zhash_destroy (&amp;kvmap);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line"></span><br><span class="line">    printf (<span class="string">"OK\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  模型5的client跟模型４的差不多一样。它现在使用了完整版的kvmsg类，在每条message上都设置了一个随机的ttl属性(秒级):<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kvmsg_set_prop(<span class="name">kvmsg</span>, <span class="string">"ttl"</span>, <span class="string">"%d"</span>, randof(<span class="number">30</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用反应器　Using a Reactor</strong></p>
<p>　　到现在，我们在server使用了一个轮询循环。在下个模型的server中，我们会换成使用反应器。在C中，我们使用CZMQ的<code>zloop</code>类。使用反应器会让代码更多，但更易理解和构建，因为server的每个部分都在一个单独的反应器句柄中得到处理。</p>
<p>　　我们使用一个单独的线程，在反应器句柄之间传递一个server对象。我们可以把server组织成多线程，每个管理一个socket或者定时器，但多线程在没有共享数据的时候才会工作的更好。在本例中所有的工作都围绕这server的hash表，因此单线程更简单。</p>
<p>　　下面是三个反应器句柄：</p>
<ul>
<li>一个处理来自ROUTER socket上的快照请求。</li>
<li>一个处理来自PULL socket的client的更新。</li>
<li>一个负责清除那些已经超过TTL的临时值。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonesrv5: Clone server, Model Five in C</span></span><br><span class="line"><span class="comment">//  Clone server - Model Five</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line">#include <span class="string">"kvmsg.c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  zloop reactor handlers</span></span><br><span class="line"><span class="keyword">static</span> int s_snapshots (zloop_t *<span class="keyword">loop</span>, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> int s_collector (zloop_t *<span class="keyword">loop</span>, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> int s_flush_ttl (zloop_t *<span class="keyword">loop</span>, zmq_pollitem_t *poller, void *args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Our server is defined by these properties</span></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    zctx_t *ctx;                <span class="comment">//  Context wrapper</span></span><br><span class="line">    zhash_t *kvmap;             <span class="comment">//  Key-value store</span></span><br><span class="line">    zloop_t *<span class="keyword">loop</span>;              <span class="comment">//  zloop reactor</span></span><br><span class="line">    int port;                   <span class="comment">//  Main port we're working on</span></span><br><span class="line">    int64_t sequence;           <span class="comment">//  How many updates we're at</span></span><br><span class="line">    void *snapshot;             <span class="comment">//  Handle snapshot requests</span></span><br><span class="line">    void *publisher;            <span class="comment">//  Publish updates to clients</span></span><br><span class="line">    void *collector;            <span class="comment">//  Collect updates from clients</span></span><br><span class="line">&#125; clonesrv_t;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) zmalloc (<span class="keyword">sizeof</span> (clonesrv_t));</span><br><span class="line">    <span class="keyword">self</span>-&gt;port = <span class="number">5556</span>;</span><br><span class="line">    <span class="keyword">self</span>-&gt;ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">self</span>-&gt;kvmap = zhash_new ();</span><br><span class="line">    <span class="keyword">self</span>-&gt;<span class="keyword">loop</span> = zloop_new ();</span><br><span class="line">    zloop_set_verbose (<span class="keyword">self</span>-&gt;<span class="keyword">loop</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Set up our clone server sockets</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;snapshot  = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_ROUTER);</span><br><span class="line">    zsocket_bind (<span class="keyword">self</span>-&gt;snapshot,  <span class="string">"tcp://*:%d"</span>, <span class="keyword">self</span>-&gt;port);</span><br><span class="line">    <span class="keyword">self</span>-&gt;publisher = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (<span class="keyword">self</span>-&gt;publisher, <span class="string">"tcp://*:%d"</span>, <span class="keyword">self</span>-&gt;port + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">self</span>-&gt;collector = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_PULL);</span><br><span class="line">    zsocket_bind (<span class="keyword">self</span>-&gt;collector, <span class="string">"tcp://*:%d"</span>, <span class="keyword">self</span>-&gt;port + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Register our handlers with reactor</span></span><br><span class="line">    zmq_pollitem_t poller = &#123; <span class="number">0</span>, <span class="number">0</span>, ZMQ_POLLIN &#125;;</span><br><span class="line">    poller.socket = <span class="keyword">self</span>-&gt;snapshot;</span><br><span class="line">    zloop_poller (<span class="keyword">self</span>-&gt;<span class="keyword">loop</span>, &amp;poller, s_snapshots, <span class="keyword">self</span>);</span><br><span class="line">    poller.socket = <span class="keyword">self</span>-&gt;collector;</span><br><span class="line">    zloop_poller (<span class="keyword">self</span>-&gt;<span class="keyword">loop</span>, &amp;poller, s_collector, <span class="keyword">self</span>);</span><br><span class="line">    zloop_timer (<span class="keyword">self</span>-&gt;<span class="keyword">loop</span>, <span class="number">1000</span>, <span class="number">0</span>, s_flush_ttl, <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Run reactor until process interrupted</span></span><br><span class="line">    zloop_start (<span class="keyword">self</span>-&gt;<span class="keyword">loop</span>);</span><br><span class="line"></span><br><span class="line">    zloop_destroy (&amp;<span class="keyword">self</span>-&gt;<span class="keyword">loop</span>);</span><br><span class="line">    zhash_destroy (&amp;<span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">    zctx_destroy (&amp;<span class="keyword">self</span>-&gt;ctx);</span><br><span class="line">    free (<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  We handle ICANHAZ? requests by sending snapshot data to the</span></span><br><span class="line"><span class="comment">//  client that requested it:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Routing information for a key-value snapshot</span></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    void *socket;           <span class="comment">//  ROUTER socket to send to</span></span><br><span class="line">    zframe_t *identity;     <span class="comment">//  Identity of peer who requested state</span></span><br><span class="line">    <span class="built_in">char</span> *subtree;          <span class="comment">//  Client subtree specification</span></span><br><span class="line">&#125; kvroute_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  We call this function for each key-value pair in our hash table</span></span><br><span class="line"><span class="keyword">static</span> int</span><br><span class="line">s_send_single (<span class="keyword">const</span> <span class="built_in">char</span> *key, void *data, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    kvroute_t *kvroute = (kvroute_t *) args;</span><br><span class="line">    kvmsg_t *kvmsg = (kvmsg_t *) data;</span><br><span class="line">    <span class="keyword">if</span> (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))</span><br><span class="line">    &amp;&amp;  memcmp (kvroute-&gt;subtree,</span><br><span class="line">                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == <span class="number">0</span>) &#123;</span><br><span class="line">        zframe_send (&amp;kvroute-&gt;identity,    <span class="comment">//  Choose recipient</span></span><br><span class="line">            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);</span><br><span class="line">        kvmsg_send (kvmsg, kvroute-&gt;socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This is the reactor handler for the snapshot socket; it accepts</span></span><br><span class="line"><span class="comment">//  just the ICANHAZ? request and replies with a state snapshot ending</span></span><br><span class="line"><span class="comment">//  with a KTHXBAI message:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int</span><br><span class="line">s_snapshots (zloop_t *<span class="keyword">loop</span>, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    zframe_t *identity = zframe_recv (poller-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (identity) &#123;</span><br><span class="line">        <span class="comment">//  Request is in second frame of message</span></span><br><span class="line">        <span class="built_in">char</span> *request = zstr_recv (poller-&gt;socket);</span><br><span class="line">        <span class="built_in">char</span> *subtree = NULL;</span><br><span class="line">        <span class="keyword">if</span> (streq (request, <span class="string">"ICANHAZ?"</span>)) &#123;</span><br><span class="line">            free (request);</span><br><span class="line">            subtree = zstr_recv (poller-&gt;socket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            printf (<span class="string">"E: bad request, aborting\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subtree) &#123;</span><br><span class="line">            <span class="comment">//  Send state socket to client</span></span><br><span class="line">            kvroute_t routing = &#123; poller-&gt;socket, identity, subtree &#125;;</span><br><span class="line">            zhash_foreach (<span class="keyword">self</span>-&gt;kvmap, s_send_single, &amp;routing);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Now send END message with sequence number</span></span><br><span class="line">            zclock_log (<span class="string">"I: sending shapshot=%d"</span>, (int) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">            zframe_send (&amp;identity, poller-&gt;socket, ZFRAME_MORE);</span><br><span class="line">            kvmsg_t *kvmsg = kvmsg_new (<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">            kvmsg_set_key  (kvmsg, <span class="string">"KTHXBAI"</span>);</span><br><span class="line">            kvmsg_set_body (kvmsg, (byte *) subtree, <span class="number">0</span>);</span><br><span class="line">            kvmsg_send     (kvmsg, poller-&gt;socket);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            free (subtree);</span><br><span class="line">        &#125;</span><br><span class="line">        zframe_destroy(&amp;identity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  We store each update with a new sequence number, and if necessary, a</span></span><br><span class="line"><span class="comment">//  time-to-live. We publish updates immediately on our publisher socket:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int</span><br><span class="line">s_collector (zloop_t *<span class="keyword">loop</span>, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    kvmsg_t *kvmsg = kvmsg_recv (poller-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (kvmsg) &#123;</span><br><span class="line">        kvmsg_set_sequence (kvmsg, ++<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        kvmsg_send (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">        int ttl = atoi (kvmsg_get_prop (kvmsg, <span class="string">"ttl"</span>));</span><br><span class="line">        <span class="keyword">if</span> (ttl)</span><br><span class="line">            kvmsg_set_prop (kvmsg, <span class="string">"ttl"</span>,</span><br><span class="line">                <span class="string">"%"</span> PRId64, zclock_time () + ttl * <span class="number">1000</span>);</span><br><span class="line">        kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">        zclock_log (<span class="string">"I: publishing update=%d"</span>, (int) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  At regular intervals, we flush ephemeral values that have expired. This</span></span><br><span class="line"><span class="comment">//  could be slow on very large data sets:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  If key-value pair has expired, delete it and publish the</span></span><br><span class="line"><span class="comment">//  fact to listening clients.</span></span><br><span class="line"><span class="keyword">static</span> int</span><br><span class="line">s_flush_single (<span class="keyword">const</span> <span class="built_in">char</span> *key, void *data, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    kvmsg_t *kvmsg = (kvmsg_t *) data;</span><br><span class="line">    int64_t ttl;</span><br><span class="line">    sscanf (kvmsg_get_prop (kvmsg, <span class="string">"ttl"</span>), <span class="string">"%"</span> PRId64, &amp;ttl);</span><br><span class="line">    <span class="keyword">if</span> (ttl &amp;&amp; zclock_time () &gt;= ttl) &#123;</span><br><span class="line">        kvmsg_set_sequence (kvmsg, ++<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        kvmsg_set_body (kvmsg, (byte *) <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">        kvmsg_send (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">        kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">        zclock_log (<span class="string">"I: publishing delete=%d"</span>, (int) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int</span><br><span class="line">s_flush_ttl (zloop_t *<span class="keyword">loop</span>, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;kvmap)</span><br><span class="line">        zhash_foreach (<span class="keyword">self</span>-&gt;kvmap, s_flush_single, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>给可靠性添加双子星模型　Adding the Binary Star Pattern for Reliability</strong></p>
<p>　　到目前位置我们研究的克隆模型还比较简单。现在我们就要进入相当复杂的部分了，这让我又需要再去拿一杯浓缩咖啡。你会发现要设计”可靠的”消息机制相当复杂，需要在设计之前就问自己”到底需不需要这个？”如果使用不可靠的或”足够”可靠的系统就能应付过去，那就可以少费很多功夫。当然，你也可能会时不时丢些数据。这经常是个需要权衡的问题。因为这杯咖啡相当好喝，我们就开始跳进这个深坑吧。</p>
<p>　　在你运行这最后一个模型的时候，你需要停止然后重启server。这看起来像是它恢复过来了，但当然是它把更新放到了一个空的状态存储而不是真正的当前状态存储中。任何新加入的client只会得到最近的更新而得不到完整的历史更新。</p>
<p>　　我们想要的就是一种让server从中断或崩溃中恢复过来的方法。我们也需要在server停止一定时间服务的时候提供备份。当某人要求”可靠性”的时候，问问他们想要处理哪些故障。在本例中，有这些故障：</p>
<ul>
<li>server进程崩溃然后自动或手动重启。该进程丢了它的状态，必须从某处恢复过来。</li>
<li>server机器挂掉并且很长时间掉线。client必须切换到替代server上。</li>
<li>server进程或机器断网了，比如交换机或数据中心挂掉了。它在某个时候可能会恢复，但同时client需要有个备份server。</li>
</ul>
<p>　　第一步是要添加第二个server。我们可以用第四章的双子星模型，把这两个server组织成主server和备份server。双子星是个反应器，因此我们把最后这个server模型重构成反应器模式是很有用的。</p>
<p>　　我们需要保证如果主server挂掉的话没有丢失更新。最简单的方法就是把它们发送给两个server。备份server然后就像一个client那样工作，通过接收更新保持状态同步。它也会从client那里拿到新的更新。它还不能把这些更新放到自己的hash表中，但可以保持一端时间。</p>
<p>　　因此，模型６从模型５的基础上引入了如下改变：</p>
<ul>
<li>我们使用一个pub-sub流而不是push-pull流来做client发送到server的更新。这考虑到需要向两个server都发送更新。否则我们就必须使用两个DEALER socket。</li>
<li>我们给server的更新(给client的)添加了心跳，好让在主server挂掉的时候client能检测到，然后它能切换到备份服务器上。</li>
<li>我们用双子星bstar反应器类连接这两个server。双子星依赖client向它们认为活跃的server发送明确的请求来投票。我们会使用快照请求作为投票机制。</li>
<li>我们通过增加一个UUID字段保证所有的更新message都是唯一的。client生成它，然后server会在重新发布出来的更新中传递它。</li>
<li>不活跃的server会保存一份它从client接收的更新的”待定列表(pending list)”，而不是从活跃的server上拿来；或者从活跃的server上拿来，而不是从client上。该列表从旧到新依次排列，因此很容易就移除头部的更新。</li>
</ul>
<p><img src="/img/zmq61.png" alt="f61"></p>
<p>  把client的逻辑设计成一个有限状态机很有用，client循环经过三种状态：</p>
<ul>
<li>client打开并连接它的socket，然后向第一个server请求快照。为了避免请求风暴，它只会询问任一指定的server两次。请求可能会丢失，这运气就比较糟糕了。两个都丢失的可能性会少很多。</li>
<li>client等着当前server的一个回复(快照数据)，如果拿到，就存储起来。如果在一段时间内没有回复，它就会切换到另一台server上去。</li>
<li>当client已经拿到它的快照，就等着并处理更新。再次，如果它在一段时间内没有收到server的任何数据，就切换到另一台server上去。</li>
</ul>
<p>　　client会永远循环。很可能在启动或者进行故障转移的时候一些client会试着连接主server而另一些尝试跟备份server通信。双子星状态机会处理这种情况，确切来说是希望能处理。很难保证软件的正确性：相反我们会不断锤炼它直到没有错。</p>
<p>　　故障转移会按照以下步骤进行：</p>
<ul>
<li>client检测到主server不再发送心跳，并且得出它挂掉的结论。然后client去连接备份server并发送一个新的状态快照请求。</li>
<li>备份server从client接收到快照请求，然后它检测到主server已经挂掉了，就替换掉主server。</li>
<li>备份server把它的待定列表添加到自己的hash表中，然后开始处理状态快照请求。</li>
</ul>
<p>　　当主server恢复过来，它会：</p>
<ul>
<li>启动然后变成不活跃的server，作为一个克隆模型的client连接到备份server。</li>
<li>通过它自己的SUB　socket接收从client的更新。</li>
</ul>
<p>　　我们会做出如下的假设：</p>
<ul>
<li>至少一个server会持续运行。如果两台server都挂掉，就会丢失所有的server状态并且没办法恢复。</li>
<li>多client不会在同一时间更新相同的hash key。client的更新会按照不同的顺序抵达两台server。因此，备份server可能会按照跟主server可能会做或已经做了的顺序不同的顺序从它的待定列表中应用更新。从一个client来的更新总是会按照相同的顺序抵达两台server，因此它是安全的。</li>
</ul>
<p>　　因此我们使用双子星模型的高可靠性server组的框架会有两个server和一组跟两台server都通信的client组成。</p>
<p><img src="/img/zmq62.png" alt="f62"></p>
<p>　　下面是克隆模型server的第六个也是最后一个模型：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonesrv6: Clone server, Model Six in C</span></span><br><span class="line"><span class="comment">//  Clone server Model Six</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="comment">#include "bstar.c"</span></span><br><span class="line"><span class="comment">#include "kvmsg.c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  We define a set of reactor handlers and our server object structure:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Bstar reactor handlers</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_snapshots   (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_collector   (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_flush_ttl   (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_send_hugz   (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_new_active  (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_new_passive (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">    s_subscriber  (zloop_t *loop, zmq_pollitem_t *poller, void *args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Our server is defined by these properties</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    zctx_t *ctx;                <span class="comment">//  Context wrapper</span></span><br><span class="line">    zhash_t *kvmap;             <span class="comment">//  Key-value store</span></span><br><span class="line">    bstar_t *bstar;             <span class="comment">//  Bstar reactor core</span></span><br><span class="line">    int64_t sequence;           <span class="comment">//  How many updates we're at</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">//  Main port we're working on</span></span><br><span class="line">    <span class="keyword">int</span> peer;                   <span class="comment">//  Main port of our peer</span></span><br><span class="line">    void *publisher;            <span class="comment">//  Publish updates and hugz</span></span><br><span class="line">    void *collector;            <span class="comment">//  Collect updates from clients</span></span><br><span class="line">    void *subscriber;           <span class="comment">//  Get updates from peer</span></span><br><span class="line">    zlist_t *pending;           <span class="comment">//  Pending updates from clients</span></span><br><span class="line">    <span class="keyword">bool</span> primary;               <span class="comment">//  true if we're primary</span></span><br><span class="line">    <span class="keyword">bool</span> active;                <span class="comment">//  true if we're active</span></span><br><span class="line">    <span class="keyword">bool</span> passive;               <span class="comment">//  true if we're passive</span></span><br><span class="line">&#125; clonesrv_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The main task parses the command line to decide whether to start</span></span><br><span class="line"><span class="comment">//  as a primary or backup server. We're using the Binary Star pattern</span></span><br><span class="line"><span class="comment">//  for reliability. This interconnects the two servers so they can</span></span><br><span class="line"><span class="comment">//  agree on which one is primary and which one is backup. To allow the</span></span><br><span class="line"><span class="comment">//  two servers to run on the same box, we use different ports for</span></span><br><span class="line"><span class="comment">//  primary and backup. Ports 5003/5004 are used to interconnect the</span></span><br><span class="line"><span class="comment">//  servers. Ports 5556/5566 are used to receive voting events (snapshot</span></span><br><span class="line"><span class="comment">//  requests in the clone pattern). Ports 5557/5567 are used by the</span></span><br><span class="line"><span class="comment">//  publisher, and ports 5558/5568 are used by the collector:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; streq (argv [<span class="number">1</span>], <span class="string">"-p"</span>)) &#123;</span><br><span class="line">        zclock_log (<span class="string">"I: primary active, waiting for backup (passive)"</span>);</span><br><span class="line">        <span class="keyword">self</span>-&gt;bstar = bstar_new (BSTAR_PRIMARY, <span class="string">"tcp://*:5003"</span>,</span><br><span class="line">                                 <span class="string">"tcp://localhost:5004"</span>);</span><br><span class="line">        bstar_voter (<span class="keyword">self</span>-&gt;bstar, <span class="string">"tcp://*:5556"</span>,</span><br><span class="line">                     ZMQ_ROUTER, s_snapshots, <span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>-&gt;port = <span class="number">5556</span>;</span><br><span class="line">        <span class="keyword">self</span>-&gt;peer = <span class="number">5566</span>;</span><br><span class="line">        <span class="keyword">self</span>-&gt;primary = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; streq (argv [<span class="number">1</span>], <span class="string">"-b"</span>)) &#123;</span><br><span class="line">        zclock_log (<span class="string">"I: backup passive, waiting for primary (active)"</span>);</span><br><span class="line">        <span class="keyword">self</span>-&gt;bstar = bstar_new (BSTAR_BACKUP, <span class="string">"tcp://*:5004"</span>,</span><br><span class="line">                                 <span class="string">"tcp://localhost:5003"</span>);</span><br><span class="line">        bstar_voter (<span class="keyword">self</span>-&gt;bstar, <span class="string">"tcp://*:5566"</span>,</span><br><span class="line">                     ZMQ_ROUTER, s_snapshots, <span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>-&gt;port = <span class="number">5566</span>;</span><br><span class="line">        <span class="keyword">self</span>-&gt;peer = <span class="number">5556</span>;</span><br><span class="line">        <span class="keyword">self</span>-&gt;primary = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        printf (<span class="string">"Usage: clonesrv4 &#123; -p | -b &#125;\n"</span>);</span><br><span class="line">        free (<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">exit</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  Primary server will become first active</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;primary)</span><br><span class="line">        <span class="keyword">self</span>-&gt;kvmap = zhash_new ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>-&gt;ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">self</span>-&gt;pending = zlist_new ();</span><br><span class="line">    bstar_set_verbose (<span class="keyword">self</span>-&gt;bstar, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Set up our clone server sockets</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;publisher = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_PUB);</span><br><span class="line">    <span class="keyword">self</span>-&gt;collector = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (<span class="keyword">self</span>-&gt;collector, <span class="string">""</span>);</span><br><span class="line">    zsocket_bind (<span class="keyword">self</span>-&gt;publisher, <span class="string">"tcp://*:%d"</span>, <span class="keyword">self</span>-&gt;port + <span class="number">1</span>);</span><br><span class="line">    zsocket_bind (<span class="keyword">self</span>-&gt;collector, <span class="string">"tcp://*:%d"</span>, <span class="keyword">self</span>-&gt;port + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Set up our own clone client interface to peer</span></span><br><span class="line">    <span class="keyword">self</span>-&gt;subscriber = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (<span class="keyword">self</span>-&gt;subscriber, <span class="string">""</span>);</span><br><span class="line">    zsocket_connect (<span class="keyword">self</span>-&gt;subscriber,</span><br><span class="line">                     <span class="string">"tcp://localhost:%d"</span>, <span class="keyword">self</span>-&gt;peer + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  After we've setup our sockets, we register our binary star</span></span><br><span class="line">    <span class="comment">//  event handlers, and then start the bstar reactor. This finishes</span></span><br><span class="line">    <span class="comment">//  when the user presses Ctrl-C or when the process receives a SIGINT</span></span><br><span class="line">    <span class="comment">//  interrupt:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Register state change handlers</span></span><br><span class="line">    bstar_new_active (<span class="keyword">self</span>-&gt;bstar, s_new_active, <span class="keyword">self</span>);</span><br><span class="line">    bstar_new_passive (<span class="keyword">self</span>-&gt;bstar, s_new_passive, <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Register our other handlers with the bstar reactor</span></span><br><span class="line">    zmq_pollitem_t poller = &#123; <span class="keyword">self</span>-&gt;collector, <span class="number">0</span>, ZMQ_POLLIN &#125;;</span><br><span class="line">    zloop_poller (bstar_zloop (<span class="keyword">self</span>-&gt;bstar), &amp;poller, s_collector, <span class="keyword">self</span>);</span><br><span class="line">    zloop_timer  (bstar_zloop (<span class="keyword">self</span>-&gt;bstar), <span class="number">1000</span>, <span class="number">0</span>, s_flush_ttl, <span class="keyword">self</span>);</span><br><span class="line">    zloop_timer  (bstar_zloop (<span class="keyword">self</span>-&gt;bstar), <span class="number">1000</span>, <span class="number">0</span>, s_send_hugz, <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Start the bstar reactor</span></span><br><span class="line">    bstar_start (<span class="keyword">self</span>-&gt;bstar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Interrupted, so shut down</span></span><br><span class="line">    <span class="keyword">while</span> (zlist_size (<span class="keyword">self</span>-&gt;pending)) &#123;</span><br><span class="line">        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (<span class="keyword">self</span>-&gt;pending);</span><br><span class="line">        kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    zlist_destroy (&amp;<span class="keyword">self</span>-&gt;pending);</span><br><span class="line">    bstar_destroy (&amp;<span class="keyword">self</span>-&gt;bstar);</span><br><span class="line">    zhash_destroy (&amp;<span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">    zctx_destroy (&amp;<span class="keyword">self</span>-&gt;ctx);</span><br><span class="line">    free (<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  We handle ICANHAZ? requests exactly as in the clonesrv5 example.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Routing information for a key-value snapshot</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    void *socket;           <span class="comment">//  ROUTER socket to send to</span></span><br><span class="line">    zframe_t *identity;     <span class="comment">//  Identity of peer who requested state</span></span><br><span class="line">    <span class="keyword">char</span> *subtree;          <span class="comment">//  Client subtree specification</span></span><br><span class="line">&#125; kvroute_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Send one state snapshot key-value pair to a socket</span></span><br><span class="line"><span class="comment">//  Hash item data is our kvmsg object, ready to send</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_send_single (<span class="keyword">const</span> <span class="keyword">char</span> *key, void *data, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    kvroute_t *kvroute = (kvroute_t *) args;</span><br><span class="line">    kvmsg_t *kvmsg = (kvmsg_t *) data;</span><br><span class="line">    <span class="keyword">if</span> (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))</span><br><span class="line">    &amp;&amp;  memcmp (kvroute-&gt;subtree,</span><br><span class="line">                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == <span class="number">0</span>) &#123;</span><br><span class="line">        zframe_send (&amp;kvroute-&gt;identity,    <span class="comment">//  Choose recipient</span></span><br><span class="line">            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);</span><br><span class="line">        kvmsg_send (kvmsg, kvroute-&gt;socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_snapshots (zloop_t *loop, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    zframe_t *identity = zframe_recv (poller-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (identity) &#123;</span><br><span class="line">        <span class="comment">//  Request is in second frame of message</span></span><br><span class="line">        <span class="keyword">char</span> *request = zstr_recv (poller-&gt;socket);</span><br><span class="line">        <span class="keyword">char</span> *subtree = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (streq (request, <span class="string">"ICANHAZ?"</span>)) &#123;</span><br><span class="line">            free (request);</span><br><span class="line">            subtree = zstr_recv (poller-&gt;socket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            printf (<span class="string">"E: bad request, aborting\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subtree) &#123;</span><br><span class="line">            <span class="comment">//  Send state socket to client</span></span><br><span class="line">            kvroute_t routing = &#123; poller-&gt;socket, identity, subtree &#125;;</span><br><span class="line">            zhash_foreach (<span class="keyword">self</span>-&gt;kvmap, s_send_single, &amp;routing);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Now send END message with sequence number</span></span><br><span class="line">            zclock_log (<span class="string">"I: sending shapshot=%d"</span>, (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">            zframe_send (&amp;identity, poller-&gt;socket, ZFRAME_MORE);</span><br><span class="line">            kvmsg_t *kvmsg = kvmsg_new (<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">            kvmsg_set_key  (kvmsg, <span class="string">"KTHXBAI"</span>);</span><br><span class="line">            kvmsg_set_body (kvmsg, (byte *) subtree, <span class="number">0</span>);</span><br><span class="line">            kvmsg_send     (kvmsg, poller-&gt;socket);</span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            free (subtree);</span><br><span class="line">        &#125;</span><br><span class="line">        zframe_destroy(&amp;identity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The collector is more complex than in the clonesrv5 example because the</span></span><br><span class="line"><span class="comment">//  way it processes updates depends on whether we're active or passive.</span></span><br><span class="line"><span class="comment">//  The active applies them immediately to its kvmap, whereas the passive</span></span><br><span class="line"><span class="comment">//  queues them as pending:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  If message was already on pending list, remove it and return true,</span></span><br><span class="line"><span class="comment">//  else return false.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_was_pending (clonesrv_t *<span class="keyword">self</span>, kvmsg_t *kvmsg)</span><br><span class="line">&#123;</span><br><span class="line">    kvmsg_t *held = (kvmsg_t *) zlist_first (<span class="keyword">self</span>-&gt;pending);</span><br><span class="line">    <span class="keyword">while</span> (held) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memcmp (kvmsg_uuid (kvmsg),</span><br><span class="line">                    kvmsg_uuid (held), sizeof (uuid_t)) == <span class="number">0</span>) &#123;</span><br><span class="line">            zlist_remove (<span class="keyword">self</span>-&gt;pending, held);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        held = (kvmsg_t *) zlist_next (<span class="keyword">self</span>-&gt;pending);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_collector (zloop_t *loop, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    kvmsg_t *kvmsg = kvmsg_recv (poller-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (kvmsg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;active) &#123;</span><br><span class="line">            kvmsg_set_sequence (kvmsg, ++<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">            kvmsg_send (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">            <span class="keyword">int</span> ttl = atoi (kvmsg_get_prop (kvmsg, <span class="string">"ttl"</span>));</span><br><span class="line">            <span class="keyword">if</span> (ttl)</span><br><span class="line">                kvmsg_set_prop (kvmsg, <span class="string">"ttl"</span>,</span><br><span class="line">                    <span class="string">"%"</span> PRId64, zclock_time () + ttl * <span class="number">1000</span>);</span><br><span class="line">            kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">            zclock_log (<span class="string">"I: publishing update=%d"</span>, (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  If we already got message from active, drop it, else</span></span><br><span class="line">            <span class="comment">//  hold on pending list</span></span><br><span class="line">            <span class="keyword">if</span> (s_was_pending (<span class="keyword">self</span>, kvmsg))</span><br><span class="line">                kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                zlist_append (<span class="keyword">self</span>-&gt;pending, kvmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  We purge ephemeral values using exactly the same code as in</span></span><br><span class="line"><span class="comment">//  the previous clonesrv5 example.</span></span><br><span class="line"><span class="comment">//  If key-value pair has expired, delete it and publish the</span></span><br><span class="line"><span class="comment">//  fact to listening clients.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_flush_single (<span class="keyword">const</span> <span class="keyword">char</span> *key, void *data, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    kvmsg_t *kvmsg = (kvmsg_t *) data;</span><br><span class="line">    int64_t ttl;</span><br><span class="line">    sscanf (kvmsg_get_prop (kvmsg, <span class="string">"ttl"</span>), <span class="string">"%"</span> PRId64, &amp;ttl);</span><br><span class="line">    <span class="keyword">if</span> (ttl &amp;&amp; zclock_time () &gt;= ttl) &#123;</span><br><span class="line">        kvmsg_set_sequence (kvmsg, ++<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        kvmsg_set_body (kvmsg, (byte *) <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">        kvmsg_send (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">        kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">        zclock_log (<span class="string">"I: publishing delete=%d"</span>, (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_flush_ttl (zloop_t *loop, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;kvmap)</span><br><span class="line">        zhash_foreach (<span class="keyword">self</span>-&gt;kvmap, s_flush_single, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  We send a HUGZ message once a second to all subscribers so that they</span></span><br><span class="line"><span class="comment">//  can detect if our server dies. They'll then switch over to the backup</span></span><br><span class="line"><span class="comment">//  server, which will become active:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_send_hugz (zloop_t *loop, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    kvmsg_t *kvmsg = kvmsg_new (<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">    kvmsg_set_key  (kvmsg, <span class="string">"HUGZ"</span>);</span><br><span class="line">    kvmsg_set_body (kvmsg, (byte *) <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    kvmsg_send     (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">    kvmsg_destroy (&amp;kvmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  When we switch from passive to active, we apply our pending list so that</span></span><br><span class="line"><span class="comment">//  our kvmap is up-to-date. When we switch to passive, we wipe our kvmap</span></span><br><span class="line"><span class="comment">//  and grab a new snapshot from the active server:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_new_active (zloop_t *loop, zmq_pollitem_t *unused, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>-&gt;active = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">self</span>-&gt;passive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Stop subscribing to updates</span></span><br><span class="line">    zmq_pollitem_t poller = &#123; <span class="keyword">self</span>-&gt;subscriber, <span class="number">0</span>, ZMQ_POLLIN &#125;;</span><br><span class="line">    zloop_poller_end (bstar_zloop (<span class="keyword">self</span>-&gt;bstar), &amp;poller);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Apply pending list to own hash table</span></span><br><span class="line">    <span class="keyword">while</span> (zlist_size (<span class="keyword">self</span>-&gt;pending)) &#123;</span><br><span class="line">        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (<span class="keyword">self</span>-&gt;pending);</span><br><span class="line">        kvmsg_set_sequence (kvmsg, ++<span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        kvmsg_send (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">        kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">        zclock_log (<span class="string">"I: publishing pending=%d"</span>, (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_new_passive (zloop_t *loop, zmq_pollitem_t *unused, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line"></span><br><span class="line">    zhash_destroy (&amp;<span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">    <span class="keyword">self</span>-&gt;active = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">self</span>-&gt;passive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Start subscribing to updates</span></span><br><span class="line">    zmq_pollitem_t poller = &#123; <span class="keyword">self</span>-&gt;subscriber, <span class="number">0</span>, ZMQ_POLLIN &#125;;</span><br><span class="line">    zloop_poller (bstar_zloop (<span class="keyword">self</span>-&gt;bstar), &amp;poller, s_subscriber, <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  When we get an update, we create a new kvmap if necessary, and then</span></span><br><span class="line"><span class="comment">//  add our update to our kvmap. We're always passive in this case:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">s_subscriber (zloop_t *loop, zmq_pollitem_t *poller, void *args)</span><br><span class="line">&#123;</span><br><span class="line">    clonesrv_t *<span class="keyword">self</span> = (clonesrv_t *) args;</span><br><span class="line">    <span class="comment">//  Get state snapshot if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;kvmap == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>-&gt;kvmap = zhash_new ();</span><br><span class="line">        void *snapshot = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_DEALER);</span><br><span class="line">        zsocket_connect (snapshot, <span class="string">"tcp://localhost:%d"</span>, <span class="keyword">self</span>-&gt;peer);</span><br><span class="line">        zclock_log (<span class="string">"I: asking for snapshot from: tcp://localhost:%d"</span>,</span><br><span class="line">                    <span class="keyword">self</span>-&gt;peer);</span><br><span class="line">        zstr_sendm (snapshot, <span class="string">"ICANHAZ?"</span>);</span><br><span class="line">        zstr_send (snapshot, <span class="string">""</span>); <span class="comment">// blank subtree to get all</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            kvmsg_t *kvmsg = kvmsg_recv (snapshot);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">            <span class="keyword">if</span> (streq (kvmsg_key (kvmsg), <span class="string">"KTHXBAI"</span>)) &#123;</span><br><span class="line">                <span class="keyword">self</span>-&gt;sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">                kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Done</span></span><br><span class="line">            &#125;</span><br><span class="line">            kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">        &#125;</span><br><span class="line">        zclock_log (<span class="string">"I: received snapshot=%d"</span>, (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        zsocket_destroy (<span class="keyword">self</span>-&gt;ctx, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  Find and remove update off pending list</span></span><br><span class="line">    kvmsg_t *kvmsg = kvmsg_recv (poller-&gt;socket);</span><br><span class="line">    <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strneq (kvmsg_key (kvmsg), <span class="string">"HUGZ"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s_was_pending (<span class="keyword">self</span>, kvmsg)) &#123;</span><br><span class="line">            <span class="comment">//  If active update came before client update, flip it</span></span><br><span class="line">            <span class="comment">//  around, store active update (with sequence) on pending</span></span><br><span class="line">            <span class="comment">//  list and use to clear client update when it comes later</span></span><br><span class="line">            zlist_append (<span class="keyword">self</span>-&gt;pending, kvmsg_dup (kvmsg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  If update is more recent than our kvmap, apply it</span></span><br><span class="line">        <span class="keyword">if</span> (kvmsg_sequence (kvmsg) &gt; <span class="keyword">self</span>-&gt;sequence) &#123;</span><br><span class="line">            <span class="keyword">self</span>-&gt;sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">            kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">            zclock_log (<span class="string">"I: received update=%d"</span>, (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        kvmsg_destroy (&amp;kvmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　该模型只有几百行代码，但让它运行起来花费了很长时间。更准确来说，构建模型６花费了整整一个星期，”哦my上帝，这对一个例子来说真是太复杂了”。我们在这个小程序中使用了相当多的东西，有故障转移、临时值、子树等等。让我吃惊的是之前的设计相当准确。当然那么多socket流的构建和调试也是相当有挑战的。</p>
<p>　　基于反应器的设计去除了很多代码中的啰里啰嗦，剩下的就相当简单且容易理解了。我们使用了第四章的bstar反应器。整个server是一个线程，因此没有奇怪的线程间通信——只是一个结构体指针(self)在所有的句柄之间传递，该结构体指针就能愉快的完成所有的事。使用反应器模型的一个附带好处是代码被紧密组织到一个轮询循环，这就很容易重用了。模型６的很多部分是来自模型５的。</p>
<p>　　我是一部分一部分写的，写完一部分工作”正确”之后才去写下一部分。因为有四个或五个主要的socket流，这意味着大量的调试和测试。我是通过把message打印到控制台来调试的。不要在zmq程序中使用传统的调试器：你需要监控message流来知道到底发生了什么。</p>
<p>　　为了测试，我总是试着用Valgrind，它会检测内存泄露和无效的内存使用。在C中，这是一个很重要的方面，因为你没办法把内存管理委派给一个垃圾收集器。使用像kvmsg和CZMQ会很有用。</p>
<p><strong>集群hashy映射协议  The Clustered Hashmap Protocol</strong></p>
<p>　　尽管server只是一个先前模型和双子星模型的混搭，但client相当复杂。在我们详细介绍之前，先来看看最终的协议。我把它作为一个说明写在了zmo RFC网站，也就是<a href="http://rfc.zeromq.org/spec:12" target="_blank" rel="noopener">Clustered Hashmap Protocol</a>。</p>
<p>　　大致说来，有两种方法来设计一个像这个这么复杂的协议。一种是把每种数据流都分配到各自的一组socket上，这是我们常用的方法。优点是每个数据流都很简单且清晰。缺点是同时管理多个socket数据流会很复杂。使用反应器会简单点儿，但反应器模型会产生很多必须相互适配的可变部分。</p>
<p>　　第二种办法是用一个单独是socket来处理所有的事情。在本例中，我在server中使用了ROUTER，在client中使用了DEALER，然后在这个连接之上处理所有的事情。这样会产生一个更复杂的协议，但至少复杂性都集中在一个地方。在第七章我们会看到一个基于ROUTER-DEALER组合的协议例子。</p>
<p>　　现在我们来看看CHP协议。注意”SHOULD”，”MUST”和”MAY”是我们在协议中用来明确需求等级的关键字。】</p>
<p><strong>目标　Goals</strong></p>
<p>　　CHP用于为一组基于zmq网络的client之间可靠的pub-sub模型提供基础。它定义了一个包含key-value对的”hashmap”抽象概念。任一client都能在任何时候修改任一key-value对，并且更新会被递送到所有的client。一个client能在任一时刻加入网络。</p>
<p><strong>架构 Architecture</strong></p>
<p>　　CHP连接一组client应用和一组server。client连接到server。client不能连接彼此。client能随意加入和退出。</p>
<p><strong>端口和连接　　Ports and Connections</strong></p>
<p>　　server必须(MUST)启动如下三个端口地址：</p>
<ul>
<li>一个端口在P上的SNAPSHOT端口(zmq ROUTER socket)。</li>
<li>一个端口在P+1上的PUBLISHER 端口(zmq PUB socket)。</li>
<li>一个端口在P+2上的COLLECTOR端口(zmq SUB socekt)。</li>
</ul>
<p>　　client应该(SHOULD)至少启动如下两个连接：</p>
<ul>
<li>一个端口在P上的SNAPSHOT连接(zmq DEALER socket)。</li>
<li>一个端口在P+1上的SUBSCRIBER连接(zmq SUB socket)。</li>
</ul>
<p>　　如果client想更新haspmap的话，它可以(MAY)启动第三个连接：</p>
<ul>
<li>一个端口在P+2上的PUBLISHER连接(zmq PUB socket)。</li>
</ul>
<p>　　剩下的框架没在下面的命令中说明。</p>
<p><strong>状态同步 State Synchronization</strong></p>
<p>　　client必须(MUST)在启动的时候发送一个ICANHAZ命令到它的快照连接。该命令包括以下两个帧：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ICANHAZ command</span><br><span class="line">-----------------------------------</span><br><span class="line">Frame 0: "ICANHAZ?"</span><br><span class="line">Frame 1: subtree specification</span><br></pre></td></tr></table></figure></p>
<p>　　每个帧都是zmq字符串。子树说明可以(MAY)为空。如果不为空，它会包含一个通过反斜杠分开的一个个路径段，以反斜杠最后结束。</p>
<p>　　server必须(MUST)返回给ICANHAZ命令零个或多个KVSYNC命令到它的快照端口，然后跟一个KTHXBAI命令。server必须(MUST)在每个命令之前前缀上client的标识，该标识由ICANHAZ命令提供。KVSYNC命令定义了一个kay-value对：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KVSYNC <span class="keyword">command</span></span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line">Frame <span class="number">0</span>: key, <span class="keyword">as</span> ZeroMQ <span class="keyword">string</span></span><br><span class="line">Frame <span class="number">1</span>: sequence <span class="built_in">number</span>, <span class="number">8</span> <span class="keyword">bytes</span> <span class="keyword">in</span> network order</span><br><span class="line">Frame <span class="number">2</span>: &lt;<span class="literal">empty</span>&gt;</span><br><span class="line">Frame <span class="number">3</span>: &lt;<span class="literal">empty</span>&gt;</span><br><span class="line">Frame <span class="number">4</span>: <span class="built_in">value</span>, <span class="keyword">as</span> blob</span><br></pre></td></tr></table></figure></p>
<p>　　序列编号没有符号，可以是０．</p>
<p>　　KTHXBAI命令采用如下格式：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KTHXBAI command</span><br><span class="line">-----------------------------------</span><br><span class="line">Frame 0: <span class="string">"KTHXBAI"</span></span><br><span class="line">Frame 1: sequence number, 8 bytes <span class="keyword">in</span><span class="built_in"> network </span>order</span><br><span class="line">Frame 2: &lt;empty&gt;</span><br><span class="line">Frame 3: &lt;empty&gt;</span><br><span class="line">Frame 4: subtree specification</span><br></pre></td></tr></table></figure></p>
<p>　　序列编号必须(MUST)是KVSYNC命令先前送过来的最大数字。</p>
<p>　　当client收到了一个KTHXBAI命令，它应该(SHOULD)开始去接收从它的订阅连接发来的数据然后处理它们。</p>
<p><strong>Server-to-Client Updates</strong></p>
<p>　　当server有一个hashmap的更新，它必须(MUST)把它作为一个KVPUB命令通过发布socket广播出去。KVPUB命令有如下格式：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KVPUB <span class="keyword">command</span></span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line">Frame <span class="number">0</span>: key, <span class="keyword">as</span> ZeroMQ <span class="keyword">string</span></span><br><span class="line">Frame <span class="number">1</span>: sequence <span class="built_in">number</span>, <span class="number">8</span> <span class="keyword">bytes</span> <span class="keyword">in</span> network order</span><br><span class="line">Frame <span class="number">2</span>: UUID, <span class="number">16</span> <span class="keyword">bytes</span></span><br><span class="line">Frame <span class="number">3</span>: properties, <span class="keyword">as</span> ZeroMQ <span class="keyword">string</span></span><br><span class="line">Frame <span class="number">4</span>: <span class="built_in">value</span>, <span class="keyword">as</span> blob</span><br></pre></td></tr></table></figure></p>
<p>　　序列编号必须(MUST)严格递增。client必须(MUST)丢掉那些序列编号没有严格大于上一条接收到的KTHXBAI或KVPUB命令的序列编号的任何KVPUB命令。</p>
<p>　　UUID是可选项并且frame 2可以(MAY)为空(长度为０)。属性字段组织成零个或多个”name=value”后跟一个换行符的字段的格式。如果该key-value对没有属性，那属性字段就为空。</p>
<p>　　如果value为空，client应该(SHOULD)应该删除指定key的key-value项。</p>
<p>　　在缺少更新的时候server应该(SHOULD)定期发送一个HUGZ命令，比如说每秒一次。HUGZ命令格式如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HUGZ command</span><br><span class="line">-----------------------------------</span><br><span class="line">Frame 0: "HUGZ"</span><br><span class="line">Frame 1: 00000000</span><br><span class="line">Frame 2: &lt;empty&gt;</span><br><span class="line">Frame 3: &lt;empty&gt;</span><br><span class="line">Frame 4: &lt;empty&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　client可以(MAY)把HUGZ的缺失作为server已经挂掉的指示器(见下面可靠性)。</p>
<p><strong>Client-to-Server Updates</strong></p>
<p>　　当client有一个针对它自己的hashmap的更新，它可以(MAY)把它作为一个KVSET命令通过发布连接发送给server。KVSET命令格式如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KVSET <span class="keyword">command</span></span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line">Frame <span class="number">0</span>: key, <span class="keyword">as</span> ZeroMQ <span class="keyword">string</span></span><br><span class="line">Frame <span class="number">1</span>: sequence <span class="built_in">number</span>, <span class="number">8</span> <span class="keyword">bytes</span> <span class="keyword">in</span> network order</span><br><span class="line">Frame <span class="number">2</span>: UUID, <span class="number">16</span> <span class="keyword">bytes</span></span><br><span class="line">Frame <span class="number">3</span>: properties, <span class="keyword">as</span> ZeroMQ <span class="keyword">string</span></span><br><span class="line">Frame <span class="number">4</span>: <span class="built_in">value</span>, <span class="keyword">as</span> blob</span><br></pre></td></tr></table></figure></p>
<p>　　序列编号没有符号且可以为０。如果使用一个可靠的server架构的话，UUID应该(SHOULD)是个全局唯一标识。</p>
<p>　　如果value为空，server必须(MUST)删除该指定key的key-value项。</p>
<p>　　server应该(SHOULD)接收如下属性：</p>
<ul>
<li><strong>ttl:</strong>用秒定义一个存活时间(time-to-live)。如果KVSET命令有个ttl属性，server应该(SHOULD)在TTL过期的时候删除该key-value对并且广播一个value为空的KVPUB命令来删除每个client中的该向。</li>
</ul>
<p><strong>可靠性 Reliability</strong></p>
<p>　　CHP可以配置成双server，如果主server失效那备份server就会接替工作。CHP没有定义故障转移的机制，不过可以参照双子星模型的定义。</p>
<p>　　要辅助server的可靠性设计，client可以(MAY)：</p>
<ul>
<li>在每个KVSET命令中设置一个UUID。</li>
<li>检测一段时间的HUGZ缺失，把这作为当前服务器失效的一个指示器。</li>
<li>连接备份server并且重新请求状态同步。</li>
</ul>
<p><strong>扩展性和性能 Scalability and Performance</strong></p>
<p>  CHP被设计成能适应大规模(成千)client的架构，限制只存在于broker的系统资源。由于所有的更新都会通过一台单独的server，总体吞吐量会被限制在峰值为每秒几百万个更新，或者更少些。</p>
<p><strong>安全　Security</strong></p>
<p>　　CHP没有实现任何认证、接入控制或者密码机制，不应该在需要这些的场景中使用。</p>
<p><strong>构建一个多线程栈和API Building a Multithreaded Stach and API</strong></p>
<p>　　目前我们使用的client栈还不能正确处理该协议。在开始构建心跳的时候，我们需要一个能运行在后台线程的client栈。在第四章结尾的自由者模型中我们使用过一个多线程API但没有详细说明它。当你开始构建像CHP那样更复杂的zmq协议的时候多线程API就相当有用了。</p>
<p><img src="/img/zmq63.png" alt="f63"></p>
<p>　　如果你设计设计了一个很重要的协议并且期望应用正确实现它，那大多数开发者会在大部分时间弄错的。你会听到很多人抱怨协议太复杂、太脆弱、太难使用。即使你给它们一个很简单的API，也会很难让它们去买该系统。</p>
<p>　　我们的多线程API包括一个前端对象和一个后台代理，通过两个PAIR socket连接。像这样连接两个PAIR socket会很有用，你的高级绑定很可能跟CZMQ一样，就是封装一个”创建一个带有我可以用来向它发送信息的管道的新线程”的方法。</p>
<p>　　我们在本书中看到的多线程API全都采用相同的格式：</p>
<ul>
<li>对象的构造函数(<code>clone_new</code>)创建一个context并且启动一个带有管道的后台线程。它保存有该管道的一端以便能向后台线程发送命令。</li>
<li>后台线程启动一个<em>agent</em>，该agent实际上是一个从管道socket和任何其他socket(这里是DEALER和SUB socekt)读取信息的<code>zmq_poll</code>循环。</li>
<li><p>现在主应用线程和后台线程只通过zmq　message通信。通过连接，前端发送的字符串命令会通过该类中的每个方法转换成一条message发送到后台agent，就像这样：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">clone_connect (<span class="name">clone_t</span> *self, char *address, char *service)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    zmsg_t *msg = zmsg_new ()<span class="comment">;</span></span><br><span class="line">    zmsg_addstr (<span class="name">msg</span>, <span class="string">"CONNECT"</span>)<span class="comment">;</span></span><br><span class="line">    zmsg_addstr (<span class="name">msg</span>, address)<span class="comment">;</span></span><br><span class="line">    zmsg_addstr (<span class="name">msg</span>, service)<span class="comment">;</span></span><br><span class="line">    zmsg_send (<span class="name">&amp;msg</span>, self-&gt;pipe)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果该函数需要返回码，它可以等着一个从agent的回复message。</p>
</li>
<li>如果该agent需要向后台返回异步事件，我们就在该类中增加一个<code>recv</code>函数，它会在前端管道上等着message。</li>
<li>我们可能希望把前端管道socket暴露出来好让该类能进一步整合到轮询循环。否则每个<code>recv</code>方法都会阻塞该应用。</li>
</ul>
<p>　　该克隆类有着跟第四章<code>flicliapi</code>类相同的结构，并且增加了最后一个克隆模型client的逻辑。没有zmq，这种多线程API的设计就需要几周时间的艰苦工作。使用了zmq的话，就差不多是一两天的工作了。</p>
<p>　　该克隆类的真实API相当简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Create a new clone class instance</span></span><br><span class="line"><span class="keyword">clone_t</span> *</span><br><span class="line">    clone_new (<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Destroy a clone class instance</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">    clone_destroy (<span class="keyword">clone_t</span> **self_p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Define the subtree, if any, for this clone class</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">    clone_subtree (<span class="keyword">clone_t</span> *self, <span class="keyword">char</span> *subtree);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Connect the clone class to one server</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">    clone_connect (<span class="keyword">clone_t</span> *self, <span class="keyword">char</span> *address, <span class="keyword">char</span> *service);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set a value in the shared hashmap</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">    clone_set (<span class="keyword">clone_t</span> *self, <span class="keyword">char</span> *key, <span class="keyword">char</span> *value, <span class="keyword">int</span> ttl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Get a value from the shared hashmap</span></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">    clone_get (<span class="keyword">clone_t</span> *self, <span class="keyword">char</span> *key);</span><br></pre></td></tr></table></figure></p>
<p>　　下面是克隆client的模型６，它现在变成了使用该克隆类的一个瘦壳：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clonecli6: Clone client, Model Six in C</span></span><br><span class="line"><span class="comment">//  Clone client Model Six</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Lets us build this source without creating a library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clone.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUBTREE <span class="meta-string">"/client/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Create distributed hash instance</span></span><br><span class="line">    <span class="keyword">clone_t</span> *clone = clone_new ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Specify configuration</span></span><br><span class="line">    clone_subtree (clone, SUBTREE);</span><br><span class="line">    clone_connect (clone, <span class="string">"tcp://localhost"</span>, <span class="string">"5556"</span>);</span><br><span class="line">    clone_connect (clone, <span class="string">"tcp://localhost"</span>, <span class="string">"5566"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Set random tuples into the distributed hash</span></span><br><span class="line">    <span class="keyword">while</span> (!zctx_interrupted) &#123;</span><br><span class="line">        <span class="comment">//  Set random value, check it was stored</span></span><br><span class="line">        <span class="keyword">char</span> key [<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">char</span> value [<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">sprintf</span> (key, <span class="string">"%s%d"</span>, SUBTREE, randof (<span class="number">10000</span>));</span><br><span class="line">        <span class="built_in">sprintf</span> (value, <span class="string">"%d"</span>, randof (<span class="number">1000000</span>));</span><br><span class="line">        clone_set (clone, key, value, randof (<span class="number">30</span>));</span><br><span class="line">        sleep (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clone_destroy (&amp;clone);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　注意连接函数，它指定了一个server端点地址。在该函数下，我们实际上在跟三个端口通信。然而，就像CHP协议说的那样，这三个端口是三个连续的端口数字：</p>
<ul>
<li>server状态路由(ROUTER)在port P。</li>
<li>server更新发布者(PUB)在port P+1。</li>
<li>server更新订阅者(SUB)在port P+2。</li>
</ul>
<p>　　因此我们可以把这三个连接整合到一个逻辑操作中(我们实现为三个独立的zmq连接调用)。</p>
<p>　　我们以该克隆栈的源代码结束。这是段复杂的代码，但只要你把它分解为前端对象类和后台agent类就很容易理解了。前端向agent发送字符串命令(“SUBTREE”, “CONNECT”, “SET”, “GET”)，agent会处理这些命令并更server(s)通信。下面是agent的逻辑：</p>
<ol>
<li>启动并从第一台server拿到快照。</li>
<li>当拿到一个快照后就切换到从订阅者socket读取信息。</li>
<li>如果没拿到快照就故障转移到第二台server。</li>
<li>在管道和订阅者socket上轮询。</li>
<li>如果得到管道上的输入，处理这个从前端对象来的控制命令。</li>
<li>如果得到订阅者上的输入，存储或应用该更新。</li>
<li>如果在一定时间内没有从server得到任何东西，就进行故障转移。</li>
<li>重复直到进程被Ctrl-C中断。</li>
</ol>
<p>　　下面是真正的克隆类实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  clone: Clone class in C</span></span><br><span class="line"><span class="comment">//  clone class - Clone client API stack (multithreaded)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include "clone.h"</span></span><br><span class="line"><span class="comment">//  If no server replies within this time, abandon request</span></span><br><span class="line"><span class="comment">#define GLOBAL_TIMEOUT  4000    //  msecs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  =====================================================================</span></span><br><span class="line"><span class="comment">//  Synchronous part, works in our application thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Structure of our class</span></span><br><span class="line"></span><br><span class="line">struct _clone_t &#123;</span><br><span class="line">    zctx_t *ctx;                <span class="comment">//  Our context wrapper</span></span><br><span class="line">    void *pipe;                 <span class="comment">//  Pipe through to clone agent</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  This is the thread that handles our real clone class</span></span><br><span class="line"><span class="keyword">static</span> void clone_agent (void *args, zctx_t *ctx, void *pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Here are the constructor and destructor for the clone class. Note that</span></span><br><span class="line"><span class="comment">//  we create a context specifically for the pipe that connects our</span></span><br><span class="line"><span class="comment">//  frontend to the backend agent:</span></span><br><span class="line"></span><br><span class="line">clone_t *</span><br><span class="line">clone_new (void)</span><br><span class="line">&#123;</span><br><span class="line">    clone_t</span><br><span class="line">        *<span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = (clone_t *) zmalloc (sizeof (clone_t));</span><br><span class="line">    <span class="keyword">self</span>-&gt;ctx = zctx_new ();</span><br><span class="line">    <span class="keyword">self</span>-&gt;pipe = zthread_fork (<span class="keyword">self</span>-&gt;ctx, clone_agent, <span class="keyword">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">clone_destroy (clone_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        clone_t *<span class="keyword">self</span> = *self_p;</span><br><span class="line">        zctx_destroy (&amp;<span class="keyword">self</span>-&gt;ctx);</span><br><span class="line">        free (<span class="keyword">self</span>);</span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Specify subtree for snapshot and updates, which we must do before</span></span><br><span class="line"><span class="comment">//  connecting to a server as the subtree specification is sent as the</span></span><br><span class="line"><span class="comment">//  first command to the server. Sends a [SUBTREE][subtree] command to</span></span><br><span class="line"><span class="comment">//  the agent:</span></span><br><span class="line"></span><br><span class="line">void clone_subtree (clone_t *<span class="keyword">self</span>, <span class="keyword">char</span> *subtree)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmsg_t *msg = zmsg_new ();</span><br><span class="line">    zmsg_addstr (msg, <span class="string">"SUBTREE"</span>);</span><br><span class="line">    zmsg_addstr (msg, subtree);</span><br><span class="line">    zmsg_send (&amp;msg, <span class="keyword">self</span>-&gt;pipe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Connect to a new server endpoint. We can connect to at most two</span></span><br><span class="line"><span class="comment">//  servers. Sends [CONNECT][endpoint][service] to the agent:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">clone_connect (clone_t *<span class="keyword">self</span>, <span class="keyword">char</span> *address, <span class="keyword">char</span> *service)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmsg_t *msg = zmsg_new ();</span><br><span class="line">    zmsg_addstr (msg, <span class="string">"CONNECT"</span>);</span><br><span class="line">    zmsg_addstr (msg, address);</span><br><span class="line">    zmsg_addstr (msg, service);</span><br><span class="line">    zmsg_send (&amp;msg, <span class="keyword">self</span>-&gt;pipe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Set a new value in the shared hashmap. Sends a [SET][key][value][ttl]</span></span><br><span class="line"><span class="comment">//  command through to the agent which does the actual work:</span></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">clone_set (clone_t *<span class="keyword">self</span>, <span class="keyword">char</span> *key, <span class="keyword">char</span> *value, <span class="keyword">int</span> ttl)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ttlstr [<span class="number">10</span>];</span><br><span class="line">    sprintf (ttlstr, <span class="string">"%d"</span>, ttl);</span><br><span class="line"></span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    zmsg_t *msg = zmsg_new ();</span><br><span class="line">    zmsg_addstr (msg, <span class="string">"SET"</span>);</span><br><span class="line">    zmsg_addstr (msg, key);</span><br><span class="line">    zmsg_addstr (msg, value);</span><br><span class="line">    zmsg_addstr (msg, ttlstr);</span><br><span class="line">    zmsg_send (&amp;msg, <span class="keyword">self</span>-&gt;pipe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Look up value in distributed hash table. Sends [GET][key] to the agent and</span></span><br><span class="line"><span class="comment">//  waits for a value response. If there is no value available, will eventually</span></span><br><span class="line"><span class="comment">//  return NULL:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">clone_get (clone_t *<span class="keyword">self</span>, <span class="keyword">char</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    assert (<span class="keyword">self</span>);</span><br><span class="line">    assert (key);</span><br><span class="line">    zmsg_t *msg = zmsg_new ();</span><br><span class="line">    zmsg_addstr (msg, <span class="string">"GET"</span>);</span><br><span class="line">    zmsg_addstr (msg, key);</span><br><span class="line">    zmsg_send (&amp;msg, <span class="keyword">self</span>-&gt;pipe);</span><br><span class="line"></span><br><span class="line">    zmsg_t *reply = zmsg_recv (<span class="keyword">self</span>-&gt;pipe);</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="keyword">char</span> *value = zmsg_popstr (reply);</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The backend agent manages a set of servers, which we implement using</span></span><br><span class="line"><span class="comment">//  our simple class model:</span></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    <span class="keyword">char</span> *address;              <span class="comment">//  Server address</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">//  Server port</span></span><br><span class="line">    void *snapshot;             <span class="comment">//  Snapshot socket</span></span><br><span class="line">    void *subscriber;           <span class="comment">//  Incoming updates</span></span><br><span class="line">    uint64_t expiry;            <span class="comment">//  When server expires</span></span><br><span class="line">    <span class="keyword">uint</span> requests;              <span class="comment">//  How many snapshot requests made?</span></span><br><span class="line">&#125; server_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> server_t *</span><br><span class="line">server_new (zctx_t *ctx, <span class="keyword">char</span> *address, <span class="keyword">int</span> port, <span class="keyword">char</span> *subtree)</span><br><span class="line">&#123;</span><br><span class="line">    server_t *<span class="keyword">self</span> = (server_t *) zmalloc (sizeof (server_t));</span><br><span class="line"></span><br><span class="line">    zclock_log (<span class="string">"I: adding server %s:%d…"</span>, address, port);</span><br><span class="line">    <span class="keyword">self</span>-&gt;address = strdup (address);</span><br><span class="line">    <span class="keyword">self</span>-&gt;port = port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>-&gt;snapshot = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (<span class="keyword">self</span>-&gt;snapshot, <span class="string">"%s:%d"</span>, address, port);</span><br><span class="line">    <span class="keyword">self</span>-&gt;subscriber = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_connect (<span class="keyword">self</span>-&gt;subscriber, <span class="string">"%s:%d"</span>, address, port + <span class="number">1</span>);</span><br><span class="line">    zsocket_set_subscribe (<span class="keyword">self</span>-&gt;subscriber, subtree);</span><br><span class="line">    zsocket_set_subscribe (<span class="keyword">self</span>-&gt;subscriber, <span class="string">"HUGZ"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void</span><br><span class="line">server_destroy (server_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        server_t *<span class="keyword">self</span> = *self_p;</span><br><span class="line">        free (<span class="keyword">self</span>-&gt;address);</span><br><span class="line">        free (<span class="keyword">self</span>);</span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Here is the implementation of the backend agent itself:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Number of servers to which we will talk to</span></span><br><span class="line"><span class="comment">#define SERVER_MAX      2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Server considered dead if silent for this long</span></span><br><span class="line"><span class="comment">#define SERVER_TTL      5000    //  msecs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  States we can be in</span></span><br><span class="line"><span class="comment">#define STATE_INITIAL       0   //  Before asking server for state</span></span><br><span class="line"><span class="comment">#define STATE_SYNCING       1   //  Getting state from server</span></span><br><span class="line"><span class="comment">#define STATE_ACTIVE        2   //  Getting new updates from server</span></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    zctx_t *ctx;                <span class="comment">//  Context wrapper</span></span><br><span class="line">    void *pipe;                 <span class="comment">//  Pipe back to application</span></span><br><span class="line">    zhash_t *kvmap;             <span class="comment">//  Actual key/value table</span></span><br><span class="line">    <span class="keyword">char</span> *subtree;              <span class="comment">//  Subtree specification, if any</span></span><br><span class="line">    server_t *server [SERVER_MAX];</span><br><span class="line">    <span class="keyword">uint</span> nbr_servers;           <span class="comment">//  0 to SERVER_MAX</span></span><br><span class="line">    <span class="keyword">uint</span> state;                 <span class="comment">//  Current state</span></span><br><span class="line">    <span class="keyword">uint</span> cur_server;            <span class="comment">//  If active, server 0 or 1</span></span><br><span class="line">    int64_t sequence;           <span class="comment">//  Last kvmsg processed</span></span><br><span class="line">    void *publisher;            <span class="comment">//  Outgoing updates</span></span><br><span class="line">&#125; agent_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> agent_t *</span><br><span class="line">agent_new (zctx_t *ctx, void *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    agent_t *<span class="keyword">self</span> = (agent_t *) zmalloc (sizeof (agent_t));</span><br><span class="line">    <span class="keyword">self</span>-&gt;ctx = ctx;</span><br><span class="line">    <span class="keyword">self</span>-&gt;pipe = pipe;</span><br><span class="line">    <span class="keyword">self</span>-&gt;kvmap = zhash_new ();</span><br><span class="line">    <span class="keyword">self</span>-&gt;subtree = strdup (<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">self</span>-&gt;state = STATE_INITIAL;</span><br><span class="line">    <span class="keyword">self</span>-&gt;publisher = zsocket_new (<span class="keyword">self</span>-&gt;ctx, ZMQ_PUB);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void</span><br><span class="line">agent_destroy (agent_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    <span class="keyword">if</span> (*self_p) &#123;</span><br><span class="line">        agent_t *<span class="keyword">self</span> = *self_p;</span><br><span class="line">        <span class="keyword">int</span> server_nbr;</span><br><span class="line">        <span class="keyword">for</span> (server_nbr = <span class="number">0</span>; server_nbr &lt; <span class="keyword">self</span>-&gt;nbr_servers; server_nbr++)</span><br><span class="line">            server_destroy (&amp;<span class="keyword">self</span>-&gt;server [server_nbr]);</span><br><span class="line">        zhash_destroy (&amp;<span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">        free (<span class="keyword">self</span>-&gt;subtree);</span><br><span class="line">        free (<span class="keyword">self</span>);</span><br><span class="line">        *self_p = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Here we handle the different control messages from the frontend;</span></span><br><span class="line"><span class="comment">//  SUBTREE, CONNECT, SET, and GET:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">agent_control_message (agent_t *<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    zmsg_t *msg = zmsg_recv (<span class="keyword">self</span>-&gt;pipe);</span><br><span class="line">    <span class="keyword">char</span> *command = zmsg_popstr (msg);</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streq (command, <span class="string">"SUBTREE"</span>)) &#123;</span><br><span class="line">        free (<span class="keyword">self</span>-&gt;subtree);</span><br><span class="line">        <span class="keyword">self</span>-&gt;subtree = zmsg_popstr (msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (streq (command, <span class="string">"CONNECT"</span>)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *address = zmsg_popstr (msg);</span><br><span class="line">        <span class="keyword">char</span> *service = zmsg_popstr (msg);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;nbr_servers &lt; SERVER_MAX) &#123;</span><br><span class="line">            <span class="keyword">self</span>-&gt;server [<span class="keyword">self</span>-&gt;nbr_servers++] = server_new (</span><br><span class="line">                <span class="keyword">self</span>-&gt;ctx, address, atoi (service), <span class="keyword">self</span>-&gt;subtree);</span><br><span class="line">            <span class="comment">//  We broadcast updates to all known servers</span></span><br><span class="line">            zsocket_connect (<span class="keyword">self</span>-&gt;publisher, <span class="string">"%s:%d"</span>,</span><br><span class="line">                address, atoi (service) + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zclock_log (<span class="string">"E: too many servers (max. %d)"</span>, SERVER_MAX);</span><br><span class="line">        free (address);</span><br><span class="line">        free (service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//  When we set a property, we push the new key-value pair onto</span></span><br><span class="line">    <span class="comment">//  all our connected servers:</span></span><br><span class="line">    <span class="keyword">if</span> (streq (command, <span class="string">"SET"</span>)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *key = zmsg_popstr (msg);</span><br><span class="line">        <span class="keyword">char</span> *value = zmsg_popstr (msg);</span><br><span class="line">        <span class="keyword">char</span> *ttl = zmsg_popstr (msg);</span><br><span class="line">        zhash_update (<span class="keyword">self</span>-&gt;kvmap, key, (byte *) value);</span><br><span class="line">        zhash_freefn (<span class="keyword">self</span>-&gt;kvmap, key, free);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Send key-value pair on to server</span></span><br><span class="line">        kvmsg_t *kvmsg = kvmsg_new (<span class="number">0</span>);</span><br><span class="line">        kvmsg_set_key  (kvmsg, key);</span><br><span class="line">        kvmsg_set_uuid (kvmsg);</span><br><span class="line">        kvmsg_fmt_body (kvmsg, <span class="string">"%s"</span>, value);</span><br><span class="line">        kvmsg_set_prop (kvmsg, <span class="string">"ttl"</span>, ttl);</span><br><span class="line">        kvmsg_send     (kvmsg, <span class="keyword">self</span>-&gt;publisher);</span><br><span class="line">        kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">        free (ttl);</span><br><span class="line">        free (key);             <span class="comment">//  Value is owned by hash table</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (streq (command, <span class="string">"GET"</span>)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *key = zmsg_popstr (msg);</span><br><span class="line">        <span class="keyword">char</span> *value = zhash_lookup (<span class="keyword">self</span>-&gt;kvmap, key);</span><br><span class="line">        <span class="keyword">if</span> (value)</span><br><span class="line">            zstr_send (<span class="keyword">self</span>-&gt;pipe, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zstr_send (<span class="keyword">self</span>-&gt;pipe, <span class="string">""</span>);</span><br><span class="line">        free (key);</span><br><span class="line">        free (value);</span><br><span class="line">    &#125;</span><br><span class="line">    free (command);</span><br><span class="line">    zmsg_destroy (&amp;msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  The asynchronous agent manages a server pool and handles the</span></span><br><span class="line"><span class="comment">//  request-reply dialog when the application asks for it:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void</span><br><span class="line">clone_agent (void *args, zctx_t *ctx, void *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    agent_t *<span class="keyword">self</span> = agent_new (ctx, pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        zmq_pollitem_t poll_set [] = &#123;</span><br><span class="line">            &#123; pipe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</span><br><span class="line">            &#123; <span class="number">0</span>,    <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> poll_timer = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> poll_size = <span class="number">2</span>;</span><br><span class="line">        server_t *server = <span class="keyword">self</span>-&gt;server [<span class="keyword">self</span>-&gt;cur_server];</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>-&gt;state) &#123;</span><br><span class="line">            <span class="keyword">case</span> STATE_INITIAL:</span><br><span class="line">                <span class="comment">//  In this state we ask the server for a snapshot,</span></span><br><span class="line">                <span class="comment">//  if we have a server to talk to…</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;nbr_servers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    zclock_log (<span class="string">"I: waiting for server at %s:%d…"</span>,</span><br><span class="line">                        server-&gt;address, server-&gt;port);</span><br><span class="line">                    <span class="keyword">if</span> (server-&gt;requests &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        zstr_sendm (server-&gt;snapshot, <span class="string">"ICANHAZ?"</span>);</span><br><span class="line">                        zstr_send  (server-&gt;snapshot, <span class="keyword">self</span>-&gt;subtree);</span><br><span class="line">                        server-&gt;requests++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    server-&gt;expiry = zclock_time () + SERVER_TTL;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;state = STATE_SYNCING;</span><br><span class="line">                    poll_set [<span class="number">1</span>].socket = server-&gt;snapshot;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    poll_size = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> STATE_SYNCING:</span><br><span class="line">                <span class="comment">//  In this state we read from snapshot and we expect</span></span><br><span class="line">                <span class="comment">//  the server to respond, else we fail over.</span></span><br><span class="line">                poll_set [<span class="number">1</span>].socket = server-&gt;snapshot;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> STATE_ACTIVE:</span><br><span class="line">                <span class="comment">//  In this state we read from subscriber and we expect</span></span><br><span class="line">                <span class="comment">//  the server to give HUGZ, else we fail over.</span></span><br><span class="line">                poll_set [<span class="number">1</span>].socket = server-&gt;subscriber;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server) &#123;</span><br><span class="line">            poll_timer = (server-&gt;expiry - zclock_time ())</span><br><span class="line">                       * ZMQ_POLL_MSEC;</span><br><span class="line">            <span class="keyword">if</span> (poll_timer &lt; <span class="number">0</span>)</span><br><span class="line">                poll_timer = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  We're ready to process incoming messages; if nothing at all</span></span><br><span class="line">        <span class="comment">//  comes from our server within the timeout, that means the</span></span><br><span class="line">        <span class="comment">//  server is dead:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rc = zmq_poll (poll_set, poll_size, poll_timer);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">//  Context has been shut down</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poll_set [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (agent_control_message (<span class="keyword">self</span>))</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (poll_set [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            kvmsg_t *kvmsg = kvmsg_recv (poll_set [<span class="number">1</span>].socket);</span><br><span class="line">            <span class="keyword">if</span> (!kvmsg)</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  Anything from server resets its expiry time</span></span><br><span class="line">            server-&gt;expiry = zclock_time () + SERVER_TTL;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;state == STATE_SYNCING) &#123;</span><br><span class="line">                <span class="comment">//  Store in snapshot until we're finished</span></span><br><span class="line">                server-&gt;requests = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (streq (kvmsg_key (kvmsg), <span class="string">"KTHXBAI"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">                    <span class="keyword">self</span>-&gt;state = STATE_ACTIVE;</span><br><span class="line">                    zclock_log (<span class="string">"I: received from %s:%d snapshot=%d"</span>,</span><br><span class="line">                        server-&gt;address, server-&gt;port,</span><br><span class="line">                        (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">                    kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;state == STATE_ACTIVE) &#123;</span><br><span class="line">                <span class="comment">//  Discard out-of-sequence updates, incl. HUGZ</span></span><br><span class="line">                <span class="keyword">if</span> (kvmsg_sequence (kvmsg) &gt; <span class="keyword">self</span>-&gt;sequence) &#123;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;sequence = kvmsg_sequence (kvmsg);</span><br><span class="line">                    kvmsg_store (&amp;kvmsg, <span class="keyword">self</span>-&gt;kvmap);</span><br><span class="line">                    zclock_log (<span class="string">"I: received from %s:%d update=%d"</span>,</span><br><span class="line">                        server-&gt;address, server-&gt;port,</span><br><span class="line">                        (<span class="keyword">int</span>) <span class="keyword">self</span>-&gt;sequence);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    kvmsg_destroy (&amp;kvmsg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  Server has died, failover to next</span></span><br><span class="line">            zclock_log (<span class="string">"I: server at %s:%d didn't give HUGZ"</span>,</span><br><span class="line">                    server-&gt;address, server-&gt;port);</span><br><span class="line">            <span class="keyword">self</span>-&gt;cur_server = (<span class="keyword">self</span>-&gt;cur_server + <span class="number">1</span>) % <span class="keyword">self</span>-&gt;nbr_servers;</span><br><span class="line">            <span class="keyword">self</span>-&gt;state = STATE_INITIAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    agent_destroy (&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
    <div>
 
 
<ul class="post-copyright">
  <li class="post-copyright-author">
      <strong>本文作者：</strong>suntus
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="/2015/03/02/zmq中文指南-5/" title="zmq中文指南_5">2015/03/02/zmq中文指南-5/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权： </strong>
    本站文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议，请勿用于商业，转载注明出处！
  </li>
</ul>

</div>
      
        <div class="post-tags">
          
            <a href="/tags/tr/" rel="tag"># tr</a>
          
            <a href="/tags/zmq/" rel="tag"># zmq</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/01/30/zmq中文指南-4/" rel="next" title="zmq中文指南_4">
                <i class="fa fa-chevron-left"></i> zmq中文指南_4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/04/06/总个结2015-04-06/" rel="prev" title="总个结2015-04-06">
                总个结2015-04-06 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">suntus</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">83</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第５章－高级发布－订阅模型"><span class="nav-text">第５章－高级发布－订阅模型</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suntus</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  


  


  





  

  

  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

</body>
</html>
