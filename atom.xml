<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morning~Sun。</title>
  
  <subtitle>ha</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suntus.github.io/"/>
  <updated>2020-03-14T14:14:14.153Z</updated>
  <id>http://suntus.github.io/</id>
  
  <author>
    <name>suntus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ticket相关</title>
    <link href="http://suntus.github.io/2020/03/14/ticket%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2020/03/14/ticket相关/</id>
    <published>2020-03-14T14:08:23.000Z</published>
    <updated>2020-03-14T14:14:14.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么"><a href="#1-为什么" class="headerlink" title="1. 为什么"></a>1. 为什么</h1><p>ticket给TLS提供一个不需要在server存储会话状态(session)的机制来恢复会话。适用于TLS1.0, 1.1, 1.2。在以下情况下很有用:</p><ol><li>server需要处理大量不同用户的session;</li><li>server希望长时间存储session;</li><li>需要使用跨server的负载均衡;</li><li>在内存很少的嵌入式的server上。<a id="more"></a></li></ol><p>之前使用session ID的方法需要server将各种加密参数保存在本地，client下次希望恢复session的时候，就将session ID一并带上，server根据session ID查找本地缓存，找到对应的参数，然后直接建立握手。对照上面几个情况，看session ID为什么不适用：</p><ol><li>server处理大量会话需要在本地保存很多加密参数，内存占用和查找效率都会受影响；</li><li>长时间存储session导致长时间占用内存；</li><li>session通常保存在一个server上，如果跨server负载均衡，需要将session统一存储，或支持跨server查询；</li><li>内存占用。</li></ol><h1 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2. 是什么"></a>2. 是什么</h1><h2 id="2-1-主要流程"><a href="#2-1-主要流程" class="headerlink" title="2.1. 主要流程"></a>2.1. 主要流程</h2><ol><li>第一次完整握手，client在ClientHello中发送一个空的session_ticket扩展，表示client支持ticket会话恢复机制，</li><li>server回复一个空的session_ticket扩展，表示自己将会发送一个新的ticket。server会在发送CCS之前发送一个NewSessionTicket的消息，里边存放着用于会话恢复的各种参数，并加密。</li><li>client收到后将ticket和本地的session一并存储。</li><li>第二次会话恢复，client在ClientHello中发送不为空的session_ticket扩展，表示client希望进行会话恢复；</li><li>server收到后，解密校验，如果校验正确，就使用该session参数进行会话恢复。</li><li>不管server接受不接受client发送的ticket，只要server觉得需要签发一个新的ticket，都要发送session_ticket扩展，也就是说，ServerHello中的session_ticket就是指示server是否发送NewSessionTicket的。</li></ol><p>server签发ticket的过程如下：<img src="/img/ticket相关/ticket.png" alt="ticket签发"></p><h2 id="2-2-ticket的生命周期"><a href="#2-2-ticket的生命周期" class="headerlink" title="2.2. ticket的生命周期"></a>2.2. ticket的生命周期</h2><p>开始：</p><ol><li>client从server接收新签发的ticket，保存到本地。</li></ol><p>结束：</p><ol><li>ticket在client的缓存中超时；</li><li>ticket由client的本地策略提前结束使用；</li><li>server新签发了ticket，需要更新本地的ticket；</li><li>会话恢复时出错的时，需要删除ticket。</li></ol><h2 id="2-3-ticket的相关结构"><a href="#2-3-ticket的相关结构" class="headerlink" title="2.3. ticket的相关结构"></a>2.3. ticket的相关结构</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    HandshakeType msg_type;</span><br><span class="line">    uint24 length;</span><br><span class="line">    select (HandshakeType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">hello_request:</span> HelloRequest;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">client_hello:</span> ClientHello;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">server_hello:</span> ServerHello;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">certificate:</span> Certificate;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">server_key_exchange:</span> ServerKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">certificate_request:</span> CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">server_hello_done:</span> ServerHelloDone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">certificate_verify:</span> CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">client_key_exchange:</span> ClientKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">finished:</span> Finished;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">session_ticket:</span> NewSessionTicket; <span class="comment">/* NEW */</span></span><br><span class="line">    &#125; body;</span><br><span class="line">&#125; Handshake;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    uint32 ticket_lifetime_hint;</span><br><span class="line">    opaque ticket&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">&#125; NewSessionTicket;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    opaque key_name[<span class="number">16</span>];</span><br><span class="line">    opaque iv[<span class="number">16</span>];</span><br><span class="line">    opaque encrypted_state&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    opaque mac[<span class="number">32</span>];</span><br><span class="line">&#125; ticket;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>ticket_lifetime_hint</code>: server签发的该ticket的存活时间，从client收到NewSessionTicket开始计算，client以此判断该ticket的超时时间，单位是秒。</li><li><code>ticket</code>: server签发的ticket的具体内容，包含加密的一些参数。</li><li><code>key_name</code>: 表示该ticket用的是哪组秘钥加密认证的，通过该参数，server能很容易判断该ticket是不是自己签发的。通常是在server启动时随机生成的。</li><li><code>iv</code>: server使用AES128-CBC模式去加密<code>encrypted_state</code>，用到的IV保存在这里，IV每次签发ticket的时候都随机生成，每个ticket都不一样。- <code>encrypted_state</code>：使用AES128-CBC和<code>iv</code>加密的实际session参数。</li><li><code>mac</code>: server使用HMAC-SHA256生成消息认证码MAC，认证的消息为: <code>key_name + iv + encrypted_state_len + encrypted_state</code>。</li><li>server加密需要两个秘钥——AES128-CBC使用的加密秘钥，HMAC-SHA256使用的认证秘钥。</li></ul><p>其中<code>encrypted_state</code>中没有规定，建议是：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ProtocolVersion protocol_version;</span><br><span class="line">    CipherSuite cipher_suite;</span><br><span class="line">    CompressionMethod compression_method;</span><br><span class="line">    opaque master_secret[<span class="number">48</span>];</span><br><span class="line">    ClientIdentity client_identity;</span><br><span class="line">    uint32 timestamp;</span><br><span class="line">&#125; StatePlaintext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    anonymous(<span class="number">0</span>),</span><br><span class="line">    certificate_based(<span class="number">1</span>),</span><br><span class="line">    psk(<span class="number">2</span>)</span><br><span class="line">&#125; ClientAuthenticationType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ClientAuthenticationType client_authentication_type;</span><br><span class="line">    <span class="keyword">select</span> (ClientAuthenticationType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="symbol">anonymous:</span> <span class="class"><span class="keyword">struct</span> &#123;&#125;;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="symbol">certificate_based:</span></span><br><span class="line">            ASN.<span class="number">1</span>Cert certificate_list&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>&gt;;</span><br><span class="line">        <span class="keyword">case</span> <span class="symbol">psk:</span></span><br><span class="line">            opaque psk_identity&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;; <span class="regexp">/* from [RFC4279] */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ClientIdentity;</span><br></pre></td></tr></table></figure></p><p>其中:</p><ul><li><code>protocol_version</code>: 签发该ticket时候使用的协议版本。</li><li><code>cipher_suite</code>: 签发该ticket时候使用的加密套件。</li><li><code>master_secret</code>: 签发该ticket时候使用的主秘钥。</li><li><code>timestamp</code>: server用来判断ticket是否超时的。</li><li><code>client_identity</code>: 如果进行了client认证，这里会包含一些对client认证的消息。</li><li><code>certificate_based</code>: client认证使用了证书，这里就包含client的证书列表</li><li><code>psk_identity</code>: client使用了PSK认证，这里就包含了psk的id，用该id可以查找到psk的相关信息。</li></ul><h2 id="2-4-ticket跟原有的session-ID机制的交互使用"><a href="#2-4-ticket跟原有的session-ID机制的交互使用" class="headerlink" title="2.4. ticket跟原有的session ID机制的交互使用"></a>2.4. ticket跟原有的session ID机制的交互使用</h2><ol><li>第一次握手，如果server表示会签发新的ticket，session ID就为空；</li><li>第二次握手，server拒绝使用ticket，可以发送非空的session ID表示自己支持有状态的会话恢复；</li><li>client收到NewSessionTicket的话，就丢掉任何从ServerHello中获取的session ID；</li><li>client发送ticket的时候，也可以生成一个session ID放在CH中； server如果接受ticket，也可以在SH中返回同样的session ID，这样，client就能区分server什么时候在进行会话恢复，什么时候回退到完整握手——server接受了ticket，就使用ticket进行会话恢复，此时session ID跟client发送的一样，server不接受ticket，如果返回跟client一样的session ID，就表示自己支持有状态的会话恢复，如果返回空，就表示自己不支持会话恢复，会回退到完整握手。同时，因为这个session ID是client自己生成的，所以server不接受ticket的话，也查不到session，只能回复空的session ID，client就能根据session ID是否为空，来判断是否进行会话恢复。</li><li>client发送ticket的时候，server禁止使用session ID进行有状态的恢复；</li><li>总结起来就是：有限使用ticket机制。如果client自己生成了session ID，同时又发送了ticket，server也表示要用该ticket恢复，就返回同样的session ID。</li></ol><h1 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h1><ol><li>恢复失败的session会同时将ticket失效。</li><li>被盗的ticket也无所谓，因为ticket是加密的</li><li>伪造的ticket会导致握手失败</li><li>DoS攻击的话，使用<code>key_name</code>可以抵御一部分，另外对ticket的解密校验尽量轻量化，比如使用对称加密算法。</li><li>加密ticket的key的管理建议：<ol><li>key需要随机生成；</li><li>key最少128位；</li><li>key除了加密和校验ticket，不能用作他用；</li><li>key应该周期性更新；</li><li>ticket格式或加密算法更新的话，key需要同时更新。</li></ol></li><li>ticket的有效时间可能超过24小时；</li></ol><h1 id="4-TLS1-3的ticket机制"><a href="#4-TLS1-3的ticket机制" class="headerlink" title="4. TLS1.3的ticket机制"></a>4. TLS1.3的ticket机制</h1><p>TLS1.3将有状态和无状态的会话恢复机制都整合到PSK机制中，当然，PSK也跟最开始诞生的功能有些不一样了，所以TLS1.3的PSK集中了原有的PSK功能、有状态的会话恢复功能(session ID)、无状态的会话恢复功能(ticket)。现在只简单说下PSK的会话恢复功能，TLS1.3的PSK的完整介绍后续再说。</p><p>TLS1.3的会话恢复完全抛弃了CH和SH中session_id字段的功能，但为了兼容考虑，还会在会话恢复的时候进行相应的设置——TLS1.3的client跟TLS1.2的server协商的时候。</p><h2 id="4-1-主要流程"><a href="#4-1-主要流程" class="headerlink" title="4.1. 主要流程"></a>4.1. 主要流程</h2><ol><li>第一次握手，server如果支持会话恢复，就在握手完成后，发送<code>NewSessionTicket</code>消息；</li><li>client如果收到<code>NewSessionTicket</code>消息，就将当前session和其中的ticket存储到一起；</li><li>第二次握手，client在CH中发送<code>pre_shared_key</code>扩展项，其中携带ticket。</li><li>server收到psk扩展后，先解密校验ticket，然后用ticket中的PSK相关key去校验psk。</li><li>server在握手完成后，还可能再签发一个新的<code>NewSessionTicket</code>用于替换之前的。</li></ol><h2 id="4-2-消息格式"><a href="#4-2-消息格式" class="headerlink" title="4.2. 消息格式"></a>4.2. 消息格式</h2><h3 id="4-2-1-server新签发的ticket的NewSessionTicket的消息格式为："><a href="#4-2-1-server新签发的ticket的NewSessionTicket的消息格式为：" class="headerlink" title="4.2.1. server新签发的ticket的NewSessionTicket的消息格式为："></a>4.2.1. server新签发的ticket的<code>NewSessionTicket</code>的消息格式为：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    uint32 ticket_lifetime;</span><br><span class="line">    uint32 ticket_age_add;</span><br><span class="line">    opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">    opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">&#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>ticket_lifetime</code>: ticket从签发开始的有效时间，单位是秒。server不能签发超过7天(604800s)的ticket。为0表示该ticket应该立即丢掉。由于往返时间，server可以认为稍微超过一段有效时间的过期ticket仍然有效；</li><li><code>ticket_age_add</code>: 每次签发ticket都生成的一个随机数。用于隐藏CH中<code>pre_shared_key</code>扩展项中的ticket的有效时间，防止攻击者关联起多个连接。psk中的有效时间 = (client自己保存的ticket有效时间(单位毫秒)  + ticket_age_add ) module 2^32。</li><li><code>ticket_nonce</code>: 该连接上签发的ticket的唯一标识，从0开始依次递增；</li><li><code>ticket</code>：用做CH中psk的identity，可以是一个索引(类似session ID一样的，这时候就是有状态的会话恢复)或者加密签名后的数据(类似原始的ticket，这时候就是无状态的会话恢复)。无状态的数据结构类似TLS1.2的ticket。</li><li><code>extensions</code>：TLS1.3现在只定义了一个扩展项——<code>early_data</code>，用于表示server最大能接受的早期数据大小(未加密的明文数据，不包括填充等，纯用户数据长度)。</li></ul><h3 id="4-2-2-PSK扩展项"><a href="#4-2-2-PSK扩展项" class="headerlink" title="4.2.2. PSK扩展项"></a>4.2.2. PSK扩展项</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    opaque identity&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    uint32 obfuscated_ticket_age<span class="comment">;</span></span><br><span class="line">&#125; PskIdentity<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">opaque PskBinderEntry&lt;<span class="number">32</span>..<span class="number">255</span>&gt;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    PskIdentity identities&lt;<span class="number">7</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    PskBinderEntry <span class="keyword">binders&lt;33..2^16-1&gt;;</span></span><br><span class="line"><span class="keyword">&#125; </span>OfferedPsks<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    select (Handshake.msg_type) &#123;</span><br><span class="line">        case client_hello: OfferedPsks<span class="comment">;</span></span><br><span class="line">        case server_hello: uint16 selected_identity<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125; PreSharedKeyExtension<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>identity</code>: 就是<code>NewSessionTicket.ticket</code>。</li><li><code>obfuscated_ticket_age</code>：隐藏的ticket有效时间，外部导入的PSK该值是0，上次会话建立的PSK的有效时间 = (client自己保存的ticket有效时间(单位毫秒) + ticket_age_add ) module 2^32。注意该值是以ms为单位。</li><li><code>identities</code>： cilent希望用的一个identity列表，要是有0-RTT数据，必须用第一个identity(序号是0);</li><li><code>binders</code>: 一列HMAC的值，按照<code>identities</code>的顺序依次排列。目的是将psk(ticket或者sesssion ID或者外部导入的PSK)跟当前握手绑定。</li><li><code>selected_identity</code>: server如果使用psk会话恢复，返回选择的identity的序号(从0开始)。</li></ul><h2 id="4-3-TLS1-3中ticket的安全性考虑"><a href="#4-3-TLS1-3中ticket的安全性考虑" class="headerlink" title="4.3. TLS1.3中ticket的安全性考虑"></a>4.3. TLS1.3中ticket的安全性考虑</h2><p>具体跟0-RTT的早期数据相关，后续再补。</p><h1 id="5-openssl中关于ticket的相关接口"><a href="#5-openssl中关于ticket的相关接口" class="headerlink" title="5. openssl中关于ticket的相关接口"></a>5. openssl中关于ticket的相关接口</h1><h2 id="5-1-处理ticket中的加密数据"><a href="#5-1-处理ticket中的加密数据" class="headerlink" title="5.1. 处理ticket中的加密数据"></a>5.1. 处理ticket中的加密数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/tls1.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_tlsext_ticket_key_evp_cb</span><span class="params">(SSL_CTX sslctx,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> (*cb)(SSL *s, <span class="keyword">unsigned</span> <span class="keyword">char</span> key_name[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH],</span></span></span><br><span class="line"><span class="function"><span class="params">               EVP_CIPHER_CTX *ctx, EVP_MAC_CTX *hctx, <span class="keyword">int</span> enc))</span></span>;</span><br><span class="line"><span class="comment">// OpenSSL 3.0引入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_tlsext_ticket_key_cb</span><span class="params">(SSL_CTX sslctx,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> (*cb)(SSL *s, <span class="keyword">unsigned</span> <span class="keyword">char</span> key_name[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH],</span></span></span><br><span class="line"><span class="function"><span class="params">               EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, <span class="keyword">int</span> enc))</span></span>;</span><br><span class="line"><span class="comment">// OpenSSL 3.0中被废除</span></span><br></pre></td></tr></table></figure><p>因为没有必要为每一个session都维护一个单独的加密状态，所以就交给用户去维护，然后用户负责ticket中部分参数的生成和和状态维护。</p><p>server收到client发来的空的<code>session_ticket</code>扩展项，<code>enc</code>参数为1，表示这是要签发一个新的ticket，应用需要设置<code>key_name, iv, ctx, hctx</code> 给lib，lib会使用这些信息去创建并加密ticket。<br>server收到client发来的非空的<code>session_ticket</code>扩展项，<code>enc</code>参数为0， 表示这是要解析一个ticket，lib会传给应用<code>key_name, iv</code>，应用需要设置<code>ctx, hctx</code>给lib，用以解密校验ticket。<br>返回值表示应用是否希望签发使用新的ticket:</p><ul><li>2: 表示应用已经设置了<code>ctx, hctx</code>，可以继续处理当前收到的ticket，另外需要重新签发一个ticket，该cb会在签发新ticket的时候再被调用一次，这次<code>enc</code>会被设为1.</li><li>1: <code>ctx, hctx</code>已经设置了，可以继续按默认情况处理。</li><li>0: 表示应用无法处理该ticket，需要进行完整握手或者使用session ID会话恢复机制。</li><li>小于0: 出错了。</li></ul><h2 id="5-2-设置签发和校验ticket时候的用户接口和数据"><a href="#5-2-设置签发和校验ticket时候的用户接口和数据" class="headerlink" title="5.2. 设置签发和校验ticket时候的用户接口和数据"></a>5.2. 设置签发和校验ticket时候的用户接口和数据</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (<span class="name">*SSL_CTX_generate_session_ticket_fn</span>)(<span class="name">SSL</span> *s, void *arg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef SSL_TICKET_RETURN (<span class="name">*SSL_CTX_decrypt_session_ticket_fn</span>)(<span class="name">SSL</span> *s, SSL_SESSION *ss, const unsigned char *keyname, size_t keyname_len, SSL_TICKET_STATUS status, void *arg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int SSL_CTX_set_session_ticket_cb(<span class="name">SSL_CTX</span> *ctx, SSL_CTX_generate_session_ticket_fn gen_cb, SSL_CTX_decrypt_session_ticket_fn dec_cb, void *arg)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>gen_cb()</code>是给应用提供的在生成ticket的时候进行的回调，在回调中应用可以调用<code>SSL_SESSION_set1_ticket_appdata()</code>在ticket中设置用户数据。<code>gen_cb()</code>中的参数<code>arg</code>就是<code>SSL_CTX_set_session_ticket_cb()</code>中的<code>arg</code>。<br>默认情况下，会话恢复的时候，TLS1.2不会再签发新的ticket，TLS1.3每次会话恢复都会签发新的ticket，可以用<code>SSL_CTX_set_tlsext_ticket_key_cb()</code>改变这个行为。</p><p><code>dec_cb()</code>是在库尝试解密ticket之后，给应用提供的回调。如果解密成功，<code>ss</code>中存放的是session，<code>keyname</code>和<code>keyname_len</code>是解密ticket使用的秘钥标识，<code>status</code>是解密是否成功，<code>arg</code>就是<code>SSL_CTX_set_session_ticket_cb()</code>中的<code>arg</code>。该回调被调用的时候，<code>sessionss</code>还没绑定到SSL<code>s</code>上。做任何操作前， 都要先检查<code>status</code>：</p><ul><li><code>SSL_TICKET_EMPTY</code>: 空的ticket数据，就是CH中发送了空的<code>session_ticket</code>扩展，表示client支持ticket机制。只在TLS1.2之前使用，TLS1.3没意义。</li><li><code>SSL_TICKET_NO_DECRYPT</code>: 无法解密ticket，没有ticket数据可用，且应该给client<br>发送新的ticket。</li><li><code>SSL_TICKET_SUCCESS</code>: ticket解密成功，可以使用应用数据，不应该发送新的ticket。</li><li><code>SSL_TICKET_SUCCESS_RENEW</code>: 跟<code>SSL_TICKET_SUCCESS</code>一样，但要发送新的ticket。</li></ul><p><code>dec_cb()</code>的返回值可以是：</p><ul><li><code>SSL_TICKET_RETURN_ABORT</code>: 应用判断需要中止握手，可能是由于检测ticket相关数据失败了。注意，TLS1.3一次握手可能会签发多个ticket，一个ticket失效不代表其他也失效，需要小心使用该返回值。</li><li><code>SSL_TICKET_RETURN_IGNORE</code>: 不使用该ticket，也不要签发新的ticket。</li><li><code>SSL_TICKET_RETURN_IGNORE_RENEW</code>:不使用该ticket，但签发一个新的ticket。</li><li><code>SSL_TICKET_RETURN_USE</code>: 使用ticket，但不签发新的ticket。</li><li><code>SSL_TICKET_RETURN_USE_RENEW</code>: 使用ticket，签发新的ticket。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_SESSION_set1_ticket_appdata</span><span class="params">(SSL_SESSION *ss, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_SESSION_get0_ticket_appdata</span><span class="params">(SSL_SESSION *ss, <span class="keyword">void</span> **data, <span class="keyword">size_t</span> *len)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SSL_SESSION_set1_ticket_appdata(()</code>可以将用户数据存入ticket发送给client。</p><h2 id="5-3-设置TLS1-3中ticket签发个数"><a href="#5-3-设置TLS1-3中ticket签发个数" class="headerlink" title="5.3. 设置TLS1.3中ticket签发个数"></a>5.3. 设置TLS1.3中ticket签发个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_num_tickets</span><span class="params">(SSL *s, <span class="keyword">size_t</span> num_tickets)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> SSL_get_num_tickets(SSL *s);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_num_tickets</span><span class="params">(SSL_CTX *ctx, <span class="keyword">size_t</span> num_tickets)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> SSL_CTX_get_num_tickets(SSL_CTX *ctx);</span><br></pre></td></tr></table></figure><p>设置TLS1.3完整握手后，server可以发送多少个ticket。默认是2个，也可以是0个。会话恢复之后默认发送1个新的ticket，会话恢复后发送的个数不能用这些函数改变，可以用<code>SSL_CTX_set_tlsext_ticket_key_cb</code>改变。<br>TLS1.3中，server使用<code>SSL_verify_client_post_handshake()</code>进行握手后认证，client发来证书后，还会签发新的ticket，这个ticket个数跟开始的握手时签发的个数一样，如果开始的是完整握手，那也可以在调用<code>SSL_verify_client_post_handshake()</code>之前调用<code>SSL_set_num_tickets</code>重新设置签发个数。</p><p><strong>参考</strong>:</p><ol><li><a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_num_tickets.html" target="_blank" rel="noopener">openssl手册</a></li><li><a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC8446-TLS1.3 PSK,ticket</a></li><li><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246-TLS1.2 session ID</a></li><li><a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">RFC5077-Transport Layer Security (TLS) Session Resumption without<br>Server-Side State</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-为什么&quot;&gt;&lt;a href=&quot;#1-为什么&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么&quot;&gt;&lt;/a&gt;1. 为什么&lt;/h1&gt;&lt;p&gt;ticket给TLS提供一个不需要在server存储会话状态(session)的机制来恢复会话。适用于TLS1.0, 1.1, 1.2。在以下情况下很有用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;server需要处理大量不同用户的session;&lt;/li&gt;
&lt;li&gt;server希望长时间存储session;&lt;/li&gt;
&lt;li&gt;需要使用跨server的负载均衡;&lt;/li&gt;
&lt;li&gt;在内存很少的嵌入式的server上。
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>ALPN相关</title>
    <link href="http://suntus.github.io/2019/08/30/ALPN%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2019/08/30/ALPN相关/</id>
    <published>2019-08-30T06:11:25.000Z</published>
    <updated>2019-08-30T06:13:10.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么需要ALPN"><a href="#1-为什么需要ALPN" class="headerlink" title="1. 为什么需要ALPN"></a>1. 为什么需要ALPN</h3><p>　　TLS只负责建立加密通道，不负责上层到底是什么应用，所以如果用户想在1个地址上支持多种应用协议，比如1个443端口，既想支持HTTP/1.1，还能支持HTTP/2、SPDY/1，没有ALPN（App-Layer Protocol Negotiation）的话，用户需要在ssl建立连接之后，再协商是用哪个协议，然后分发到各个协议的处理流程中，这样多了一个来回。ALPN把应用层协商附带到握手协商中，让用户在握手建立之后就立即知道使用的应用协议，这样节省了一个来回。<br><a id="more"></a></p><h3 id="2-TLS中的具体实现"><a href="#2-TLS中的具体实现" class="headerlink" title="2. TLS中的具体实现"></a>2. TLS中的具体实现</h3><p>　　主要见 <a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">RFC 7301</a>。</p><p>　　ALPN作为扩展项存在ClientHello和ServerHello中，ALPN格式为：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">       application_layer_protocol_negotiation(<span class="number">16</span>), (<span class="number">65535</span>)</span><br><span class="line">&#125; ExtensionType;</span><br><span class="line"></span><br><span class="line">The <span class="string">"extension_data"</span> field <span class="keyword">of</span> the (<span class="string">"application_layer_protocol_negotiation(16)"</span>) extension SHALL</span><br><span class="line">contain a <span class="string">"ProtocolNameList"</span> value.</span><br><span class="line"></span><br><span class="line">opaque ProtocolName&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">8</span>-<span class="number">1</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       ProtocolName protocol_name_list&lt;<span class="number">2</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;</span><br><span class="line">&#125; ProtocolNameList;</span><br></pre></td></tr></table></figure></p><p>　　协商过程:</p><ol><li>client在ClientHello中设置期望的协议列表，优先支持的放在前边。</li><li>server设置支持的应用协议列表，优先支持的放到前边。收到ClientHello后，应用选择支持的协议。</li><li>server在ServerHello中返回支持的1个应用协议，此后的应用层就使用该协议。</li><li><p>client收到ServerHello中的应用协议，此后的应用层就使用该协议。</p></li><li><p>如果server没有支持的协议，会返回握手失败的警告。</p></li></ol><p>　　需要注意的是ALPN协商每次都在握手的时候进行，不会保存到session中，所以即使会话恢复，也会重新协商。会话恢复是TLS层的东西，不是应用层的，不管是哪个协议的应用，都可以使用TLS恢复的会话。</p><h3 id="3-openssl中的接口"><a href="#3-openssl中的接口" class="headerlink" title="3. openssl中的接口"></a>3. openssl中的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client或者server设置支持的应用协议，格式是带1个字节长度前缀的协议，类似</span></span><br><span class="line"><span class="comment">// "\x08HTTP/1.1" 或者 "\x08HTTP/1.1\x06SPDY/1"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_alpn_protos</span><span class="params">(SSL_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *protos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> protos_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_alpn_protos</span><span class="params">(SSL *ssl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *protos,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> protos_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置协商回调，server在收到ALPN时会调用该回调，让用户去进行协商和一些其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_set_alpn_select_cb</span><span class="params">(SSL_CTX *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> (*cb) (SSL *ssl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **out,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">char</span> *outlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// openssl提供的标准的协商过程，应用可以在握手的时候就知道准备用什么协议了。</span></span><br><span class="line"><span class="comment">// 该函数应该在SSL_CTX_set_alpn_select_cb()设置的回调中使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_select_next_proto</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> **out, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *server,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> server_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> client_len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//  取出已经协商好的应用协议</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_get0_alpn_selected</span><span class="params">(<span class="keyword">const</span> SSL *ssl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> *len)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">RFC 7301</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为什么需要ALPN&quot;&gt;&lt;a href=&quot;#1-为什么需要ALPN&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要ALPN&quot;&gt;&lt;/a&gt;1. 为什么需要ALPN&lt;/h3&gt;&lt;p&gt;　　TLS只负责建立加密通道，不负责上层到底是什么应用，所以如果用户想在1个地址上支持多种应用协议，比如1个443端口，既想支持HTTP/1.1，还能支持HTTP/2、SPDY/1，没有ALPN（App-Layer Protocol Negotiation）的话，用户需要在ssl建立连接之后，再协商是用哪个协议，然后分发到各个协议的处理流程中，这样多了一个来回。ALPN把应用层协商附带到握手协商中，让用户在握手建立之后就立即知道使用的应用协议，这样节省了一个来回。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>RSA算法</title>
    <link href="http://suntus.github.io/2019/06/17/RSA%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/06/17/RSA算法/</id>
    <published>2019-06-17T10:49:51.000Z</published>
    <updated>2019-06-17T11:14:09.063Z</updated>
    
    <content type="html"><![CDATA[<p>比较浅显的理解，主要是对RSA算法有一些数学上的认识。<br><a id="more"></a></p><h3 id="1-数学原理"><a href="#1-数学原理" class="headerlink" title="1. 数学原理"></a>1. 数学原理</h3><h4 id="1-1-质数很容易生成"><a href="#1-1-质数很容易生成" class="headerlink" title="1.1 质数很容易生成"></a>1.1 质数很容易生成</h4><p>给定一个长度，很容易找到符合这个长度的一个随机质数。这个结论依赖两点：</p><ol><li>质数在任意长度内都广泛存在；</li><li>即使数很大(比如4096位)，也很容易判断它到底是不是个质数。</li></ol><p>要生成一个质数，先随机生成一批给定长度的数字，然后判断它们是不是质数。根据<code>Prime Number Theorem</code>，找到一个质数，需要判断的候选数字个数在$\ln(x)$的阶上($O(\ln(x))$???), $x$是给定的长度。</p><p>之前判断一个数是不是质数需要找它所有的因子，看是不是只有1和它本身，如果是那就是质数。现在的方法是判断一个数是不是有质数的一些性质。如果不能很快判断一个数是不是质数，现代的很多公钥算法就很难实际应用了。</p><h4 id="1-2-乘法很容易计算"><a href="#1-2-乘法很容易计算" class="headerlink" title="1.2 乘法很容易计算"></a>1.2 乘法很容易计算</h4><p>有两个很大(512位以上)的质数$p, q$, 很容易算出他们的乘积$n = pq$。</p><h4 id="1-3-因式分解很难"><a href="#1-3-因式分解很难" class="headerlink" title="1.3 因式分解很难"></a>1.3 因式分解很难</h4><p>尽管经过几百年的研究，现在因式分解的方法比一个个查找的方法快很多(现在最快的能接近$\sqrt{n}$)，但还是很慢，非常慢。</p><h4 id="1-4-幂的模很容易计算"><a href="#1-4-幂的模很容易计算" class="headerlink" title="1.4 幂的模很容易计算"></a>1.4 幂的模很容易计算</h4><p>给定$n, m, e$, 很容易算出来$c = m^e \text{ mod } n$</p><h4 id="1-5-如果给出因子，很容易计算出模的根"><a href="#1-5-如果给出因子，很容易计算出模的根" class="headerlink" title="1.5 如果给出因子，很容易计算出模的根"></a>1.5 如果给出因子，很容易计算出模的根</h4><p>给定$n, e, c$，还有$n$的质数因子$p, q$, 很容易计算出$c = m^e \text{ mod } n$中的$m$<br>方法就是存在$d$满足$m = (m ^ e) ^ d \text{ mod } n = c^d \text{ mod } n$</p><p>其中d按如下方法计算：<br>$L = LCM(p-1, q-1)$，LCM是$p-1,q-1$的最小公倍数，$d$是所有满足 $d \cdot e \text{ mod } L = 1$的数，也就是说，$d$和$e$是关于$\text{ mod } L$的倒数，$e$跟$p-1$和$q-1$互质保证了$d$一定存在。模倒数可以用扩展欧几里得算法很容易算出来。</p><h4 id="1-6-如果不给出因子，计算模的根很难"><a href="#1-6-如果不给出因子，计算模的根很难" class="headerlink" title="1.6 如果不给出因子，计算模的根很难"></a>1.6 如果不给出因子，计算模的根很难</h4><p>如果只给出$n, e, c$，不给出n的因子$p, q$，就很难计算出$c = m^e \text{ mod } n$中的$m$。</p><p>要恢复$m$，需要先找到$d$，事实上，任何确定d的方法都会转到因式分解$n$的路上。</p><h3 id="2-RSA加解密"><a href="#2-RSA加解密" class="headerlink" title="2. RSA加解密"></a>2. RSA加解密</h3><p>有了以上的基础，现在可以描述一下RSA密钥对儿的生成步骤了。</p><p>加密系统中的公钥包含$n$和$e$，$n$叫<em>模数(modulus)</em>，$e$叫<em>公钥指数(public exponent)</em>。私钥包含$n$和$d$，$d$叫<em>私钥指数(private exponent)</em>。</p><p>生成步骤如下：</p><ol><li>生成一对儿很大的随机质数$p,q$</li><li>计算模数$n = pq$</li><li>在[3,n-1]之间挑选一个奇数$e$, 作为公钥指数，并保证$e$和 $p-1、q-1$互质。</li><li>用$e, p, q$计算私钥指数$d$。 先算$L = LCM(p-1, q-1)$, LCM是$p-1$和$q-1$的最小公倍数，$d$满足$d \cdot e \text{ mod } L = 1$， 可以用扩展欧几里得算法算出来。</li><li>$(n, e)$就是公钥， $(n, d)$就是私钥。</li></ol><p>加密操作：</p><script type="math/tex; mode=display">c = m^e \text{ mod } n</script><p>解密操作:</p><script type="math/tex; mode=display">m = c^d \text{ mod } n</script><p>签名操作：</p><script type="math/tex; mode=display">s = m^d \text{ mod } n</script><p>验签操作：</p><script type="math/tex; mode=display">m = s^e \text{ mod } n</script><p>我们常数的RSA 4096指的是$n$的位数，表示RSA算法一次可以加密多少位的数据。</p><h3 id="3-openssl相关的几个问题"><a href="#3-openssl相关的几个问题" class="headerlink" title="3. openssl相关的几个问题"></a>3. openssl相关的几个问题</h3><ol><li><code>RSA_size()</code>和<code>RSA_bits()</code>的返回值<br><code>RSA_size()</code>返回的是rsa-&gt;n的字节数，这个值乘8就是期望的1024, 2048, 4096等值。<br><code>RSA_bits()</code>返回的是rsa-&gt;n的有效位数，这个值不一定就是1024这些值，因为最高有效位可能是0。(其实openssl内置的rsa密钥生成函数中，保证了n的最高4个有效位必须在[0x9, 0xf]之间)。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>讲RSA非常好的一个，基本是这篇的摘要: The Mathematics of the RSA Public-Key Cryptosystem</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较浅显的理解，主要是对RSA算法有一些数学上的认识。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>ECC算法</title>
    <link href="http://suntus.github.io/2019/05/31/ECC%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/05/31/ECC算法/</id>
    <published>2019-05-31T11:04:38.000Z</published>
    <updated>2019-05-31T15:36:45.747Z</updated>
    
    <content type="html"><![CDATA[<p>对TLS1.3中用到的ECC相关算法，比如ECDH, ECDSA, X25519等进行一下基础说明，起码知道group、curve之类的是什么意思。<br><a id="more"></a></p><h2 id="1-椭圆曲线-Elliptic-Curves"><a href="#1-椭圆曲线-Elliptic-Curves" class="headerlink" title="1. 椭圆曲线(Elliptic Curves)"></a>1. 椭圆曲线(Elliptic Curves)</h2><p>椭圆曲线的Weierstrass标准形式：</p><script type="math/tex; mode=display">y^2 = x^3 + ax + b</script><script type="math/tex; mode=display">4a^3 + 27b^2 != 0</script><p>定义0表示椭圆曲线上的无限远点，这样组成的椭圆曲线是这样的：</p><script type="math/tex; mode=display">\left\{ (x, y) \in \mathbb{R}^2\ |\ y^2 = x^3 + ax + b,\ 4 a^3 + 27 b^2 \ne 0 \right\}\ \cup\ \left\{ 0 \right\}</script><h2 id="2-群-Group"><a href="#2-群-Group" class="headerlink" title="2. 群(Group)"></a>2. 群(Group)</h2><p>$\mathbb{G}$是一个集合，在集合中定义一个对两个元素的操作，记为<code>&quot;加&quot;</code>,用<code>+</code>表示，集合中两个元素a和b,<code>&quot;加&quot;</code>操作表示为$a+b$，如果$a+b$这个操作满足一下4个特性，$\mathbb{G}$就是一个群(Group):</p><ul><li>闭合性closure: a, b是$\mathbb{G}$的元素，$a+b$也是；</li><li>结合性associativity: $(a+b)+c=a+(b+c)$</li><li>存在单位元identity element 0, 有$a+0=0+a=a$</li><li>每个元素都有一个相反数，对每个元素a都存在b使$a+b=0$, b就是a的相反数，可以表示为$-a$</li></ul><p>如果再加一条特性：</p><ul><li>交换律：$a+b=b+a$<br>这样的群就要阿贝尔群(Abelian Group)</li></ul><p>这个”加+”操作，也可以用”乘*”来表示，这个操作只是表示集合上两个元素的一个操作，此时</p><ul><li>$a \cdot b$ 也是 $\mathbb{G}$ 上的一个元素；</li><li>$(a \cdot b) \cdot c=a \cdot (b \cdot c)$</li><li>单位元1， $a \cdot 1=1 \cdot a=a$</li><li>$a \cdot b=1$， b可以表示为$a^{-1}$</li></ul><p>在讨论ECC的时候，一些旧的文献通常用<code>+</code>，新的通常用<code>*</code>，另外，在密码学中讨论加密强度的时候，通常按照指数(幂)、读书来讨论，比如长听到取离散对数问题。本文都用<code>+</code>来表示。</p><h2 id="3-椭圆曲线上的群"><a href="#3-椭圆曲线上的群" class="headerlink" title="3. 椭圆曲线上的群"></a>3. 椭圆曲线上的群</h2><p>可以定义一个在椭圆曲线上的群$\mathbb{G}$：</p><ul><li>一个椭圆曲线上的点是$\mathbb{G}$中的元素;</li><li>单位元定义为无穷远处的点0</li><li>一个点P的相反数是关于x轴对称的点</li><li><code>加</code>定义为： $P, Q, R$是斜率相同的点(一条直线跟椭圆曲线相交的3个点)，有$P+Q+R=0$</li></ul><p>这样就有$R=-(P+Q)$，如果要用计算机去算，需要转换成代数的方法计算R的x,y坐标<br>记</p><script type="math/tex; mode=display">P=(x_P, y_P), Q=(x_Q, y_Q), R=(x_R, y_R)</script><p>则:</p><script type="math/tex; mode=display">m = \frac{y_P - y_Q}{x_R - x_Q}</script><script type="math/tex; mode=display">x_R = m^2 - x_P - x_Q</script><script type="math/tex; mode=display">y_R = y_P + m(x_R - x_P)</script><p>这样，就能根据$P, Q$算出$R$了。</p><h2 id="4-标量乘法"><a href="#4-标量乘法" class="headerlink" title="4. 标量乘法"></a>4. 标量乘法</h2><script type="math/tex; mode=display">nP = \underbrace{P + P + \cdots + P}_{n\ \text{times}}</script><p>叫做<code>标量乘法</code>.<br>有个快速算法：<code>double and add</code>，<br>比如 $n = 151$， 用2进制表示为$10010111b$，然后</p><script type="math/tex; mode=display">\begin{array}{rcl}    151 & = & 1 \cdot 2^7 + 0 \cdot 2^6 + 0 \cdot 2^5 + 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 \\    & = & 2^7 + 2^4 + 2^2 + 2^1 + 2^0\end{array}</script><p>就可以很方便的用计算机去算了。</p><h2 id="5-对数"><a href="#5-对数" class="headerlink" title="5. 对数"></a>5. 对数</h2><p>对$Q=nP$,如果知道$n$和$P$，可以很容易算出$Q$(double and add)， 但如果知道$Q$和$P$，却很难算出$n$——数学上没有很快的算法。<br>如果用<code>*</code>来表示，那就是$Q=P^n$,知道$Q$和$P$，很难算出指数$n$，这就是取对数难题，也是密码学中的基石。</p><h2 id="6-有限域-Finite-Field"><a href="#6-有限域-Finite-Field" class="headerlink" title="6. 有限域(Finite Field)"></a>6. 有限域(Finite Field)</h2><p>有限域，就是域中元素是有限个数的域，整个实数域是无限的，如果对实数取$ \text{ mod }  p$，就可以得到元素个数为p的有限域了，<br>域中多一个操作乘，符合结合律：$x \cdot (y+z)=x \cdot y+x \cdot z$</p><p>先了解mod运算</p><script type="math/tex; mode=display">(18+9)  \text{ mod }  23=4</script><script type="math/tex; mode=display">-5  \text{ mod }  23 = 18</script><script type="math/tex; mode=display">9^{-1}  \text{ mod }  23 = 18</script><p>因为在域23上，$9^{-1} = 18$(因为 $9 \cdot 18  \text{ mod }  23 = 1, 9 \cdot 9{^-1} mod 23 = 1$, 域上1个元素有且只有1个倒数，所以$9^{-1} = 18$，9的倒数是18)</p><h2 id="7-mod-p-除法"><a href="#7-mod-p-除法" class="headerlink" title="7. mod p 除法"></a>7. mod p 除法</h2><p>要计算$\frac{x}{y}$，需要计算$x \cdot y^{^-1}$,也是就是我们要先找到y的倒数，然后再乘上x<br>取一个数的倒数用扩展欧几里得算法可以很简单算出来。</p><h2 id="8-有限域-GF-p-中的椭圆曲线"><a href="#8-有限域-GF-p-中的椭圆曲线" class="headerlink" title="8. 有限域$GF(p)$中的椭圆曲线"></a>8. 有限域$GF(p)$中的椭圆曲线</h2><p>先前的椭圆曲线是实数域上的，现在挑选其中在有限域$GF(p)$上的点，就组成了椭圆曲线上的有限域——或者有限域上的椭圆曲线。</p><h2 id="9-有限域上的椭圆曲线的加法"><a href="#9-有限域上的椭圆曲线的加法" class="headerlink" title="9. 有限域上的椭圆曲线的加法"></a>9. 有限域上的椭圆曲线的加法</h2><p>还是$P+Q+R=0$，但$P，Q, R$在有限域上怎么斜率相同呢？——在一条直线上即可。但有限域上的直线跟是实数域上有些不同，只要有限域中的点$(x,y)$符合$ax+by+c ( \text{ mod }  p) = 0 ( \text{ mod }  p)$，就说这些点在同一条直线上——这样的直线画出来可能有很多并行的条，都算同一条直线。</p><p>这样，有限域上的加法用计算机计算，公式是这样的</p><script type="math/tex; mode=display">x_R = (m^2-x_P-x_Q)  \text{ mod }  p</script><script type="math/tex; mode=display">y_R = [y_P + m(x_R-x_P)]  \text{ mod }  p = [y_Q + m(x_R-x_Q)]  \text{ mod }  p</script><p>这样就可以用计算机计算$P + Q = R$了</p><h2 id="10-一个椭圆曲线群的阶order"><a href="#10-一个椭圆曲线群的阶order" class="headerlink" title="10. 一个椭圆曲线群的阶order"></a>10. 一个椭圆曲线群的阶<code>order</code></h2><p>首先，一个群上的点的元素个数，叫做这个群的阶。<br>定义在一个有限域上的一个椭圆曲线的元素个数是多少呢？有个快速的算法可以计算: <code>Schoof’s algorithm</code>。可以方便计算椭圆曲线在有限域上的元素个数。</p><h2 id="11-标量乘法和曲线子群"><a href="#11-标量乘法和曲线子群" class="headerlink" title="11. 标量乘法和曲线子群"></a>11. 标量乘法和曲线子群</h2><p>标量乘法是这样的</p><script type="math/tex; mode=display">n P = \underbrace{P + P + \cdots + P}_{n\ \text{times}}</script><p>但在有限域上，我们可以想象出<br>$1P$<br>$2P$<br>$3P$<br>$…$<br>得出的结果最终会形成一个循环，而且循环中的所有结果都在有限域上，这样，我们根据$P$生成了一个曲线子群，$P$就叫做这个子群的生成因子后者基准点。曲线子群就是ECC和其他加密系统的基础。</p><p>现在我们梳理一下：</p><ul><li>一开始我们有实数群$\mathbb{G}$,</li><li>我们取椭圆曲线，得出椭圆曲线上的点，形成一个小一点的群</li><li>接着定义有限域，然后将椭圆曲线限制到有限域上，这样框出来的椭圆曲线上的点，形成一个更小一点的群</li><li>最后，我们取其中一个点作为基准点，取基准点的向量倍数，生成一个再小一点的子群，这个群，就是我们的ECC要用的群了。</li></ul><h2 id="12-子群的阶"><a href="#12-子群的阶" class="headerlink" title="12. 子群的阶"></a>12. 子群的阶</h2><p>我们想知道，由基准点$P$生成的子群的阶是多少。现在不能用<code>Schoof’s</code>算法，它是工作在整个椭圆曲线上，而不是其中的一个子群。<br>要算子群的阶，需要知道：</p><ol><li>子群的阶就是子群中的元素个数，等价于 $nP=0$，其$n$是正整数，且$n$是其中最小的1个，这个$n$就是子群的阶。</li><li>根据拉格朗日定理，子群$P$的阶，是父群阶的一个因子，比如一个椭圆曲线有$N$个元素，它的一个子群有$n$个元素，$n$能整除$N$</li></ol><p>接着我们开始算子群P的阶：</p><ol><li>用<code>Schoof&#39;s</code>算法计算椭圆曲线的阶$N$</li><li>找出$N$的所有因子</li><li>对$N$的每一个因子$n$，计算$nP$</li><li>找出使$nP=0$的最小的$n$，这个$n$就是子群的阶.</li></ol><p>比如对$GP(37)$有限域上的椭圆曲线 $y^2 = x^3 - x + 3$,  它的阶$N=42$，子群可能有的阶$n = 1, 2, 3, 6, 7, 14, 21, 42$,  如果我们取基准点$P = (2, 3)$，那么</p><script type="math/tex; mode=display">P != 0, 2P !=0, 3P != 0, 6P!= 0, 7P=0</script><p>那么就说，$P$的阶是$n = 7$</p><h2 id="13-找一个基准点"><a href="#13-找一个基准点" class="headerlink" title="13. 找一个基准点"></a>13. 找一个基准点</h2><p>对ECC算法来说，我们希望子群拥有更高的阶。<br>我们先计算椭圆曲线的阶$N$，找一个比较大的因子$n$，然后根据$n$找出一个合适的基准点。<br>也就是说，我们先找子群的阶，再根据子群的阶找其中的基准点。而不是先找基准点，再算子群的阶。</p><p>再加一个信息：根据拉格朗日定理，$h = N/n$肯定是个整数（因为$n$是$N$的一个因子）。这个$h$叫做子群的协因子(cofactor).</p><p>对一个椭圆曲线上的任意一点来说， $NP = 0$,因为$N$总是任何一个$n$的倍数；<br>也就是 $n(hP) = 0$<br>取$n$是素数，点$G = hP$生成一个阶为$n$的子群。<br>这样，我们就根据选择的阶$n$，算出了一个基准点。</p><h2 id="14-离散对数"><a href="#14-离散对数" class="headerlink" title="14. 离散对数"></a>14. 离散对数</h2><p>在连续的椭圆曲线上，我们如果知道$P$和$Q$很难算出$k$，使得$Q = kP$，<br>那么，<br>在有限域上的椭圆曲线，这个也是很多难的，叫做椭圆曲线的离散对数问题。</p><p>ECC有意思的一点是，这个离散对数问题“更难”，也就是要达到相同的加密强度，$k$的位数可以更少。这也是有RSA，还有开发ECC的原因。</p><h2 id="15-定义一个ECC的域需要的参数"><a href="#15-定义一个ECC的域需要的参数" class="headerlink" title="15. 定义一个ECC的域需要的参数"></a>15. 定义一个ECC的域需要的参数</h2><ol><li>有限域的大小是个素数$p$</li><li>椭圆曲线中的系数$a,b$</li><li>子群基准点$G$</li><li>子群的阶$n$</li><li>子群的协因子$h$</li></ol><p>所以，定义一个我们ECC需要的问题域需要6个因子$（p, a, b , G, n, h）$</p><h2 id="16-随机曲线"><a href="#16-随机曲线" class="headerlink" title="16. 随机曲线"></a>16. 随机曲线</h2><p>并不是所有的椭圆曲线上的离散对数都那么难，比如$p = hn$的椭圆曲线就可以用<code>Smart</code>方法攻击。而且我们也不知道还有没有哪些椭圆曲线的攻击方法我们没发现。<br>一个更具密码学强度的方法是，我们选一个随机因子$S$，对$S$取hash，然后衍生出$a、b$或者$G$，或者两者都用$S$生成，那么攻击者就不知道我们用的是什么参数，会更安全些。<br>但是，NIST规定了一些$S$，我们也不知道$S$是不是精心挑选的。。。。。。</p><h2 id="17-ECC算法"><a href="#17-ECC算法" class="headerlink" title="17. ECC算法"></a>17. ECC算法</h2><ol><li>私钥就是从$[1,n-1]$($n$是子群的阶)中随机挑选的一个整数$d$</li><li>公钥就是点$H = dG$($G$是子群的基准点)</li></ol><p>知道$d$和$G$，算出$H$很简单，但反过来就很难。<br>这是个非对称加密算法，基于此，衍生出两个算法ECDH（用于密钥交换），ECDSA（用于签名）</p><h2 id="18-ECDH"><a href="#18-ECDH" class="headerlink" title="18. ECDH"></a>18. ECDH</h2><ol><li>Alice和Bob各自生成自己的公私钥，Alice的私钥是$d_A$, 公钥是$H_A = d_A \cdot G$，Bob的是$d_B$和$H_B=d_B \cdot G$。注意Alice和Bob用的是同一个有限域上的同一个椭圆曲线的同一个基准点$G$</li><li>Alice和bob在一个未加密的通道上交换公钥$H_A$和$H_B$,</li><li>Alice计算$S = d_A \cdot H_B$, Bob计算$S = d_B \cdot H_A$, 两个计算出来的$S$是一样的</li></ol><p>这样Alice和Bob就得出了同一个$S$，就可用于对称加密了。</p><p>一个例子</p><ul><li>$p$ = 0xffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f</li><li>$a$ = 0</li><li>$b$ = 7</li><li>$x_G$ = 0x79be667e f9dcbbac 55a06295 ce870b07 029bfcdb 2dce28d9 59f2815b 16f81798</li><li>$y_G$ = 0x483ada77 26a3c465 5da4fbfc 0e1108a8 fd17b448 a6855419 9c47d08f fb10d4b8</li><li>$n$ = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141</li><li>$h$ = 1<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Curve: secp256k1</span><br><span class="line">Alice's private key: 0xe<span class="number">32868331</span>fa8ef<span class="number">0138</span>de0de<span class="number">85478346</span>aec5e<span class="number">3912</span>b<span class="number">6029</span>ae<span class="number">7169</span>1c<span class="number">384237</span>a3eeb</span><br><span class="line">Alice's public key: (<span class="number">0</span>x86b1aa5120f079594348c67647679e7ac4c365b2c01330db782b0ba611c1d677, <span class="number">0</span>x5f4376a23eed633657a90f385ba21068ed7e29859a7fab09e953cc5b3e89beba)</span><br><span class="line">Bob's private key: 0xcef<span class="number">147652</span>aa<span class="number">9016</span>2e1fff9cf07f<span class="number">2605</span>ea<span class="number">0552</span>9ca215a<span class="number">0435</span>0a98ecc24aa<span class="number">3434</span>2</span><br><span class="line">Bob's public key: (<span class="number">0</span>x4034127647bb7fdab7f1526c7d10be8b28174e2bba35b06ffd8a26fc2c20134a, <span class="number">0</span>x9e773199edc1ea792b150270ea3317689286c9fe239dd5b9c5cfd9e81b4b632)</span><br><span class="line">Shared secret: (<span class="number">0</span>x3e2ffbc3aa8a2836c1689e55cd169ba638b58a3a18803fcf7de153525b28c3cd, <span class="number">0</span>x43ca148c92af58ebdb525542488a4fe6397809200fe8c61b41a105449507083)</span><br></pre></td></tr></table></figure></li></ul><p>PS：每次都生成新的公私钥，就叫ECDHE，E表示Ephermeral，瞬时的，短暂的</p><h2 id="19-ECDSA"><a href="#19-ECDSA" class="headerlink" title="19. ECDSA"></a>19. ECDSA</h2><p>Alice使用私钥$d_A$签名消息，Bob使用Alice的公钥$H_A$验签。<br>ECDSA需要对消息的摘要进行签名，而不是对任意长度的消息签名。消息摘要需要截断到跟子群的阶$n$一样长度的位数，截断的摘要用作为一个整数$z$</p><p>签名:</p><ol><li>从$[1,n-1]$($n$是子群的阶)中随机选择一个整数$k$</li><li>计算$P=kG$（$G$是子群的基准点）</li><li>计算$r = x_P  \text{ mod }  n$($x_P$是$P$的x坐标)</li><li>如果$r=0$，重新选择$k$</li><li>计算$s = k^{-1}(z + r \cdot d_A)  \text{ mod }  n$（$d_A$是Alice的私钥，$k^{-1}$是$k$的乘法倒数 mod n）</li><li>如果$s=0$，重新选择$k$</li></ol><p>$(r,s)$组成的对儿就是签名</p><p>验签：</p><ol><li>计算$u_1 = s^{-1} \cdot z  \text{ mod }  n$</li><li>计算$u_2 = s^{-1} \cdot r  \text{ mod }  n$</li><li>计算点$P = u_1G+u_2H_A$<br>如果$r = x_P \text{ mod } n$， 就说明签名正确</li></ol><p>例子<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Curve</span>: secp256k1</span><br><span class="line">Private <span class="attribute">key</span>: <span class="number">0</span>x9f4c9eb899bd86e0e83ecca659602a15b2edb648e2ae4ee4a256b17bb29a1a1e</span><br><span class="line">Public <span class="attribute">key</span>: (<span class="number">0</span>xabd9791437093d377ca25ea974ddc099eafa3d97c7250d2ea32af6a1556f92a, <span class="number">0</span>x3fe60f6150b6d87ae8d64b78199b13f26977407c801f233288c97ddc4acca326)</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hello!'</span></span><br><span class="line"><span class="attribute">Signature</span>: (<span class="number">0</span>xddcb8b5abfe46902f2ac54ab9cd5cf205e359c03fdf66ead1130826f79d45478, <span class="number">0</span>x551a5b2cd8465db43254df998ba577cb28e1ee73c5530430395e4fba96610151)</span><br><span class="line"><span class="attribute">Verification</span>: signature matches</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hi there!'</span></span><br><span class="line"><span class="attribute">Verification</span>: invalid signature</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hello!'</span></span><br><span class="line">Public <span class="attribute">key</span>: (<span class="number">0</span>xc40572bb38dec72b82b3efb1efc8552588b8774149a32e546fb703021cf3b78a, <span class="number">0</span>x8c6e5c5a9c1ea4cad778072fe955ed1c6a2a92f516f02cab57e0ba7d0765f8bb)</span><br><span class="line"><span class="attribute">Verification</span>: invalid signature</span><br></pre></td></tr></table></figure></p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ </a>: 这个系列非常好，基本是翻译了这篇原文.</li><li><a href="https://tools.ietf.org/html/rfc8422" target="_blank" rel="noopener">RFC8442-Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</a>: 定义了TLS1.2及以前的协议使用的ECC曲线都有哪些，比如X25591,secp256r1等.</li><li><a href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener">RFC7748-Elliptic Curves for Security</a>: 具体定义了X25519,X448曲线算法.</li><li><a href="https://tools.ietf.org/html/rfc6090" target="_blank" rel="noopener">RFC6090-Fundamental Elliptic Curve Cryptography Algorithms</a>: ECC基本定义.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对TLS1.3中用到的ECC相关算法，比如ECDH, ECDSA, X25519等进行一下基础说明，起码知道group、curve之类的是什么意思。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>HKDF算法</title>
    <link href="http://suntus.github.io/2019/05/09/HKDF%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/05/09/HKDF算法/</id>
    <published>2019-05-09T11:14:44.000Z</published>
    <updated>2019-05-09T15:05:59.166Z</updated>
    
    <content type="html"><![CDATA[<p>　　是tls1.3中关于密钥生成的重要的基础算法，跟密钥推导密切相关。<br><a id="more"></a><br>　　HKDF叫<code>HMAC-based KDF(key derivation function)，基于HMAC的密钥推导函数</code>，所以我们先认识HMAC算法。</p><h2 id="1-HMAC"><a href="#1-HMAC" class="headerlink" title="1. HMAC"></a>1. HMAC</h2><p>　　基于一个共同密钥，在两个对端之间提供消息完整性确认的机制叫<code>&quot;message authentication codes(MAC)，消息认证码&quot;</code>。其实就是将消息进行hash，得到的hash值附加到消息之后，随消息一起发送，对端接收后，同样进行hash，来验证消息是否被篡改——关键点在不同数据得到的hash值一定不同——其中得到的hash值就是MAC（在别的语境里边也叫消息摘要）。另外，为了避免使用同样的hash函数对相同数据进行操作总是得出同样的摘要，额外加入一个密钥，这样使用不同密钥就可以得出不同的MAC，当然，这个密钥是两个对端都知道的。这样，我们就得到了基于加密hash的消息完整性认证的算法——Hash-based MAC。</p><h3 id="1-1-HMAC定义如下："><a href="#1-1-HMAC定义如下：" class="headerlink" title="1.1 HMAC定义如下："></a>1.1 HMAC定义如下：</h3><p>输入：</p><pre><code>1. 使用的加密hash函数H，输出长度为hashLen2. 使用的密钥K,长度hashLen &lt;= Klen &lt;= 64，如果K的长度超过64，则先用hash函数进行一次hash，用得到的值作为K3. 需要认证的数据text</code></pre><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息完整性认证码HMAC</span><br></pre></td></tr></table></figure></p><p>过程：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义 ipad = <span class="number">64</span>个<span class="number">0</span>x36, opad = <span class="number">64</span>个<span class="number">0</span>x5c</span><br><span class="line">HMAC = HMAC-Hash(H, K, <span class="built_in">text</span>) = H(K <span class="built_in">XOR</span> opad, H(K <span class="built_in">XOR</span> ipad, <span class="built_in">text</span>))</span><br></pre></td></tr></table></figure></p><p>目的：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为<span class="built_in">text</span>生成一个HMAC消息完整性认证码，输出长度就是hash函数的输出长度</span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf1.png" alt="HMAC"></p><h2 id="2-HKDF"><a href="#2-HKDF" class="headerlink" title="2. HKDF"></a>2. HKDF</h2><p>　　HKDF的主要目的使用原始的密钥材料,派生出一个或更多个能达到密码学强度的密钥(主要是保证随机性)——就是将较短的密钥材料扩展成较长的密钥材料，过程中需要保证随机性。<br>　　HKDF包含两个基本模块,或者说两个基本使用步骤:<code>1. 提取 Extract, 2. 扩展 Expand</code>。</p><ol><li><strong><em>提取</em></strong>：使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥</li><li><strong><em>扩展</em></strong>：使用第1步骤提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。</li></ol><h3 id="2-1-HKDF-Extract"><a href="#2-1-HKDF-Extract" class="headerlink" title="2.1 HKDF-Extract"></a>2.1 HKDF-Extract</h3><p>输入：</p><pre><code>1. HMAC使用的hash函数H，H输出长度是hashLen2. 原始密钥材料IKM(input keying material)3. 另外的随机源salt, 如果没有，默认是hashLen长度的0串</code></pre><p>输出:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashLen长度的伪随机密钥prk(pseudorandom <span class="built_in">key</span>)</span><br></pre></td></tr></table></figure></p><p>过程:<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prk = HKDF-<span class="keyword">Extract</span>(H, salt, IKM) = HMAC-<span class="keyword">Hash</span>(H, salt, IKM)</span><br><span class="line">其实就相当于用salt作为HMAC-<span class="keyword">Hash</span>的<span class="keyword">K</span>，对IKM进行消息完整性认证</span><br></pre></td></tr></table></figure></p><p>目的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用salt增加IKM的随机性</span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf2.png" alt="HKDF-Extract"></p><h3 id="2-2-HKDF-Expand"><a href="#2-2-HKDF-Expand" class="headerlink" title="2.2 HKDF-Expand"></a>2.2 HKDF-Expand</h3><p>输入：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>HMAC使用的hash函数H，H输出长度是hashLen</span><br><span class="line"><span class="bullet">2. </span>第一步生成的PRK</span><br><span class="line"><span class="bullet">3. </span>另外的随机元info，可以为空</span><br><span class="line"><span class="bullet">4. </span>期望生成的密钥长度L</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L长度的OKM(<span class="keyword">output</span> keying material)</span><br></pre></td></tr></table></figure></p><p>过程:<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">N</span> = ceil(L/hashLen)</span><br><span class="line">    <span class="built_in">T</span> = <span class="built_in">T</span>(<span class="number">1</span>) || <span class="built_in">T</span>(<span class="number">2</span>) || <span class="built_in">T</span>(<span class="number">3</span>) || ... || <span class="built_in">T</span>(<span class="built_in">N</span>)</span><br><span class="line">    OKM = <span class="built_in">T</span>的前L字节</span><br><span class="line"></span><br><span class="line">    <span class="built_in">T</span>(<span class="number">0</span>) = 空</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">1</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">0</span>) || <span class="built_in">info</span> || <span class="number">0</span>x01)</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">2</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">1</span>) || <span class="built_in">info</span> || <span class="number">0</span>x02)</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">3</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">2</span>) || <span class="built_in">info</span> || <span class="number">0</span>x03)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>目的:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将PRK扩展到指定长度L，同时保持密码学强度<span class="comment">(随机性)</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf3.png" alt="HKDF-Expand"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol><li>HKDF是密钥推导算法，根据一个原始密钥材料，推导出指定长度的密钥；</li><li>HKDF基于HMAC；</li><li>HMAC是基于加密hash函数的消息完整性认证算法，主要目的是认证消息完整性。在这里被用于增加原始密钥材料的随机性；</li><li>HKDF包含两步：(1) 提取Extract, (2) 扩展Expand；</li><li>HKDF-Extract就是HMAC，取IKM的认证码，也就相当于用额外的随机源salt(Key)增加了IKM(text)的随机性；</li><li>HKDf-Expand就是将短密钥变长，同时保证随机性。</li></ol><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc5869" target="_blank" rel="noopener">RFC5869: HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a></li><li><a href="https://www.ietf.org/rfc/rfc2104.txt" target="_blank" rel="noopener">RFC2104: HMAC: Keyed-Hashing for Message Authentication</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　是tls1.3中关于密钥生成的重要的基础算法，跟密钥推导密切相关。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>顺时针规则--C语言声明</title>
    <link href="http://suntus.github.io/2017/12/19/%E9%A1%BA%E6%97%B6%E9%92%88%E8%A7%84%E5%88%99--C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/"/>
    <id>http://suntus.github.io/2017/12/19/顺时针规则--C语言声明/</id>
    <published>2017-12-19T05:44:49.000Z</published>
    <updated>2017-12-20T01:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>The “Clockwise/Spiral Rule”<br>By David Anderson</p><p>每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!<br><a id="more"></a><br>该规则只有简单的3步：</p><ol><li><p>从未知元素开始，沿顺时针/螺旋方向移动；当遇到如下元素的时候，用相应的自然语言陈述出来：</p><ul><li>[X] 或者 [] =&gt; 大小为…的数组X 或 未知大小数组的…(Array X size of… or Array undefined size of…)</li><li>(type1, type2) =&gt; 传入type1和type2参数、返回…的函数(function passing type1 and type2 returning…)</li><li>* =&gt; 指向…的指针(pointer(s) to…)</li></ul></li><li><p>一直沿着顺时针往下进行，直到覆盖了所有的元素。</p></li><li>括号内的永远优先!</li></ol><p>其实对英文来说就是不断在后边加定语，但对汉语来说，就需要不断在前边加定语。</p><h2 id="1-简单声明"><a href="#1-简单声明" class="headerlink" title="1.简单声明"></a>1.简单声明</h2><pre><code>                 +-------+                 | +-+   |                 | ^ |   |            char *str[10];             ^   ^   |   |             |   +---+   |             +-----------+</code></pre><p>首先需要问的是：<code>str</code>是什么？</p><blockquote><p>str 是个…(str is an…)</p><ul><li>我们从<code>str</code>开始顺时针移动，碰到的第一个元素是<code>[</code>，这意味着我们碰到了个数组，于是就有…<br>str是个大小是10、…的数组(str is an array 10 of…)</li><li>继续顺时针，下一个遇到的是<code>*</code>,这意味着我们碰到了个指针，就有…<br>str是个大小是10、指向…指针的数组(str is an array 10 of pointers to…)</li><li>继续，下一个是该行结尾<code>;</code>；继续，接下来是<code>char</code>，因此…<br>str是个大小是10、指向字符的指针的数组(str is an array 10 of pointers to char)</li></ul></blockquote><h2 id="2-指向函数的指针的声明"><a href="#2-指向函数的指针的声明" class="headerlink" title="2.指向函数的指针的声明"></a>2.指向函数的指针的声明</h2><pre><code>                 +--------------------+                 | +---+              |                 | |+-+|              |                 | |^ ||              |            char *(*fp)( int, float *);             ^   ^ ^  ||              |             |   | +--+|              |             |   +-----+              |             +------------------------+</code></pre><p>还是一样，首先要问：<code>fp</code>是什么？</p><blockquote><p>fp 是个…(fp is a…)</p><ul><li>顺时针移动，首先看到了<code>)</code>，因此<code>fp</code>就在括号中了，我们在括号中顺时针移动，下一个看到的是<code>*</code>，因此…<br>fp 是个指向…的指针(fp is a pointer to…)</li><li>跳出括号，继续顺时针转动，看到了<code>(</code>，这表明遇到了一个函数，就有…<br>fp 是个指向传入参数是int和指向float的指针、返回值是…的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning…)</li><li>继续顺时针，看到了<code>*</code>，说明…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向…的指针的函数的指针(fp is a pointer to a funciton passing an int and a pointer to float returning a pointer to…)</li><li>继续，遇到<code>;</code>；再继续，遇到了<code>char</code>，因此…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向char的指针的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char)</li></ul></blockquote><h2 id="3-终极形态"><a href="#3-终极形态" class="headerlink" title="3.终极形态"></a>3.终极形态</h2><pre><code>                  +-----------------------------+                  |                  +---+      |                  |  +---+           |+-+|      |                  |  ^   |           |^ ||      |            void (*signal(int, void (*fp)(int)))(int);             ^    ^      |      ^    ^  ||      |             |    +------+      |    +--+|      |             |                  +--------+      |             +----------------------------------+</code></pre><p>依然是:<code>signal</code>是什么?<br>注意<code>signal</code>在括号中，需要先解决它</p><ul><li>顺时针移动，首先遇到<code>(</code>，因此…<blockquote><p>signal是个传入参数为int和…,返回…的函数(signal is a function passing an int and a…)</p></blockquote></li><li>接着，我们可以对<code>fp</code>用相同的规则，<code>fp</code>是什么？<code>fp</code>在括号中，首先遇到的是<code>*</code>，于是…<blockquote><p>fp是个指向…的指针(fp is a pointer to…)</p></blockquote></li><li>继续会遇到<code>(</code>，就有…<blockquote><p>fp是个指向传入参数是int、返回…的函数的指针(fp is a pointer to a function passing int returning…)</p></blockquote></li><li>接着，看到了<code>void</code>…<blockquote><p>fp 是个指向传入参数是int、返回值为空(void)的函数的指针(fp is a pointer to a function passing int returning nothing (void))</p></blockquote></li><li>现在结束了对<code>fp</code>的解析，接着看<code>signal</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为…的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning…)</p></blockquote></li><li>现在还在括号内，接着的元素是<code>*</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为指向…的指针的函数(signal is a function passing an int and a pointer to a funciton passing an int returning nothing(void) returning a pointer to…)</p></blockquote></li><li>再继续，碰到了<code>(</code>…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为…的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning…)</p></blockquote></li><li>终于到最后了，我们只剩下<code>void</code>这一个元素了，最终<code>signale</code>的定义为…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为空的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning nothing(void))</p></blockquote></li></ul><h2 id="const和volatile的例子"><a href="#const和volatile的例子" class="headerlink" title="const和volatile的例子"></a><code>const</code>和<code>volatile</code>的例子</h2><p>规则一样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *chptr:</span><br></pre></td></tr></table></figure></p><p><code>chptr</code>是个指向一个char常量(constant)的指针(chptr is a pointer to a char constant)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向char的常量指针(chptr is a constant pointer to char)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向一个char原子(volatile)的常量指针(chptr is a constant pointer to a char volatile)</p><hr><p>C的复杂声明其实就不断加定语，但是这个定语在修饰的是哪个主语，需要按照顺时针/螺旋规则来解释。熟悉了就好。</p><hr><p>原文: <a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The ``Clockwise/Spiral Rule’’</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The “Clockwise/Spiral Rule”&lt;br&gt;By David Anderson&lt;/p&gt;
&lt;p&gt;每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="tr" scheme="http://suntus.github.io/tags/tr/"/>
    
  </entry>
  
  <entry>
    <title>软件的12个要素</title>
    <link href="http://suntus.github.io/2017/12/08/%E8%BD%AF%E4%BB%B6%E7%9A%8412%E4%B8%AA%E8%A6%81%E7%B4%A0/"/>
    <id>http://suntus.github.io/2017/12/08/软件的12个要素/</id>
    <published>2017-12-08T09:37:57.000Z</published>
    <updated>2017-12-14T07:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>由Heroku创始人Adam Wiggins在2012年发布。</li><li>是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。</li><li>使用于任意语言和后端服务开发的应用程序。</li><li>最佳阅读人员：服务器开发和运维人员。</li><li>中心思想是隔离。</li></ul><a id="more"></a><h2 id="1-基准代码"><a href="#1-基准代码" class="headerlink" title="1.基准代码"></a>1.基准代码</h2><p>1个模块只有1份基准代码，多个模块组成的是一个分布式系统。基准代码应该用版本管理工具加以控制，每个基准代码应该独占1个库，同属1个系统的多个基准代码库可以加入组。</p><h2 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2.依赖"></a>2.依赖</h2><ul><li>显示声明依赖。</li><li>通过依赖隔离工具来确保程序不会调用系统种存在但清单中未声明的依赖项。这种做法应该统一应用到开发和生产环境。</li></ul><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><ul><li>与代码分离。</li><li>推荐保存到环境变量。</li></ul><h2 id="4-后端服务"><a href="#4-后端服务" class="headerlink" title="4.后端服务"></a>4.后端服务</h2><ul><li>把后端服务当做附加资源。如数据库，MQ,SMTP，缓存等。</li><li>应该保证应用在不改动任何代码的情况下，将本地mysql换成第三方服务(如Amazon RDS)</li></ul><h2 id="5-构建，发布，运行"><a href="#5-构建，发布，运行" class="headerlink" title="5.构建，发布，运行"></a>5.构建，发布，运行</h2><p>严格分离构建和运行<br>基准代码转换成一份部署需要三个阶段：<br>1）构建阶段：将代码转化成可执行包的过程。构建时会使用指定版本的代码，获取和打包依赖项，编译成二进制文件和资源文件<br>2）发布阶段：将构建结果和当前部署所需配置相结合，并能够立即在运行环境中投入使用<br>3）运行阶段：只针对选定的发布版本，在执行环境中启动一系列运行程序进程</p><h2 id="6-进程"><a href="#6-进程" class="headerlink" title="6.进程"></a>6.进程</h2><ul><li>系统可以有1个或多个进程，进程必须无状态且无共享，任何需要持久化的数据都存储在后端服务中（比如数据库）。</li><li>内存和磁盘可以作为进程在进行某种事务型操作时的缓存（比如下载一个很大的文件）。不考虑这些缓存的内容是不是可以保留给之后的请求使用。</li><li>如果需要在内存中保存数据，优先考虑使用redis等内存数据库。</li></ul><h2 id="7-端口绑定"><a href="#7-端口绑定" class="headerlink" title="7.端口绑定"></a>7.端口绑定</h2><ul><li>使用端口提供服务。</li></ul><h2 id="8-并发"><a href="#8-并发" class="headerlink" title="8.并发"></a>8.并发</h2><ul><li>应该更多考虑水平扩展的可能。</li><li>不需要自己设置守护进程，而应交给其他进程托管系统。</li></ul><h2 id="9-易处理"><a href="#9-易处理" class="headerlink" title="9.易处理"></a>9.易处理</h2><ul><li>可以瞬间开启或停止，有利于快速、弹性的伸缩应用</li><li>进程接收到终止信号会优雅的终止。对网络进程，优雅就是停止监听服务的端口，拒绝信的请求，并执行当前已接收到的请求，然后退出。对worker进程，优雅终止就是当前任务退出队列。任务都应该可重复，使重复操作幂等实现。</li><li>应该可以处理 意外的、不优雅的终止。</li></ul><h2 id="10-开发环境与线上环境等价"><a href="#10-开发环境与线上环境等价" class="headerlink" title="10.开发环境与线上环境等价"></a>10.开发环境与线上环境等价</h2><p>尽可能保持开发、预发布、线上环境相同<br>开发环境和线上环境的差异有：</p><ol><li>时间差异：开发的代码可能几天，几周才会上线</li><li>人员差异：开发人员编写代码，运维人员部署代码</li><li>工具差异： 开发人员或许使用nginx，sqlite， osx，线上环境使用apache，mysql，linux</li></ol><h2 id="11-日志"><a href="#11-日志" class="headerlink" title="11.日志"></a>11.日志</h2><p>把日志当做事件流。<br>日志使应用程序运行的动作变得透明。服务器环境中，日志通常被写在文件中，但这只是一种输出格式。<br>日志应该是事件流的汇总，将所有运行中进程和后端服务的数据流按照时间顺序收集起来。<br>应用本身不应考虑存储自己的数据流，不应该试图去写或管理日志文件，都应该直接输出的标准输出（stdout）。最后汇总到统一的日志处理系统中。</p><h2 id="12-管理进程"><a href="#12-管理进程" class="headerlink" title="12.管理进程"></a>12.管理进程</h2><p>后台管理任务当做一次性进程运行。</p><hr><p>参考：<br><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">The Twelve-Factor App</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;由Heroku创始人Adam Wiggins在2012年发布。&lt;/li&gt;
&lt;li&gt;是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。&lt;/li&gt;
&lt;li&gt;使用于任意语言和后端服务开发的应用程序。&lt;/li&gt;
&lt;li&gt;最佳阅读人员：服务器开发和运维人员。&lt;/li&gt;
&lt;li&gt;中心思想是隔离。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ongoing" scheme="http://suntus.github.io/tags/ongoing/"/>
    
  </entry>
  
  <entry>
    <title>用到的docker</title>
    <link href="http://suntus.github.io/2017/12/08/%E7%94%A8%E5%88%B0%E7%9A%84docker/"/>
    <id>http://suntus.github.io/2017/12/08/用到的docker/</id>
    <published>2017-12-08T00:34:42.000Z</published>
    <updated>2017-12-09T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>都是在ubuntu系统中<br><a id="more"></a></p><h2 id="1-修改container时区"><a href="#1-修改container时区" class="headerlink" title="1.修改container时区"></a>1.修改container时区</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加shell命令</span><br><span class="line">echo <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone </span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span>同步主机时区</span><br><span class="line">启动时挂载`/etc/localtime`文件</span><br></pre></td></tr></table></figure><p>docker run -it -v /etc/localtime:/etc/localtime <img><br>```</p><hr><p>参考</p><ol><li><a href="https://brickyang.github.io/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/" target="_blank" rel="noopener">时区</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是在ubuntu系统中&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>docker search时列出tag</title>
    <link href="http://suntus.github.io/2017/12/07/docker%20search%E6%97%B6%E5%88%97%E5%87%BAtag/"/>
    <id>http://suntus.github.io/2017/12/07/docker search时列出tag/</id>
    <published>2017-12-07T02:24:23.000Z</published>
    <updated>2017-12-12T02:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用这个脚本docker-show-repo-tag.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple script that will display docker repository tags.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#   $ docker-show-repo-tags.sh ubuntu centos</span></span><br><span class="line"><span class="keyword">for</span> Repo <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">  curl -s -S <span class="string">"https://registry.hub.docker.com/v2/repositories/library/<span class="variable">$Repo</span>/tags/"</span> | \</span><br><span class="line">    sed -e <span class="string">'s/,/,\n/g'</span> -e <span class="string">'s/\[/\[\n/g'</span> | \</span><br><span class="line">    grep <span class="string">'"name"'</span> | \</span><br><span class="line">    awk -F\<span class="string">" '&#123;print <span class="variable">$4</span>;&#125;' | \</span></span><br><span class="line"><span class="string">    sort -fu | \</span></span><br><span class="line"><span class="string">    sed -e "</span>s/^/<span class="variable">$&#123;Repo&#125;</span>:/<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这样用:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./docker-show-repo-tags.sh ubuntu centos</span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">14.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">16.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">17.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span>latest</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty<span class="number">-20171117</span></span><br><span class="line"><span class="symbol">ubuntu:</span>xenial</span><br><span class="line"><span class="symbol">ubuntu:</span>xenial<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">ubuntu:</span>zesty</span><br><span class="line"><span class="symbol">ubuntu:</span>zesty<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.7</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.8</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">7</span></span><br><span class="line"><span class="symbol">centos:</span>centos6</span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.6</span></span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.7</span></span><br><span class="line"><span class="symbol">centos:</span>centos7</span><br><span class="line"><span class="symbol">centos:</span>latest</span><br></pre></td></tr></table></figure></p><hr><p>参考：<a href="https://stackoverflow.com/a/34054903/2955061" target="_blank" rel="noopener">https://stackoverflow.com/a/34054903/2955061</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用这个脚本docker-show-repo-tag.sh&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Simple script that will display docker repository tags.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Usage:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#   $ docker-show-repo-tags.sh ubuntu centos&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; Repo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; $* ; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  curl -s -S &lt;span class=&quot;string&quot;&gt;&quot;https://registry.hub.docker.com/v2/repositories/library/&lt;span class=&quot;variable&quot;&gt;$Repo&lt;/span&gt;/tags/&quot;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sed -e &lt;span class=&quot;string&quot;&gt;&#39;s/,/,\n/g&#39;&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&#39;s/\[/\[\n/g&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grep &lt;span class=&quot;string&quot;&gt;&#39;&quot;name&quot;&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    awk -F\&lt;span class=&quot;string&quot;&gt;&quot; &#39;&amp;#123;print &lt;span class=&quot;variable&quot;&gt;$4&lt;/span&gt;;&amp;#125;&#39; | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sort -fu | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sed -e &quot;&lt;/span&gt;s/^/&lt;span class=&quot;variable&quot;&gt;$&amp;#123;Repo&amp;#125;&lt;/span&gt;:/&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker精简镜像体积</title>
    <link href="http://suntus.github.io/2017/12/07/docker%E7%B2%BE%E7%AE%80%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"/>
    <id>http://suntus.github.io/2017/12/07/docker精简镜像体积/</id>
    <published>2017-12-07T01:58:20.000Z</published>
    <updated>2017-12-12T02:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。</li><li>找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。<a id="more"></a></li><li>ubuntu安装软件的时候，区分 build时依赖和runtime时依赖，build的依赖（比如gcc,g++,cmake,make等等）可以在最后删除，runtime的当然就不能删除啦。</li><li>安装时使用<code>--no-install-recommands</code>选项，也就是<code>apt-get install -y --no-install-recommands  cmake3</code>，不安装apt-get推荐的依赖，只相信我们自己 : )</li><li>删除的时候用这个: <code>apt-get purge -y --auto-remove $buildDeps</code>，删的更干净。</li><li>删除apt-get安装时候的一些日志： <code>rm /var/log/dpkg.log /var/log/alternatives.log /var/log/apt/*.log</code>。</li><li>记得把安装时候不需要的源码删掉，能少一点儿是一点儿。</li></ol><hr><p>参考</p><ol><li><a href="http://blog.fleeto.us/translation/refactoring-dockerfile-image-size" target="_blank" rel="noopener">优化 Dockerfile，缩减镜像尺寸</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。&lt;/li&gt;
&lt;li&gt;找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>librdkafka相关</title>
    <link href="http://suntus.github.io/2017/12/04/librdkafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2017/12/04/librdkafka相关/</id>
    <published>2017-12-04T07:59:13.000Z</published>
    <updated>2017-12-13T07:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-offset管理"><a href="#1-offset管理" class="headerlink" title="1.offset管理"></a>1.offset管理</h2><p>kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个<code>__consumer_offsets</code>的topic中。<br>zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。<br><a id="more"></a><br>librdkafka支持两种offset管理方式：</p><ol><li>存放到本地文件</li><li>存放到集群中</li></ol><p>librdkafka consumer的high level API支持存放到broker中，low level API支持存放到本地文件</p><p><strong>存放到集群</strong><br>影响的配置有这么几个：</p><ul><li>group.id: 设置consumer组，因为offset是按组来管理的，所以必须有这个东西</li><li>enable.auto.commit: 设置是否自动保存，[true, false]</li><li>auto.commit.interval.ms: 自动保存的的时间，默认是5000(5s)</li></ul><p>下面是一段示例代码<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conf = rd_kafk<span class="built_in">a_conf</span>_new()<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"group.id"</span>,<span class="string">"hehe"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"enable.auto.commit"</span>,<span class="string">"true"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"auto.commit.interval.ms"</span>,<span class="string">"1000"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rk = rd_kafk<span class="built_in">a_new</span>(RD_KAFK<span class="built_in">A_CONSUMER</span>, conf, errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 创建个topic_partition list</span><br><span class="line">rtkp_list = rd_kafk<span class="built_in">a_topic</span>_partition_list_new(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"># 将名字为topic_test的topic添加到rtkp_list中，并将offset设置为RD_KAFK<span class="built_in">A_OFFSET</span>_STORED，也就是consumer上次存储在broker中的offset。rd_kafk<span class="built_in">a_topic</span>_partition_list_add()返回的是<span class="number">1</span>个rd_kafk<span class="built_in">a_topic</span>_partition_t。</span><br><span class="line">rd_kafk<span class="built_in">a_topic</span>_partition_list_add(rtkp_list,<span class="string">"topic_test"</span>,<span class="number">0</span>)-&gt;offset = RD_KAFK<span class="built_in">A_OFFSET</span>_STORED<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 这里是确定订阅哪个topic了</span><br><span class="line">rd_kafk<span class="built_in">a_assign</span>(rk, rtkp_list)<span class="comment">;</span></span><br><span class="line">while(<span class="number">1</span>)&#123;</span><br><span class="line">    msg  = rd_kafk<span class="built_in">a_consumer</span>_poll(rk, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用这个去查看存储的offset到哪儿了<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-consumer-offset-checker.sh --zookeeper localhost:2181 --topic topic_test  --group hehe</span><br><span class="line"></span><br><span class="line">Group           Topic                          Pid Offset          logSize         Lag             Owner</span><br><span class="line">hehe            topic_test                    0   6483667         1674985741      1668502074      none</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset就是当前存储的offset，logSize是当前最大的offset，lag是还没消费的msg个数</span></span><br></pre></td></tr></table></figure></p><p><strong>存放到本地</strong><br>诶，参考上边吧</p><h2 id="2-high-level-API多topic操作"><a href="#2-high-level-API多topic操作" class="headerlink" title="2.high level API多topic操作"></a>2.high level API多topic操作</h2><p>有时候需要在一个进程中订阅多个topic，并且每个topic需要单独操作，这时候就可以多申请几个<code>rd_kafka_topic_partition_list_t</code>，分别在每个<code>rd_kafka_topic_partition_list_t</code>中加入各自的topic，在订阅消息的时候，使用<code>rd_kafka_assign(rk, rktp_list);</code>来切换各个topic。就可以了。</p><h2 id="3-high-level-API手动存储consumer的offset"><a href="#3-high-level-API手动存储consumer的offset" class="headerlink" title="3.high level API手动存储consumer的offset"></a>3.high level API手动存储consumer的offset</h2><p>先设置这几个参数<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rk_conf的配置</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.offset.store = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 一般还会设置这个配置，指示在broker没有存储offset(最开始时候)或offset出现错误的时候，系统应该初始化的offset位置，默认是latest</span></span><br><span class="line"><span class="literal">auto</span>.offset.reset = [earliest, latest, <span class="literal">none</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始时候topic_conf的几个配置会让人迷惑，auto.commit.enable 只针对 low level API, high level API需要使用rk_conf的全局配置，enable.autom.commit是auto.commit.enable的别名</span></span><br><span class="line"><span class="literal">auto</span>.commit.enable = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>操作的话，需要用到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个是实际将offset提交到broker的操作，async为false的时候，该操作阻塞。</span></span><br><span class="line"><span class="comment">// 两个的区别是，第一个可以控制提交的offset的具体值，第二个只能提交msg的offset，不能手动控制。</span></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_topic_partition_list_t</span> *offsets, <span class="keyword">int</span> async);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit_message(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_message_t</span> *rkmessage, <span class="keyword">int</span> async);</span><br></pre></td></tr></table></figure></p><p>另外，还有个跟offset相关的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_offset_store(<span class="keyword">rd_kafka_topic_t</span> *rkt,</span><br><span class="line">                                          <span class="keyword">int32_t</span> partition, <span class="keyword">int64_t</span> offset);</span><br></pre></td></tr></table></figure></p><p>这个函数只是把offset提交到内存，并不是提交到broker存储起来，所以还是需要调用*commit()函数</p><p><strong>注意：如果多topic切换的时候，需要先commit，再切换，否则切换回来还是会从原先的offset开始读取消息。</strong></p><hr><p>参考:</p><ol><li><a href="http://www.cnblogs.com/smartloli/p/6266453.html" target="_blank" rel="noopener">kafka的offset管理</a></li><li><a href="https://github.com/edenhill/librdkafka/wiki/Consumer-offset-management" target="_blank" rel="noopener">librdkafka的一些说明</a></li><li><a href="https://github.com/arnaud-lb/php-rdkafka/issues/87" target="_blank" rel="noopener">关于high level API手动管理offset的讨论</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-offset管理&quot;&gt;&lt;a href=&quot;#1-offset管理&quot; class=&quot;headerlink&quot; title=&quot;1.offset管理&quot;&gt;&lt;/a&gt;1.offset管理&lt;/h2&gt;&lt;p&gt;kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个&lt;code&gt;__consumer_offsets&lt;/code&gt;的topic中。&lt;br&gt;zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="kafka" scheme="http://suntus.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>iniparser-C 配置解析</title>
    <link href="http://suntus.github.io/2017/11/24/iniparser-C%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://suntus.github.io/2017/11/24/iniparser-C配置解析/</id>
    <published>2017-11-24T02:08:59.000Z</published>
    <updated>2017-11-24T03:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ndevilla/iniparser" target="_blank" rel="noopener">https://github.com/ndevilla/iniparser</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>相当小，4个文件(2个c，2个h)，1500行左右</li><li>不依赖其他库</li><li>可重入，需要自己加锁实现线程安全</li></ul><p>另外，使用也相当简单<br><a id="more"></a></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先准备ini格式的配置文件<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[kafka]</span></span><br><span class="line"><span class="attr">broker</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9092</span></span><br><span class="line"><span class="attr">topic</span> = hello</span><br><span class="line"></span><br><span class="line"><span class="section">[db]</span></span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br></pre></td></tr></table></figure></p><p>解析<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">direcotyr *d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = iniparser_load(<span class="string">"haha.conf"</span>);</span><br><span class="line">iniparser_dump(d,<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// broker</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:broker"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"broker: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// topic</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:topic"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"topic: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.host</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"db:host"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.host: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.port</span></span><br><span class="line">n = iniparser_getint(d, <span class="string">"db:port"</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.port: %d\n"</span>, n);</span><br><span class="line"></span><br><span class="line">iniparser_freedict(d);</span><br></pre></td></tr></table></figure></p><p>主要的API<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取section个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getnsec</span><span class="params">(<span class="keyword">const</span> dictionary * d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第n个section的个数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getsecname</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出配置到文件，可重新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dumpsection_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * s, FILE * f)</span></span>;</span><br><span class="line"><span class="comment">// 导出配置到文件，方便查看，不可从新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getstring</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">const</span> <span class="keyword">char</span> * def)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">iniparser_getlongint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">long</span> <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">iniparser_getdouble</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">double</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getboolean</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置配置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_set</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry, <span class="keyword">const</span> <span class="keyword">char</span> * val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_unset</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_find_entry</span><span class="params">(<span class="keyword">const</span> dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入，清理</span></span><br><span class="line"><span class="function">dictionary * <span class="title">iniparser_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * ininame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_freedict</span><span class="params">(dictionary * d)</span></span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ndevilla/iniparser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ndevilla/iniparser&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相当小，4个文件(2个c，2个h)，1500行左右&lt;/li&gt;
&lt;li&gt;不依赖其他库&lt;/li&gt;
&lt;li&gt;可重入，需要自己加锁实现线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，使用也相当简单&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数组的二分算法模块--bisect</title>
    <link href="http://suntus.github.io/2017/11/03/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9D%97-bisect/"/>
    <id>http://suntus.github.io/2017/11/03/数组的二分算法模块-bisect/</id>
    <published>2017-11-03T06:09:06.000Z</published>
    <updated>2017-11-03T06:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两点作用："><a href="#1-两点作用：" class="headerlink" title="1.两点作用："></a>1.两点作用：</h2><p>1.插入时就维护好一个排好序的数组<br>2.数组非常大的时候速度较快</p><a id="more"></a><p>用着也很简单，只有2个操作：查找、插入，每个操作各有2个方法，分别是</p><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left(a, x, <span class="attribute">lo</span>=0, <span class="attribute">hi</span>=len(a))</span><br></pre></td></tr></table></figure><p>返回一个数组a的下标i，a[lo… i-1] &lt; x &lt;= a[i…hi]。也就是说在i左边的元素都比x小，在i及i右边的元素，都等于或大于x.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect</span>()</span><br></pre></td></tr></table></figure></p><p>这两个是一样的。<br>返回一个数组a的下标i，a[lo… i-1] &lt;= x &lt;a[i…hi]。也就是说在i左边的元素小于等于x，在i及i右边的元素，都大于x</p><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_left</span>()</span><br></pre></td></tr></table></figure><p>插入的效果跟查找是一样的，不过就是查找然后插入:list.insert(bisect.bisect_left())<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort</span>()</span><br></pre></td></tr></table></figure></p><p>上边四个操作可以用下图帮助理解:<br><img src="/img/python/bisect.png" title="bisect操作"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-两点作用：&quot;&gt;&lt;a href=&quot;#1-两点作用：&quot; class=&quot;headerlink&quot; title=&quot;1.两点作用：&quot;&gt;&lt;/a&gt;1.两点作用：&lt;/h2&gt;&lt;p&gt;1.插入时就维护好一个排好序的数组&lt;br&gt;2.数组非常大的时候速度较快&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python配置解析--ConfigParser</title>
    <link href="http://suntus.github.io/2017/11/02/python%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90-ConfigParser/"/>
    <id>http://suntus.github.io/2017/11/02/python配置解析-ConfigParser/</id>
    <published>2017-11-02T06:32:33.000Z</published>
    <updated>2017-11-02T06:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>配置文件的格式<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">bind</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">log</span> = /var/log/haha.log</span><br><span class="line"><span class="attr">workers</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">connect</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9090</span></span><br><span class="line"><span class="attr">log</span> = /var/log/hehe.log</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用的话就相当简单了<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> = ConfigParser.ConfigParser()</span><br><span class="line"><span class="keyword">cp</span>.<span class="keyword">read</span>(<span class="string">"etc/app.conf"</span>)</span><br><span class="line">server.bind = <span class="keyword">cp</span>.<span class="built_in">get</span>(<span class="string">"server"</span>, <span class="string">"bind"</span>)</span><br><span class="line">server.workers = <span class="keyword">cp</span>.getint(<span class="string">"server"</span>,<span class="string">"workers"</span>)</span><br><span class="line"># 另外还有</span><br><span class="line"># <span class="keyword">cp</span>.getboolean()</span><br><span class="line"># <span class="keyword">cp</span>.getfloat()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置文件的格式&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[server]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;bind&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/haha.log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;workers&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[client]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;connect&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9090&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/hehe.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python连接mysql</title>
    <link href="http://suntus.github.io/2017/11/02/python%E8%BF%9E%E6%8E%A5mysql/"/>
    <id>http://suntus.github.io/2017/11/02/python连接mysql/</id>
    <published>2017-11-02T05:57:29.000Z</published>
    <updated>2017-11-02T06:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装MySQLdb<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> mysql-python</span><br></pre></td></tr></table></figure></p><p>创建连接<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_conn(**dbconfig):</span><br><span class="line">    conn = MySQLdb.<span class="built_in">connect</span>(**dbconfig)</span><br><span class="line">    <span class="built_in">cursor</span> = conn.<span class="built_in">cursor</span>()</span><br><span class="line">    <span class="built_in">return</span> conn, <span class="built_in">cursor</span></span><br><span class="line"></span><br><span class="line">conn, <span class="built_in">cursor</span> = db_get_conn(host=<span class="string">"127.0.0.1"</span>, user=<span class="string">"root"</span>,passwd=“<span class="number">123</span><span class="string">", db=“db_haha"</span>,charset=<span class="string">"utf8"</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建查询<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.<span class="keyword">execute</span>(<span class="string">"select a,b from t_hehe"</span>)</span><br></pre></td></tr></table></figure></p><p>获取结果<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">a</span>, b <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">        print <span class="keyword">a</span>,b</span><br><span class="line"></span><br><span class="line">// 注意：如果只有<span class="number">1</span>个元素，这样才行</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">a</span>,) <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">    print <span class="keyword">a</span></span><br></pre></td></tr></table></figure></p><p>如果结果太大，不想全部拉回来，而是创建好查询，现在服务器端查好结果，再一条条拉回来，要这样创建连接<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_ss_conn(*<span class="number">*dbc</span>onfig):</span><br><span class="line">    ss_conn = MySQLdb.connect(*<span class="number">*dbc</span>onfig)</span><br><span class="line">    ss_cursor = conn.cursor(<span class="attribute">cursorclass</span>=MySQLdb.cursors.SSCursor)</span><br><span class="line">    return ss_conn, ss_cursor</span><br><span class="line"></span><br><span class="line">ss_conn, ss_cursor = db_get_conn(<span class="attribute">host</span>=<span class="string">"127.0.0.1"</span>, <span class="attribute">user</span>=<span class="string">"root"</span>,passwd=“123", <span class="attribute">db</span>=“db_haha",charset="utf8")</span><br></pre></td></tr></table></figure></p><p>然后这样获取结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss_cursor.execute(<span class="string">"select a,b from t_hehe"</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span> <span class="keyword">in</span> ss_cursor:</span><br><span class="line">    print <span class="selector-tag">a</span>, b</span><br></pre></td></tr></table></figure></p><p>最后修改的话，记得提交事务<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">conn</span><span class="selector-class">.commit</span>()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装MySQLdb&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; mysql-python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建连接&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def db_get_conn(**dbconfig):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn = MySQLdb.&lt;span class=&quot;built_in&quot;&gt;connect&lt;/span&gt;(**dbconfig)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = conn.&lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = db_get_conn(host=&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, user=&lt;span class=&quot;string&quot;&gt;&quot;root&quot;&lt;/span&gt;,passwd=“&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;, db=“db_haha&quot;&lt;/span&gt;,charset=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>nginx图集</title>
    <link href="http://suntus.github.io/2017/10/20/nginx%E5%9B%BE%E9%9B%86/"/>
    <id>http://suntus.github.io/2017/10/20/nginx图集/</id>
    <published>2017-10-20T09:02:33.000Z</published>
    <updated>2017-10-30T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx的代码组织相当简洁明了。<br><a id="more"></a><br><img src="/img/nginx/ngx_src_1.png" title="模块的组织"></p><p><img src="/img/nginx/ngx_src_2.png" title="头文件的组织,可以帮助理解整体结构"></p><p>原来是想写一下nginx的启动流程的，但发现把这个图做出来，就没什么好说的了，即使写出来也都是大白话，还不如仔细看看这个图。<br><img src="/img/nginx/ngx_src_3.png" title="nginx主体框架启动流程"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx的代码组织相当简洁明了。&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://suntus.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>命令_nc</title>
    <link href="http://suntus.github.io/2017/09/22/%E5%91%BD%E4%BB%A4-nc/"/>
    <id>http://suntus.github.io/2017/09/22/命令-nc/</id>
    <published>2017-09-22T08:19:37.000Z</published>
    <updated>2017-09-22T08:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>netcat——瑞士军刀</p><h1 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h1><ol><li>TCP服务端客户端</li><li>网络测试</li><li>ssh的SOCKS或HTTP代理</li><li>简单的端口扫描<br>…<a id="more"></a></li></ol><h1 id="2-一些命令"><a href="#2-一些命令" class="headerlink" title="2. 一些命令"></a>2. 一些命令</h1><ul><li>-4：只使用IPv4地址</li><li>-6：只是用IPv6地址</li><li>-b：允许广播</li><li>-C：使用CRLF作为行的结尾</li><li>-D：启动debug</li><li>-d：不从标准输入中读取</li><li>-I length：设置TCP接收缓冲区大小</li><li>-i interval：在发送和接收数据包之间设置时间间隔，也在连接到多个端口的时候设置时间间隔</li><li>-k: 强制nc在连接到1个端口之后监听等待1个连接到来。跟-l配合使用</li><li>-l: 监听模式</li><li>-n：不在任何地址、主机名、端口上做DNS（直接是数字形式的）</li><li>-O length: 设置TCP发送缓冲区大小</li><li>-P proxy_username: 连接到proxy的时候提供用户名来验证</li><li>-p source_port：设置源端口</li><li>-q seconds: 在标准输入发送EOF后，等待这些秒，如果是负数，就一直等下去</li><li>-r: 让源/目的端口随机，不让在一个范围内分配</li><li>-S：开启RFC 2385 TCP MD5 signature option</li><li>-s source: 设置源地址，如果是unix domain socket，就指定文件</li><li>-T toskeyword：改变IPv4的TOS字段</li><li>-U：使用unix domain socket</li><li>-u：使用udp，而不是默认的TCP。不用-s指定的话，会在/tmp目录下新建临时文件</li><li>-V rtable: 设置使用的路由表</li><li>-v: verbose输出</li><li>-w timeout: 向外连接的时候设置超时时间</li><li>-X proxy_protocol: 设置代理协议，4” (SOCKS v.4), “5” (SOCKS v.5) and “connect”(HTTPS proxy)。默认是5</li><li>-x proxy_address[:port]：设置连接的代理地址</li><li>-Z:DCCP模式</li><li>-z: 只是扫描一下监听端口，而不发送任何数据。</li></ul><h1 id="3-简单的用法"><a href="#3-简单的用法" class="headerlink" title="3. 简单的用法"></a>3. 简单的用法</h1><h2 id="1-设置TCP服务端和客户端"><a href="#1-设置TCP服务端和客户端" class="headerlink" title="1. 设置TCP服务端和客户端"></a>1. 设置TCP服务端和客户端</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line"># rm -f /tmp/f; mkfifo /tmp/f</span><br><span class="line"># cat /tmp/f | /bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span> | nc -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1234</span> &gt; /tmp/f</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line">$ nc host.example.com <span class="number">1234</span></span><br><span class="line">$ (shell prompt from host.example.com)</span><br></pre></td></tr></table></figure><h2 id="2-文件传输"><a href="#2-文件传输" class="headerlink" title="2. 文件传输"></a>2. 文件传输</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一端</span><br><span class="line">$ nc -l <span class="number">1234</span> &gt; filename.out</span><br><span class="line"></span><br><span class="line">另一端：</span><br><span class="line">$ nc host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">1234</span> &lt; filename.<span class="keyword">in</span></span><br></pre></td></tr></table></figure><h2 id="3-连接服务器"><a href="#3-连接服务器" class="headerlink" title="3. 连接服务器"></a>3. 连接服务器</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nc [-C] localhost <span class="number">25</span> &lt;&lt; EOF</span><br><span class="line">HELO host<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br><span class="line">MAIL FROM:&lt;user@host<span class="selector-class">.example</span><span class="selector-class">.com</span>&gt;</span><br><span class="line">RCPT TO:&lt;user2@host<span class="selector-class">.example</span><span class="selector-class">.com</span>&gt;</span><br><span class="line">DATA</span><br><span class="line">Body of email.</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="4-端口扫描"><a href="#4-端口扫描" class="headerlink" title="4. 端口扫描"></a>4. 端口扫描</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -zv host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">20</span>-<span class="number">30</span></span><br><span class="line">$ nc -zv host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">80</span> <span class="number">20</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><hr><p>参考:</p><ol><li>man nc</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netcat——瑞士军刀&lt;/p&gt;
&lt;h1 id=&quot;1-功能&quot;&gt;&lt;a href=&quot;#1-功能&quot; class=&quot;headerlink&quot; title=&quot;1. 功能&quot;&gt;&lt;/a&gt;1. 功能&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;TCP服务端客户端&lt;/li&gt;
&lt;li&gt;网络测试&lt;/li&gt;
&lt;li&gt;ssh的SOCKS或HTTP代理&lt;/li&gt;
&lt;li&gt;简单的端口扫描&lt;br&gt;…
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
      <category term="cli" scheme="http://suntus.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>shell IO重定向</title>
    <link href="http://suntus.github.io/2017/09/22/shell%20IO%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://suntus.github.io/2017/09/22/shell IO重定向/</id>
    <published>2017-09-22T03:49:02.000Z</published>
    <updated>2017-09-25T04:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>重定向没什么难理解的，只是有些命令会不熟悉，这里列出了一些常用的命令，以备后查。</p><p>标准输入：键盘，0<br>标准输出：屏幕，1<br>标准错误：屏幕，2<br><a id="more"></a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> 1&gt; <span class="selector-tag">haha</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将标准输出1重定向到文件haha.txt。注意1和&gt;之间没有空格。1可以省略，就成了常用的 ls &gt; haha.txt</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="number">1</span><span class="meta">&gt;&gt;</span>haha.txt</span><br></pre></td></tr></table></figure><p>1个&gt;是先清空haha.txt，再写入；两个&gt;是追加到haha.txt后边</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> <span class="selector-tag">-qw</span> 2&gt; <span class="selector-tag">haha</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将标准错误重定向到haha.txt</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="meta">&amp;&gt; haha.txt</span></span><br></pre></td></tr></table></figure><p>将标准输出、标准错误都重定向到haha.txt</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">i</span>&gt;&amp;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>将文件描述符i重定向到描述符j，也就是现在j也具有了i的能力，应用到i上的IO操作都可以应用到j上，效果一样。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#echo <span class="number">123456789</span> &gt;filename   把字符串写到文件filename中</span><br><span class="line">#exec <span class="number">3</span>&lt;&gt;filename           把文件filename打开，并指定文件标识符为<span class="number">3</span></span><br><span class="line">#read -n <span class="number">4</span> &lt;&amp;<span class="number">3</span>              从文件中读<span class="number">4</span>个字符，句柄已经指到第四个字符末尾</span><br><span class="line">#echo -n . &gt;&amp;<span class="number">3</span>              在第<span class="number">5</span>个字符处写一个点，覆盖第<span class="number">5</span>个字符，-n表示不换行</span><br><span class="line">#exec <span class="number">3</span>&gt;&amp;-                 关闭文件标识符<span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>3&lt;&gt;filename</code> 表示用描述符3打开filename<br><code>3&gt;&amp;-</code> 表示关闭输出描述符的文件</p><p><code>3&lt;&amp;-</code> 表示关闭输入描述符的文件</p><hr><p>参考</p><ol><li>IBM的资料：<a href="https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html</a></li><li>不知道这个跟上个是谁抄谁的一部分：<a href="http://manual.51yip.com/shell/io-redirection.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重定向没什么难理解的，只是有些命令会不熟悉，这里列出了一些常用的命令，以备后查。&lt;/p&gt;
&lt;p&gt;标准输入：键盘，0&lt;br&gt;标准输出：屏幕，1&lt;br&gt;标准错误：屏幕，2&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>命令_date</title>
    <link href="http://suntus.github.io/2017/09/20/%E5%91%BD%E4%BB%A4_date/"/>
    <id>http://suntus.github.io/2017/09/20/命令_date/</id>
    <published>2017-09-20T08:31:57.000Z</published>
    <updated>2017-09-22T08:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-显示和设置系统日期和时间"><a href="#1-显示和设置系统日期和时间" class="headerlink" title="1. 显示和设置系统日期和时间"></a>1. 显示和设置系统日期和时间</h2><p>date [OPTION]… [+FORMAT]<br>date [-u| —utc| -universal] [MMDDhhmm[[CC]UYY][.ss]]</p><h2 id="2-其实核心的只有1个功能："><a href="#2-其实核心的只有1个功能：" class="headerlink" title="2. 其实核心的只有1个功能："></a>2. 其实核心的只有1个功能：</h2><p><strong><em>输入特定格式的时间，转换成自己想要的时间格式</em></strong></p><a id="more"></a><h3 id="2-1-输入使用-d，后边跟描述时间的文字"><a href="#2-1-输入使用-d，后边跟描述时间的文字" class="headerlink" title="2.1 输入使用-d，后边跟描述时间的文字"></a>2.1 输入使用-d，后边跟描述时间的文字</h3><p>比如<br>“Sun, 29 Feb 2004 16:21:42 -0800”, “2004-02-29 16:21:42” , “next Thursday”, “-10day”, “+10min”等等，该描述性的文字由指示日历的日期，时间的天，时间的时区，天的星期，相对时间，相对日期和数字组成。空字符串表示这天的开始。</p><h3 id="2-2-输出使用-FORMAT，后边跟各种格式："><a href="#2-2-输出使用-FORMAT，后边跟各种格式：" class="headerlink" title="2.2 输出使用+FORMAT，后边跟各种格式："></a>2.2 输出使用+FORMAT，后边跟各种格式：</h3><p>%%: 符号%<br>%a: 本地星期缩写， Sun<br>%A: 本地星期全称， Sunday<br>%b: 本地月份缩写, Jan<br>%B: 本地月份全称, January<br>%c: 本地日期和时间, Thu Mar 3 23:-5:25 2005<br>%C: 世纪，类似%Y，DNA没有后两位, 20<br>%d: 月的第几天, 01<br>%D: 日期，%m/%d/%y<br>%e: 月的天数，用空格填充，类似%<em>d<br>%F: 完整的日期格式，类似%F-%m-%d<br>%g: ISO格式年的后两位<br>%G: ISO格式的年<br>%h: 跟%b一样<br>%H: 小时(00..23)<br>%I: 小时(01..12)<br>%j: 年的第几天(001..366)<br>%k: 小时，用空格填充(0..23); 类似%_H<br>%l: 小时，用空格填充(1..12) ； 类似%_I<br>%m: 月(01..12)<br>%M: 分钟(00..59)<br>%n: 换行<br>%N: 纳秒,nanoseconds(0000000000..999999999)<br>%p: 本地的AM或者PM<br>%P: 类似%p，但是是小写<br>%r：本地12小时制时钟时间  11:11:04 PM<br>%R: 24小时制的小时跟分钟，类似%H:%M<br>%s: 从1970-01-01 00:00:00 UTC开始的秒数，时间戳<br>%S: 秒(00..60)<br>%t: tab字符<br>%T: 时间，类似%H:%M:%S<br>%u: 星期的第几天(1..7),1是星期一<br>%U: 年的第几个星期(00..53)，周日是星期的开始<br>%V: ISO星期制，星期一是星期的开始（01..53）<br>%w: 星期的第几天(0..6)，0是星期天<br>%W: 年的第几个星期(00..53)，周一是星期的开始<br>%x:  本地日期表示(12/31/99)<br>%X: 本地时间表示(23:13:48)<br>%y: 年的后两位数字(00..99)<br>%Y: 年<br>另外还有几个符号，用于修饰<br>-  不填充</em> 用空格填充<br>0 用0填充<br>^ 用大写<br>#  用相反的大小写</p><h2 id="3-几个例子："><a href="#3-几个例子：" class="headerlink" title="3. 几个例子："></a>3. 几个例子：</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出今天开始时间</span></span><br><span class="line">date -d <span class="string">""</span></span><br><span class="line"><span class="comment"># 当前时间戳</span></span><br><span class="line">date +%s</span><br><span class="line"><span class="comment"># 输出好看的时间：2017-9-20 16:21:42</span></span><br><span class="line">date +<span class="string">"%F %T"</span></span><br><span class="line"><span class="comment"># 将时间戳转换成可读时间，对这里的时间戳前边要加@</span></span><br><span class="line">date -d @1505896166 +<span class="string">"%F %T"</span></span><br><span class="line"><span class="comment"># 输出10分钟前的时间戳</span></span><br><span class="line">date -d <span class="string">"-10min"</span> +%s</span><br></pre></td></tr></table></figure><p>至于设置系统时间，加个-s就行了。</p><hr><p>参考：</p><ol><li>man date</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-显示和设置系统日期和时间&quot;&gt;&lt;a href=&quot;#1-显示和设置系统日期和时间&quot; class=&quot;headerlink&quot; title=&quot;1. 显示和设置系统日期和时间&quot;&gt;&lt;/a&gt;1. 显示和设置系统日期和时间&lt;/h2&gt;&lt;p&gt;date [OPTION]… [+FORMAT]&lt;br&gt;date [-u| —utc| -universal] [MMDDhhmm[[CC]UYY][.ss]]&lt;/p&gt;
&lt;h2 id=&quot;2-其实核心的只有1个功能：&quot;&gt;&lt;a href=&quot;#2-其实核心的只有1个功能：&quot; class=&quot;headerlink&quot; title=&quot;2. 其实核心的只有1个功能：&quot;&gt;&lt;/a&gt;2. 其实核心的只有1个功能：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;输入特定格式的时间，转换成自己想要的时间格式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
      <category term="cli" scheme="http://suntus.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>用到的tmux</title>
    <link href="http://suntus.github.io/2017/09/19/%E7%94%A8%E5%88%B0%E7%9A%84tmux/"/>
    <id>http://suntus.github.io/2017/09/19/用到的tmux/</id>
    <published>2017-09-19T09:15:10.000Z</published>
    <updated>2019-05-09T11:41:33.895Z</updated>
    
    <content type="html"><![CDATA[<p>终端复用软件，跟screen一样，但是要强大的多。</p><h2 id="1-典型应用场景"><a href="#1-典型应用场景" class="headerlink" title="1. 典型应用场景"></a>1. 典型应用场景</h2><p>自己电脑是客户端，平常ssh到linux服务器上编译运行调试软件，网络断开或者自己电脑挂掉之后，不想服务器上运行的程序也挂掉，这时候就可以用tmux了。还有就是tmux能方便的多开好几个窗口。tmux的作用是代理终端，以前你直接通过ssh通道来操作服务器的终端，现在通过ssh通道启动了1个tmux程序，由tmux程序代替你控制多个终端，这样你就拥有了一组终端，所以是个服务器开发神器。这个神器差不多长这样：<br><img src="/img/tmux-1.png" alt="image.png"></p><a id="more"></a><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>跟vim差不多，也是要在服务器本用户主目录下边放一个配置文件<code>.tmux.conf</code>，直接用这个吧，有些东西自己想调整可以看着改：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># (‑●‑●)&gt; released under the WTFPL v2 license, by Gregory Pakosz (@gpakosz)</span></span><br><span class="line">unbind C-b</span><br><span class="line"><span class="keyword">set</span> -g prefix C-a</span><br><span class="line"></span><br><span class="line"><span class="meta">#up</span></span><br><span class="line">bind-key k select-pane -U</span><br><span class="line"><span class="meta">#down</span></span><br><span class="line">bind-key j select-pane -D</span><br><span class="line"><span class="meta">#left</span></span><br><span class="line">bind-key h select-pane -L</span><br><span class="line"><span class="meta">#right</span></span><br><span class="line">bind-key l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#select last window</span></span><br><span class="line">bind-key C-l select-window -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#copy-mode 将快捷键设置为vi 模式</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"><span class="meta"># use the powerline patched font variant of the theme, possible values are:</span></span><br><span class="line"><span class="meta"># - default</span></span><br><span class="line"><span class="meta"># - powerline</span></span><br><span class="line">tmux_conf_theme=<span class="keyword">default</span></span><br><span class="line"><span class="meta">#tmux_conf_theme=powerline</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display an indicator in the status line when the prefix key has been pressed,</span></span><br><span class="line"><span class="meta"># possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_prefix=disabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_prefix=enabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the battery information in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_battery=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_battery=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># style to use for the battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - bar</span></span><br><span class="line"><span class="meta"># - percentage</span></span><br><span class="line">tmux_conf_battery_style=bar</span><br><span class="line"><span class="meta">#tmux_conf_battery_style=percentage</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># symbols to use for battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - block</span></span><br><span class="line"><span class="meta"># - heart</span></span><br><span class="line">tmux_conf_battery_symbol=block</span><br><span class="line"><span class="meta">#tmux_conf_battery_symbol=heart</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># number of symbols to use for battery status</span></span><br><span class="line">tmux_conf_battery_symbol_count=auto</span><br><span class="line"><span class="meta">#tmux_conf_battery_symbol_count=5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># palette used for the battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - 'colour_full_fg,colour_empty_fg,colour_bg'</span></span><br><span class="line"><span class="meta"># - heat</span></span><br><span class="line"><span class="meta"># - gradient</span></span><br><span class="line">tmux_conf_battery_palette=<span class="string">'#d70000,#e4e4e4,#000000'</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=colour160,colour254,colour16</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=heat</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=gradient</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the battery status: charging (U+26A1) / discharging (U+1F50B)</span></span><br><span class="line">tmux_conf_battery_status=enabled</span><br><span class="line"><span class="meta">#tmux_conf_battery_status=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># or alternatively use an external tool, e.g. [https://github.com/Goles/Battery](https://github.com/Goles/Battery)</span></span><br><span class="line"><span class="meta">#tmux_conf_battery='#(battery -t) '</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the time in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_time=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_time=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the date in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_date=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_date=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the username in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line"><span class="meta"># - ssh</span></span><br><span class="line">tmux_conf_theme_username=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_username=disabled</span></span><br><span class="line"><span class="meta">#tmux_conf_theme_username=ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the hostname in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line"><span class="meta"># - ssh</span></span><br><span class="line">tmux_conf_theme_hostname=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_hostname=disabled</span></span><br><span class="line"><span class="meta">#tmux_conf_theme_hostname=ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># highlight focuse pane, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_highlight_focused_pane=disabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_highlight_focused_pane=enabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># should new windows retain current path, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_windows_retain_current_path=<span class="literal">false</span></span><br><span class="line"><span class="meta">#tmux_conf_new_windows_retain_current_path=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># should new panes reatin current path, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_panes_retain_current_path=<span class="literal">true</span></span><br><span class="line"><span class="meta">#tmux_conf_new_panes_retain_current_path=false</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># prompt for session name when creating a new session, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_session_prompt=<span class="literal">false</span></span><br><span class="line"><span class="meta">#tmux_conf_new_session_prompt=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># if you're running tmux within iTerm2</span></span><br><span class="line"><span class="meta"># - and tmux is 1.9 or 1.9a</span></span><br><span class="line"><span class="meta"># - and iTerm2 is configured to let option key act as +Esc</span></span><br><span class="line"><span class="meta"># - and iTerm2 is configured to send [1;9A -&gt; [1;9D for option + arrow keys</span></span><br><span class="line"><span class="meta"># then uncomment the following line to make Meta + arrow keys mapping work</span></span><br><span class="line"><span class="meta">#set -g terminal-overrides "*:kUP3=\e[1;9A,*:kDN3=\e[1;9B,*:kRIT3=\e[1;9C,*:kLFT3=\e[1;9D"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta"># this is the place to further customize tmux's configuration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#set -g history-limit 10000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-几个概念"><a href="#3-几个概念" class="headerlink" title="3. 几个概念"></a>3. 几个概念</h2><ol><li>session，会话</li><li>window，窗口</li><li>panel，面板</li></ol><p>关系是“1个会话会包含几个窗口，1个窗口会包含几个面板”<br>当然，1个ssh通道可以启动好几个会话，每个会话都可以detach和attach，从而一下子恢复一组工作空间。网络断开之后也会恢复哦，不过服务器重启就没办法了，毕竟tmux是跑在服务器上的软件。</p><h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h2><p><strong>4.1 在tmux之外的命令</strong><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 新建1个名叫hello的session</span></span><br><span class="line">tmux <span class="keyword">new</span> -s hello</span><br><span class="line"></span><br><span class="line"><span class="meta"># 列出当前有几个session</span></span><br><span class="line">tmux ls</span><br><span class="line"></span><br><span class="line"><span class="meta"># 挂接到名叫hello的session，恢复先前的工作空间</span></span><br><span class="line">tmux at -t hello</span><br></pre></td></tr></table></figure></p><p><strong>4.2 进入tmux后的命令</strong>。一般来说在tmux内部的常用命令都是组合键，先按下前缀键，再按下后边跟着的那个键。默认的前缀键是ctrl+b，上边的配置修改成了ctrl+a，因为a距离更近啊：）<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 退出当前panel；如果当前panel是该window的最后一个，就退出该window；如果该window是该session的最后1个，就退出该session。这个不带前缀键。</span></span><br><span class="line">ctrl+d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 安全退出当前session(detach)，这样你以后还能重新挂接(attach)上来恢复工作空间。</span></span><br><span class="line">ctrl+a, d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览并切换session</span></span><br><span class="line">ctrl+a, s</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览当前配置使用的快捷键列表，按q退出</span></span><br><span class="line">ctrl+a, ?</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建一个window</span></span><br><span class="line">ctrl+a, c</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在前后两个window之间跳转</span></span><br><span class="line">ctrl+a, ctrl+l</span><br><span class="line"></span><br><span class="line"><span class="meta"># 跳转到相应编号的window</span></span><br><span class="line">ctrl+a, <span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta"># 修改当前window的名称，默认都是个'bash'。是个逗号哈。</span></span><br><span class="line">ctrl+a, ,</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建垂直切分的panel</span></span><br><span class="line">ctrl+a, %</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建水平切分的panel</span></span><br><span class="line">ctrl+a, <span class="string">"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在panel之间切换啊，跟vim的方向一样，不过都需要加个前缀</span></span><br><span class="line"><span class="meta"># 向左</span></span><br><span class="line">ctrl+a, h</span><br><span class="line"><span class="meta"># 向右</span></span><br><span class="line">ctrl+a, l</span><br><span class="line"><span class="meta"># 向下</span></span><br><span class="line">ctrl+a, j</span><br><span class="line"><span class="meta"># 向上</span></span><br><span class="line">ctrl+a, k</span><br><span class="line"></span><br><span class="line"><span class="meta"># 暂时将当前panel占据整个window，再按一次就切换回去，在复制的时候很有用。</span></span><br><span class="line">ctrl+a, z</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览历史，进入后就可以按vim的进行操作了，常用的是j,k, ctrl+b(向上翻页)，ctrl+f(向下翻页)</span></span><br><span class="line">ctrl+a, [</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制关闭当前panel</span></span><br><span class="line">ctrl+a, x</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制关闭当前window</span></span><br><span class="line">ctrl+a, <span class="meta">&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 切换panel布局，比如横向分屏变竖向</span></span><br><span class="line">ctrl+a, space</span><br><span class="line"></span><br><span class="line"><span class="meta"># 旋转panel布局，比如左1右2，变为左2右1</span></span><br><span class="line">ctrl+a, ctlr+o</span><br><span class="line"></span><br><span class="line"><span class="meta"># 微调panel大小，这个试一下就知道了</span></span><br><span class="line">ctrl+a, ctrl+方向键</span><br></pre></td></tr></table></figure></p><p>好了，常用的就是这些了。</p><hr><p>参考：</p><ol><li><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终端复用软件，跟screen一样，但是要强大的多。&lt;/p&gt;
&lt;h2 id=&quot;1-典型应用场景&quot;&gt;&lt;a href=&quot;#1-典型应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. 典型应用场景&quot;&gt;&lt;/a&gt;1. 典型应用场景&lt;/h2&gt;&lt;p&gt;自己电脑是客户端，平常ssh到linux服务器上编译运行调试软件，网络断开或者自己电脑挂掉之后，不想服务器上运行的程序也挂掉，这时候就可以用tmux了。还有就是tmux能方便的多开好几个窗口。tmux的作用是代理终端，以前你直接通过ssh通道来操作服务器的终端，现在通过ssh通道启动了1个tmux程序，由tmux程序代替你控制多个终端，这样你就拥有了一组终端，所以是个服务器开发神器。这个神器差不多长这样：&lt;br&gt;&lt;img src=&quot;/img/tmux-1.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
</feed>
