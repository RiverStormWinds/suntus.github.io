<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morning~Sun。</title>
  
  <subtitle>ha</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suntus.github.io/"/>
  <updated>2017-12-20T01:26:54.000Z</updated>
  <id>http://suntus.github.io/</id>
  
  <author>
    <name>suntus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>顺时针规则--C语言声明</title>
    <link href="http://suntus.github.io/2017/12/19/%E9%A1%BA%E6%97%B6%E9%92%88%E8%A7%84%E5%88%99--C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/"/>
    <id>http://suntus.github.io/2017/12/19/顺时针规则--C语言声明/</id>
    <published>2017-12-19T05:44:49.000Z</published>
    <updated>2017-12-20T01:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>The “Clockwise/Spiral Rule”<br>By David Anderson</p><p>每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!<br><a id="more"></a><br>该规则只有简单的3步：</p><ol><li><p>从未知元素开始，沿顺时针/螺旋方向移动；当遇到如下元素的时候，用相应的自然语言陈述出来：</p><ul><li>[X] 或者 [] =&gt; 大小为…的数组X 或 未知大小数组的…(Array X size of… or Array undefined size of…)</li><li>(type1, type2) =&gt; 传入type1和type2参数、返回…的函数(function passing type1 and type2 returning…)</li><li>* =&gt; 指向…的指针(pointer(s) to…)</li></ul></li><li><p>一直沿着顺时针往下进行，直到覆盖了所有的元素。</p></li><li>括号内的永远优先!</li></ol><p>其实对英文来说就是不断在后边加定语，但对汉语来说，就需要不断在前边加定语。</p><h2 id="1-简单声明"><a href="#1-简单声明" class="headerlink" title="1.简单声明"></a>1.简单声明</h2><pre><code>     +-------+     | +-+   |     | ^ |   |char *str[10]; ^   ^   |   | |   +---+   | +-----------+</code></pre><p>首先需要问的是：<code>str</code>是什么？</p><blockquote><p>str 是个…(str is an…)</p><ul><li>我们从<code>str</code>开始顺时针移动，碰到的第一个元素是<code>[</code>，这意味着我们碰到了个数组，于是就有…<br>str是个大小是10、…的数组(str is an array 10 of…)</li><li>继续顺时针，下一个遇到的是<code>*</code>,这意味着我们碰到了个指针，就有…<br>str是个大小是10、指向…指针的数组(str is an array 10 of pointers to…)</li><li>继续，下一个是该行结尾<code>;</code>；继续，接下来是<code>char</code>，因此…<br>str是个大小是10、指向字符的指针的数组(str is an array 10 of pointers to char)</li></ul></blockquote><h2 id="2-指向函数的指针的声明"><a href="#2-指向函数的指针的声明" class="headerlink" title="2.指向函数的指针的声明"></a>2.指向函数的指针的声明</h2><pre><code>     +--------------------+     | +---+              |     | |+-+|              |     | |^ ||              |char *(*fp)( int, float *); ^   ^ ^  ||              | |   | +--+|              | |   +-----+              | +------------------------+</code></pre><p>还是一样，首先要问：<code>fp</code>是什么？</p><blockquote><p>fp 是个…(fp is a…)</p><ul><li>顺时针移动，首先看到了<code>)</code>，因此<code>fp</code>就在括号中了，我们在括号中顺时针移动，下一个看到的是<code>*</code>，因此…<br>fp 是个指向…的指针(fp is a pointer to…)</li><li>跳出括号，继续顺时针转动，看到了<code>(</code>，这表明遇到了一个函数，就有…<br>fp 是个指向传入参数是int和指向float的指针、返回值是…的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning…)</li><li>继续顺时针，看到了<code>*</code>，说明…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向…的指针的函数的指针(fp is a pointer to a funciton passing an int and a pointer to float returning a pointer to…)</li><li>继续，遇到<code>;</code>；再继续，遇到了<code>char</code>，因此…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向char的指针的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char)</li></ul></blockquote><h2 id="3-终极形态"><a href="#3-终极形态" class="headerlink" title="3.终极形态"></a>3.终极形态</h2><pre><code>      +-----------------------------+      |                  +---+      |      |  +---+           |+-+|      |      |  ^   |           |^ ||      |void (*signal(int, void (*fp)(int)))(int); ^    ^      |      ^    ^  ||      | |    +------+      |    +--+|      | |                  +--------+      | +----------------------------------+</code></pre><p>依然是:<code>signal</code>是什么?<br>注意<code>signal</code>在括号中，需要先解决它</p><ul><li>顺时针移动，首先遇到<code>(</code>，因此…<blockquote><p>signal是个传入参数为int和…,返回…的函数(signal is a function passing an int and a…)</p></blockquote></li><li>接着，我们可以对<code>fp</code>用相同的规则，<code>fp</code>是什么？<code>fp</code>在括号中，首先遇到的是<code>*</code>，于是…<blockquote><p>fp是个指向…的指针(fp is a pointer to…)</p></blockquote></li><li>继续会遇到<code>(</code>，就有…<blockquote><p>fp是个指向传入参数是int、返回…的函数的指针(fp is a pointer to a function passing int returning…)</p></blockquote></li><li>接着，看到了<code>void</code>…<blockquote><p>fp 是个指向传入参数是int、返回值为空(void)的函数的指针(fp is a pointer to a function passing int returning nothing (void))</p></blockquote></li><li>现在结束了对<code>fp</code>的解析，接着看<code>signal</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为…的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning…)</p></blockquote></li><li>现在还在括号内，接着的元素是<code>*</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为指向…的指针的函数(signal is a function passing an int and a pointer to a funciton passing an int returning nothing(void) returning a pointer to…)</p></blockquote></li><li>再继续，碰到了<code>(</code>…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为…的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning…)</p></blockquote></li><li>终于到最后了，我们只剩下<code>void</code>这一个元素了，最终<code>signale</code>的定义为…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为空的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning nothing(void))</p></blockquote></li></ul><h2 id="const和volatile的例子"><a href="#const和volatile的例子" class="headerlink" title="const和volatile的例子"></a><code>const</code>和<code>volatile</code>的例子</h2><p>规则一样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *chptr:</span><br></pre></td></tr></table></figure></p><p><code>chptr</code>是个指向一个char常量(constant)的指针(chptr is a pointer to a char constant)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向char的常量指针(chptr is a constant pointer to char)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向一个char原子(volatile)的常量指针(chptr is a constant pointer to a char volatile)</p><hr><p>C的复杂声明其实就不断加定语，但是这个定语在修饰的是哪个主语，需要按照顺时针/螺旋规则来解释。熟悉了就好。</p><hr><p>原文: <a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The <code></code>Clockwise/Spiral Rule’’</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The “Clockwise/Spiral Rule”&lt;br&gt;By David Anderson&lt;/p&gt;
&lt;p&gt;每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="tr" scheme="http://suntus.github.io/tags/tr/"/>
    
  </entry>
  
  <entry>
    <title>软件的12个要素</title>
    <link href="http://suntus.github.io/2017/12/08/%E8%BD%AF%E4%BB%B6%E7%9A%8412%E4%B8%AA%E8%A6%81%E7%B4%A0/"/>
    <id>http://suntus.github.io/2017/12/08/软件的12个要素/</id>
    <published>2017-12-08T09:37:57.000Z</published>
    <updated>2017-12-14T07:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>由Heroku创始人Adam Wiggins在2012年发布。</li><li>是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。</li><li>使用于任意语言和后端服务开发的应用程序。</li><li>最佳阅读人员：服务器开发和运维人员。</li><li>中心思想是隔离。</li></ul><a id="more"></a><h2 id="1-基准代码"><a href="#1-基准代码" class="headerlink" title="1.基准代码"></a>1.基准代码</h2><p>1个模块只有1份基准代码，多个模块组成的是一个分布式系统。基准代码应该用版本管理工具加以控制，每个基准代码应该独占1个库，同属1个系统的多个基准代码库可以加入组。</p><h2 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2.依赖"></a>2.依赖</h2><ul><li>显示声明依赖。</li><li>通过依赖隔离工具来确保程序不会调用系统种存在但清单中未声明的依赖项。这种做法应该统一应用到开发和生产环境。</li></ul><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><ul><li>与代码分离。</li><li>推荐保存到环境变量。</li></ul><h2 id="4-后端服务"><a href="#4-后端服务" class="headerlink" title="4.后端服务"></a>4.后端服务</h2><ul><li>把后端服务当做附加资源。如数据库，MQ,SMTP，缓存等。</li><li>应该保证应用在不改动任何代码的情况下，将本地mysql换成第三方服务(如Amazon RDS)</li></ul><h2 id="5-构建，发布，运行"><a href="#5-构建，发布，运行" class="headerlink" title="5.构建，发布，运行"></a>5.构建，发布，运行</h2><p>严格分离构建和运行<br>基准代码转换成一份部署需要三个阶段：<br>1）构建阶段：将代码转化成可执行包的过程。构建时会使用指定版本的代码，获取和打包依赖项，编译成二进制文件和资源文件<br>2）发布阶段：将构建结果和当前部署所需配置相结合，并能够立即在运行环境中投入使用<br>3）运行阶段：只针对选定的发布版本，在执行环境中启动一系列运行程序进程</p><h2 id="6-进程"><a href="#6-进程" class="headerlink" title="6.进程"></a>6.进程</h2><ul><li>系统可以有1个或多个进程，进程必须无状态且无共享，任何需要持久化的数据都存储在后端服务中（比如数据库）。</li><li>内存和磁盘可以作为进程在进行某种事务型操作时的缓存（比如下载一个很大的文件）。不考虑这些缓存的内容是不是可以保留给之后的请求使用。</li><li>如果需要在内存中保存数据，优先考虑使用redis等内存数据库。</li></ul><h2 id="7-端口绑定"><a href="#7-端口绑定" class="headerlink" title="7.端口绑定"></a>7.端口绑定</h2><ul><li>使用端口提供服务。</li></ul><h2 id="8-并发"><a href="#8-并发" class="headerlink" title="8.并发"></a>8.并发</h2><ul><li>应该更多考虑水平扩展的可能。</li><li>不需要自己设置守护进程，而应交给其他进程托管系统。</li></ul><h2 id="9-易处理"><a href="#9-易处理" class="headerlink" title="9.易处理"></a>9.易处理</h2><ul><li>可以瞬间开启或停止，有利于快速、弹性的伸缩应用</li><li>进程接收到终止信号会优雅的终止。对网络进程，优雅就是停止监听服务的端口，拒绝信的请求，并执行当前已接收到的请求，然后退出。对worker进程，优雅终止就是当前任务退出队列。任务都应该可重复，使重复操作幂等实现。</li><li>应该可以处理 意外的、不优雅的终止。</li></ul><h2 id="10-开发环境与线上环境等价"><a href="#10-开发环境与线上环境等价" class="headerlink" title="10.开发环境与线上环境等价"></a>10.开发环境与线上环境等价</h2><p>尽可能保持开发、预发布、线上环境相同<br>开发环境和线上环境的差异有：</p><ol><li>时间差异：开发的代码可能几天，几周才会上线</li><li>人员差异：开发人员编写代码，运维人员部署代码</li><li>工具差异： 开发人员或许使用nginx，sqlite， osx，线上环境使用apache，mysql，linux</li></ol><h2 id="11-日志"><a href="#11-日志" class="headerlink" title="11.日志"></a>11.日志</h2><p>把日志当做事件流。<br>日志使应用程序运行的动作变得透明。服务器环境中，日志通常被写在文件中，但这只是一种输出格式。<br>日志应该是事件流的汇总，将所有运行中进程和后端服务的数据流按照时间顺序收集起来。<br>应用本身不应考虑存储自己的数据流，不应该试图去写或管理日志文件，都应该直接输出的标准输出（stdout）。最后汇总到统一的日志处理系统中。</p><h2 id="12-管理进程"><a href="#12-管理进程" class="headerlink" title="12.管理进程"></a>12.管理进程</h2><p>后台管理任务当做一次性进程运行。</p><hr><p>参考：<br><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">The Twelve-Factor App</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;由Heroku创始人Adam Wiggins在2012年发布。&lt;/li&gt;
&lt;li&gt;是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。&lt;/li&gt;
&lt;li&gt;使用于任意语言和后端服务开发的应用程序。&lt;/li&gt;
&lt;li&gt;最佳阅读人员：服务器开发和运维人员。&lt;/li&gt;
&lt;li&gt;中心思想是隔离。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ongoing" scheme="http://suntus.github.io/tags/ongoing/"/>
    
  </entry>
  
  <entry>
    <title>用到的docker</title>
    <link href="http://suntus.github.io/2017/12/08/%E7%94%A8%E5%88%B0%E7%9A%84docker/"/>
    <id>http://suntus.github.io/2017/12/08/用到的docker/</id>
    <published>2017-12-08T00:34:42.000Z</published>
    <updated>2017-12-09T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>都是在ubuntu系统中<br><a id="more"></a></p><h2 id="1-修改container时区"><a href="#1-修改container时区" class="headerlink" title="1.修改container时区"></a>1.修改container时区</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加shell命令</span><br><span class="line">echo <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone </span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span>同步主机时区</span><br><span class="line">启动时挂载`/etc/localtime`文件</span><br></pre></td></tr></table></figure><p>docker run -it -v /etc/localtime:/etc/localtime <img><br><code>`</code></p><hr><p>参考</p><ol><li><a href="https://brickyang.github.io/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/" target="_blank" rel="noopener">时区</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是在ubuntu系统中&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>docker search时列出tag</title>
    <link href="http://suntus.github.io/2017/12/07/docker%20search%E6%97%B6%E5%88%97%E5%87%BAtag/"/>
    <id>http://suntus.github.io/2017/12/07/docker search时列出tag/</id>
    <published>2017-12-07T02:24:23.000Z</published>
    <updated>2017-12-12T02:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用这个脚本docker-show-repo-tag.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple script that will display docker repository tags.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#   $ docker-show-repo-tags.sh ubuntu centos</span></span><br><span class="line"><span class="keyword">for</span> Repo <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">  curl -s -S <span class="string">"https://registry.hub.docker.com/v2/repositories/library/<span class="variable">$Repo</span>/tags/"</span> | \</span><br><span class="line">    sed -e <span class="string">'s/,/,\n/g'</span> -e <span class="string">'s/\[/\[\n/g'</span> | \</span><br><span class="line">    grep <span class="string">'"name"'</span> | \</span><br><span class="line">    awk -F\<span class="string">" '&#123;print <span class="variable">$4</span>;&#125;' | \</span></span><br><span class="line"><span class="string">    sort -fu | \</span></span><br><span class="line"><span class="string">    sed -e "</span>s/^/<span class="variable">$&#123;Repo&#125;</span>:/<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这样用:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./docker-show-repo-tags.sh ubuntu centos</span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">14.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">16.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">17.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span>latest</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty<span class="number">-20171117</span></span><br><span class="line"><span class="symbol">ubuntu:</span>xenial</span><br><span class="line"><span class="symbol">ubuntu:</span>xenial<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">ubuntu:</span>zesty</span><br><span class="line"><span class="symbol">ubuntu:</span>zesty<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.7</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.8</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">7</span></span><br><span class="line"><span class="symbol">centos:</span>centos6</span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.6</span></span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.7</span></span><br><span class="line"><span class="symbol">centos:</span>centos7</span><br><span class="line"><span class="symbol">centos:</span>latest</span><br></pre></td></tr></table></figure></p><hr><p>参考：<a href="https://stackoverflow.com/a/34054903/2955061" target="_blank" rel="noopener">https://stackoverflow.com/a/34054903/2955061</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用这个脚本docker-show-repo-tag.sh&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Simple script that will display docker repository tags.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Usage:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#   $ docker-show-repo-tags.sh ubuntu centos&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; Repo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; $* ; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  curl -s -S &lt;span class=&quot;string&quot;&gt;&quot;https://registry.hub.docker.com/v2/repositories/library/&lt;span class=&quot;variable&quot;&gt;$Repo&lt;/span&gt;/tags/&quot;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sed -e &lt;span class=&quot;string&quot;&gt;&#39;s/,/,\n/g&#39;&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&#39;s/\[/\[\n/g&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grep &lt;span class=&quot;string&quot;&gt;&#39;&quot;name&quot;&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    awk -F\&lt;span class=&quot;string&quot;&gt;&quot; &#39;&amp;#123;print &lt;span class=&quot;variable&quot;&gt;$4&lt;/span&gt;;&amp;#125;&#39; | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sort -fu | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sed -e &quot;&lt;/span&gt;s/^/&lt;span class=&quot;variable&quot;&gt;$&amp;#123;Repo&amp;#125;&lt;/span&gt;:/&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker精简镜像体积</title>
    <link href="http://suntus.github.io/2017/12/07/docker%E7%B2%BE%E7%AE%80%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"/>
    <id>http://suntus.github.io/2017/12/07/docker精简镜像体积/</id>
    <published>2017-12-07T01:58:20.000Z</published>
    <updated>2017-12-12T02:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。</li><li>找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。<a id="more"></a></li><li>ubuntu安装软件的时候，区分 build时依赖和runtime时依赖，build的依赖（比如gcc,g++,cmake,make等等）可以在最后删除，runtime的当然就不能删除啦。</li><li>安装时使用<code>--no-install-recommands</code>选项，也就是<code>apt-get install -y --no-install-recommands  cmake3</code>，不安装apt-get推荐的依赖，只相信我们自己 : )</li><li>删除的时候用这个: <code>apt-get purge -y --auto-remove $buildDeps</code>，删的更干净。</li><li>删除apt-get安装时候的一些日志： <code>rm /var/log/dpkg.log /var/log/alternatives.log /var/log/apt/*.log</code>。</li><li>记得把安装时候不需要的源码删掉，能少一点儿是一点儿。</li></ol><hr><p>参考</p><ol><li><a href="http://blog.fleeto.us/translation/refactoring-dockerfile-image-size" target="_blank" rel="noopener">优化 Dockerfile，缩减镜像尺寸</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。&lt;/li&gt;
&lt;li&gt;找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>librdkafka相关</title>
    <link href="http://suntus.github.io/2017/12/04/librdkafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2017/12/04/librdkafka相关/</id>
    <published>2017-12-04T07:59:13.000Z</published>
    <updated>2017-12-13T07:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-offset管理"><a href="#1-offset管理" class="headerlink" title="1.offset管理"></a>1.offset管理</h2><p>kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个<code>__consumer_offsets</code>的topic中。<br>zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。<br><a id="more"></a><br>librdkafka支持两种offset管理方式：</p><ol><li>存放到本地文件</li><li>存放到集群中</li></ol><p>librdkafka consumer的high level API支持存放到broker中，low level API支持存放到本地文件</p><p><strong>存放到集群</strong><br>影响的配置有这么几个：</p><ul><li>group.id: 设置consumer组，因为offset是按组来管理的，所以必须有这个东西</li><li>enable.auto.commit: 设置是否自动保存，[true, false]</li><li>auto.commit.interval.ms: 自动保存的的时间，默认是5000(5s)</li></ul><p>下面是一段示例代码<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conf = rd_kafk<span class="built_in">a_conf</span>_new()<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"group.id"</span>,<span class="string">"hehe"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"enable.auto.commit"</span>,<span class="string">"true"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"auto.commit.interval.ms"</span>,<span class="string">"1000"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rk = rd_kafk<span class="built_in">a_new</span>(RD_KAFK<span class="built_in">A_CONSUMER</span>, conf, errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 创建个topic_partition list</span><br><span class="line">rtkp_list = rd_kafk<span class="built_in">a_topic</span>_partition_list_new(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"># 将名字为topic_test的topic添加到rtkp_list中，并将offset设置为RD_KAFK<span class="built_in">A_OFFSET</span>_STORED，也就是consumer上次存储在broker中的offset。rd_kafk<span class="built_in">a_topic</span>_partition_list_add()返回的是<span class="number">1</span>个rd_kafk<span class="built_in">a_topic</span>_partition_t。</span><br><span class="line">rd_kafk<span class="built_in">a_topic</span>_partition_list_add(rtkp_list,<span class="string">"topic_test"</span>,<span class="number">0</span>)-&gt;offset = RD_KAFK<span class="built_in">A_OFFSET</span>_STORED<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 这里是确定订阅哪个topic了</span><br><span class="line">rd_kafk<span class="built_in">a_assign</span>(rk, rtkp_list)<span class="comment">;</span></span><br><span class="line">while(<span class="number">1</span>)&#123;</span><br><span class="line">    msg  = rd_kafk<span class="built_in">a_consumer</span>_poll(rk, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用这个去查看存储的offset到哪儿了<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-consumer-offset-checker.sh --zookeeper localhost:2181 --topic topic_test  --group hehe</span><br><span class="line"></span><br><span class="line">Group           Topic                          Pid Offset          logSize         Lag             Owner</span><br><span class="line">hehe            topic_test                    0   6483667         1674985741      1668502074      none</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset就是当前存储的offset，logSize是当前最大的offset，lag是还没消费的msg个数</span></span><br></pre></td></tr></table></figure></p><p><strong>存放到本地</strong><br>诶，参考上边吧</p><h2 id="2-high-level-API多topic操作"><a href="#2-high-level-API多topic操作" class="headerlink" title="2.high level API多topic操作"></a>2.high level API多topic操作</h2><p>有时候需要在一个进程中订阅多个topic，并且每个topic需要单独操作，这时候就可以多申请几个<code>rd_kafka_topic_partition_list_t</code>，分别在每个<code>rd_kafka_topic_partition_list_t</code>中加入各自的topic，在订阅消息的时候，使用<code>rd_kafka_assign(rk, rktp_list);</code>来切换各个topic。就可以了。</p><h2 id="3-high-level-API手动存储consumer的offset"><a href="#3-high-level-API手动存储consumer的offset" class="headerlink" title="3.high level API手动存储consumer的offset"></a>3.high level API手动存储consumer的offset</h2><p>先设置这几个参数<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rk_conf的配置</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.offset.store = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 一般还会设置这个配置，指示在broker没有存储offset(最开始时候)或offset出现错误的时候，系统应该初始化的offset位置，默认是latest</span></span><br><span class="line"><span class="literal">auto</span>.offset.reset = [earliest, latest, <span class="literal">none</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始时候topic_conf的几个配置会让人迷惑，auto.commit.enable 只针对 low level API, high level API需要使用rk_conf的全局配置，enable.autom.commit是auto.commit.enable的别名</span></span><br><span class="line"><span class="literal">auto</span>.commit.enable = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>操作的话，需要用到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个是实际将offset提交到broker的操作，async为false的时候，该操作阻塞。</span></span><br><span class="line"><span class="comment">// 两个的区别是，第一个可以控制提交的offset的具体值，第二个只能提交msg的offset，不能手动控制。</span></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_topic_partition_list_t</span> *offsets, <span class="keyword">int</span> async);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit_message(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_message_t</span> *rkmessage, <span class="keyword">int</span> async);</span><br></pre></td></tr></table></figure></p><p>另外，还有个跟offset相关的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_offset_store(<span class="keyword">rd_kafka_topic_t</span> *rkt,</span><br><span class="line">                                          <span class="keyword">int32_t</span> partition, <span class="keyword">int64_t</span> offset);</span><br></pre></td></tr></table></figure></p><p>这个函数只是把offset提交到内存，并不是提交到broker存储起来，所以还是需要调用*commit()函数</p><p><strong>注意：如果多topic切换的时候，需要先commit，再切换，否则切换回来还是会从原先的offset开始读取消息。</strong></p><hr><p>参考:</p><ol><li><a href="http://www.cnblogs.com/smartloli/p/6266453.html" target="_blank" rel="noopener">kafka的offset管理</a></li><li><a href="https://github.com/edenhill/librdkafka/wiki/Consumer-offset-management" target="_blank" rel="noopener">librdkafka的一些说明</a></li><li><a href="https://github.com/arnaud-lb/php-rdkafka/issues/87" target="_blank" rel="noopener">关于high level API手动管理offset的讨论</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-offset管理&quot;&gt;&lt;a href=&quot;#1-offset管理&quot; class=&quot;headerlink&quot; title=&quot;1.offset管理&quot;&gt;&lt;/a&gt;1.offset管理&lt;/h2&gt;&lt;p&gt;kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个&lt;code&gt;__consumer_offsets&lt;/code&gt;的topic中。&lt;br&gt;zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="kafka" scheme="http://suntus.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>iniparser-C 配置解析</title>
    <link href="http://suntus.github.io/2017/11/24/iniparser-C%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://suntus.github.io/2017/11/24/iniparser-C配置解析/</id>
    <published>2017-11-24T02:08:59.000Z</published>
    <updated>2017-11-24T03:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ndevilla/iniparser" target="_blank" rel="noopener">https://github.com/ndevilla/iniparser</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>相当小，4个文件(2个c，2个h)，1500行左右</li><li>不依赖其他库</li><li>可重入，需要自己加锁实现线程安全</li></ul><p>另外，使用也相当简单<br><a id="more"></a></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先准备ini格式的配置文件<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[kafka]</span></span><br><span class="line"><span class="attr">broker</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9092</span></span><br><span class="line"><span class="attr">topic</span> = hello</span><br><span class="line"></span><br><span class="line"><span class="section">[db]</span></span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br></pre></td></tr></table></figure></p><p>解析<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">direcotyr *d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = iniparser_load(<span class="string">"haha.conf"</span>);</span><br><span class="line">iniparser_dump(d,<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// broker</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:broker"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"broker: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// topic</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:topic"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"topic: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.host</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"db:host"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.host: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.port</span></span><br><span class="line">n = iniparser_getint(d, <span class="string">"db:port"</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.port: %d\n"</span>, n);</span><br><span class="line"></span><br><span class="line">iniparser_freedict(d);</span><br></pre></td></tr></table></figure></p><p>主要的API<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取section个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getnsec</span><span class="params">(<span class="keyword">const</span> dictionary * d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第n个section的个数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getsecname</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出配置到文件，可重新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dumpsection_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * s, FILE * f)</span></span>;</span><br><span class="line"><span class="comment">// 导出配置到文件，方便查看，不可从新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getstring</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">const</span> <span class="keyword">char</span> * def)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">iniparser_getlongint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">long</span> <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">iniparser_getdouble</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">double</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getboolean</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置配置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_set</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry, <span class="keyword">const</span> <span class="keyword">char</span> * val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_unset</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_find_entry</span><span class="params">(<span class="keyword">const</span> dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入，清理</span></span><br><span class="line"><span class="function">dictionary * <span class="title">iniparser_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * ininame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_freedict</span><span class="params">(dictionary * d)</span></span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ndevilla/iniparser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ndevilla/iniparser&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相当小，4个文件(2个c，2个h)，1500行左右&lt;/li&gt;
&lt;li&gt;不依赖其他库&lt;/li&gt;
&lt;li&gt;可重入，需要自己加锁实现线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，使用也相当简单&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数组的二分算法模块--bisect</title>
    <link href="http://suntus.github.io/2017/11/03/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9D%97-bisect/"/>
    <id>http://suntus.github.io/2017/11/03/数组的二分算法模块-bisect/</id>
    <published>2017-11-03T06:09:06.000Z</published>
    <updated>2017-11-03T06:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两点作用："><a href="#1-两点作用：" class="headerlink" title="1.两点作用："></a>1.两点作用：</h2><p>1.插入时就维护好一个排好序的数组<br>2.数组非常大的时候速度较快</p><a id="more"></a><p>用着也很简单，只有2个操作：查找、插入，每个操作各有2个方法，分别是</p><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left(a, x, <span class="attribute">lo</span>=0, <span class="attribute">hi</span>=len(a))</span><br></pre></td></tr></table></figure><p>返回一个数组a的下标i，a[lo… i-1] &lt; x &lt;= a[i…hi]。也就是说在i左边的元素都比x小，在i及i右边的元素，都等于或大于x.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect</span>()</span><br></pre></td></tr></table></figure></p><p>这两个是一样的。<br>返回一个数组a的下标i，a[lo… i-1] &lt;= x &lt;a[i…hi]。也就是说在i左边的元素小于等于x，在i及i右边的元素，都大于x</p><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_left</span>()</span><br></pre></td></tr></table></figure><p>插入的效果跟查找是一样的，不过就是查找然后插入:list.insert(bisect.bisect_left())<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort</span>()</span><br></pre></td></tr></table></figure></p><p>上边四个操作可以用下图帮助理解:<br><img src="/img/python/bisect.png" title="bisect操作"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-两点作用：&quot;&gt;&lt;a href=&quot;#1-两点作用：&quot; class=&quot;headerlink&quot; title=&quot;1.两点作用：&quot;&gt;&lt;/a&gt;1.两点作用：&lt;/h2&gt;&lt;p&gt;1.插入时就维护好一个排好序的数组&lt;br&gt;2.数组非常大的时候速度较快&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python配置解析--ConfigParser</title>
    <link href="http://suntus.github.io/2017/11/02/python%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90-ConfigParser/"/>
    <id>http://suntus.github.io/2017/11/02/python配置解析-ConfigParser/</id>
    <published>2017-11-02T06:32:33.000Z</published>
    <updated>2017-11-02T06:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>配置文件的格式<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">bind</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">log</span> = /var/log/haha.log</span><br><span class="line"><span class="attr">workers</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">connect</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9090</span></span><br><span class="line"><span class="attr">log</span> = /var/log/hehe.log</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用的话就相当简单了<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> = ConfigParser.ConfigParser()</span><br><span class="line"><span class="keyword">cp</span>.<span class="keyword">read</span>(<span class="string">"etc/app.conf"</span>)</span><br><span class="line">server.bind = <span class="keyword">cp</span>.<span class="built_in">get</span>(<span class="string">"server"</span>, <span class="string">"bind"</span>)</span><br><span class="line">server.workers = <span class="keyword">cp</span>.getint(<span class="string">"server"</span>,<span class="string">"workers"</span>)</span><br><span class="line"># 另外还有</span><br><span class="line"># <span class="keyword">cp</span>.getboolean()</span><br><span class="line"># <span class="keyword">cp</span>.getfloat()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置文件的格式&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[server]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;bind&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/haha.log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;workers&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[client]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;connect&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9090&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/hehe.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python连接mysql</title>
    <link href="http://suntus.github.io/2017/11/02/python%E8%BF%9E%E6%8E%A5mysql/"/>
    <id>http://suntus.github.io/2017/11/02/python连接mysql/</id>
    <published>2017-11-02T05:57:29.000Z</published>
    <updated>2017-11-02T06:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装MySQLdb<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> mysql-python</span><br></pre></td></tr></table></figure></p><p>创建连接<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_conn(**dbconfig):</span><br><span class="line">    conn = MySQLdb.<span class="built_in">connect</span>(**dbconfig)</span><br><span class="line">    <span class="built_in">cursor</span> = conn.<span class="built_in">cursor</span>()</span><br><span class="line">    <span class="built_in">return</span> conn, <span class="built_in">cursor</span></span><br><span class="line"></span><br><span class="line">conn, <span class="built_in">cursor</span> = db_get_conn(host=<span class="string">"127.0.0.1"</span>, user=<span class="string">"root"</span>,passwd=“<span class="number">123</span><span class="string">", db=“db_haha"</span>,charset=<span class="string">"utf8"</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建查询<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.<span class="keyword">execute</span>(<span class="string">"select a,b from t_hehe"</span>)</span><br></pre></td></tr></table></figure></p><p>获取结果<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">a</span>, b <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">        print <span class="keyword">a</span>,b</span><br><span class="line"></span><br><span class="line">// 注意：如果只有<span class="number">1</span>个元素，这样才行</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">a</span>,) <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">    print <span class="keyword">a</span></span><br></pre></td></tr></table></figure></p><p>如果结果太大，不想全部拉回来，而是创建好查询，现在服务器端查好结果，再一条条拉回来，要这样创建连接<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_ss_conn(*<span class="number">*dbc</span>onfig):</span><br><span class="line">    ss_conn = MySQLdb.connect(*<span class="number">*dbc</span>onfig)</span><br><span class="line">    ss_cursor = conn.cursor(<span class="attribute">cursorclass</span>=MySQLdb.cursors.SSCursor)</span><br><span class="line">    return ss_conn, ss_cursor</span><br><span class="line"></span><br><span class="line">ss_conn, ss_cursor = db_get_conn(<span class="attribute">host</span>=<span class="string">"127.0.0.1"</span>, <span class="attribute">user</span>=<span class="string">"root"</span>,passwd=“123", <span class="attribute">db</span>=“db_haha",charset="utf8")</span><br></pre></td></tr></table></figure></p><p>然后这样获取结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss_cursor.execute(<span class="string">"select a,b from t_hehe"</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span> <span class="keyword">in</span> ss_cursor:</span><br><span class="line">    print <span class="selector-tag">a</span>, b</span><br></pre></td></tr></table></figure></p><p>最后修改的话，记得提交事务<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">conn</span><span class="selector-class">.commit</span>()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装MySQLdb&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; mysql-python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建连接&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def db_get_conn(**dbconfig):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn = MySQLdb.&lt;span class=&quot;built_in&quot;&gt;connect&lt;/span&gt;(**dbconfig)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = conn.&lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = db_get_conn(host=&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, user=&lt;span class=&quot;string&quot;&gt;&quot;root&quot;&lt;/span&gt;,passwd=“&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;, db=“db_haha&quot;&lt;/span&gt;,charset=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>nginx图集</title>
    <link href="http://suntus.github.io/2017/10/20/nginx%E5%9B%BE%E9%9B%86/"/>
    <id>http://suntus.github.io/2017/10/20/nginx图集/</id>
    <published>2017-10-20T09:02:33.000Z</published>
    <updated>2017-10-30T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx的代码组织相当简洁明了。<br><a id="more"></a><br><img src="/img/nginx/ngx_src_1.png" title="模块的组织"></p><p><img src="/img/nginx/ngx_src_2.png" title="头文件的组织,可以帮助理解整体结构"></p><p>原来是想写一下nginx的启动流程的，但发现把这个图做出来，就没什么好说的了，即使写出来也都是大白话，还不如仔细看看这个图。<br><img src="/img/nginx/ngx_src_3.png" title="nginx主体框架启动流程"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx的代码组织相当简洁明了。&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://suntus.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>命令_nc</title>
    <link href="http://suntus.github.io/2017/09/22/%E5%91%BD%E4%BB%A4-nc/"/>
    <id>http://suntus.github.io/2017/09/22/命令-nc/</id>
    <published>2017-09-22T08:19:37.000Z</published>
    <updated>2017-09-22T08:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>netcat——瑞士军刀</p><h1 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h1><ol><li>TCP服务端客户端</li><li>网络测试</li><li>ssh的SOCKS或HTTP代理</li><li>简单的端口扫描<br>…<a id="more"></a></li></ol><h1 id="2-一些命令"><a href="#2-一些命令" class="headerlink" title="2. 一些命令"></a>2. 一些命令</h1><ul><li>-4：只使用IPv4地址</li><li>-6：只是用IPv6地址</li><li>-b：允许广播</li><li>-C：使用CRLF作为行的结尾</li><li>-D：启动debug</li><li>-d：不从标准输入中读取</li><li>-I length：设置TCP接收缓冲区大小</li><li>-i interval：在发送和接收数据包之间设置时间间隔，也在连接到多个端口的时候设置时间间隔</li><li>-k: 强制nc在连接到1个端口之后监听等待1个连接到来。跟-l配合使用</li><li>-l: 监听模式</li><li>-n：不在任何地址、主机名、端口上做DNS（直接是数字形式的）</li><li>-O length: 设置TCP发送缓冲区大小</li><li>-P proxy_username: 连接到proxy的时候提供用户名来验证</li><li>-p source_port：设置源端口</li><li>-q seconds: 在标准输入发送EOF后，等待这些秒，如果是负数，就一直等下去</li><li>-r: 让源/目的端口随机，不让在一个范围内分配</li><li>-S：开启RFC 2385 TCP MD5 signature option</li><li>-s source: 设置源地址，如果是unix domain socket，就指定文件</li><li>-T toskeyword：改变IPv4的TOS字段</li><li>-U：使用unix domain socket</li><li>-u：使用udp，而不是默认的TCP。不用-s指定的话，会在/tmp目录下新建临时文件</li><li>-V rtable: 设置使用的路由表</li><li>-v: verbose输出</li><li>-w timeout: 向外连接的时候设置超时时间</li><li>-X proxy_protocol: 设置代理协议，4” (SOCKS v.4), “5” (SOCKS v.5) and “connect”(HTTPS proxy)。默认是5</li><li>-x proxy_address[:port]：设置连接的代理地址</li><li>-Z:DCCP模式</li><li>-z: 只是扫描一下监听端口，而不发送任何数据。</li></ul><h1 id="3-简单的用法"><a href="#3-简单的用法" class="headerlink" title="3. 简单的用法"></a>3. 简单的用法</h1><h2 id="1-设置TCP服务端和客户端"><a href="#1-设置TCP服务端和客户端" class="headerlink" title="1. 设置TCP服务端和客户端"></a>1. 设置TCP服务端和客户端</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line"># rm -f /tmp/f; mkfifo /tmp/f</span><br><span class="line"># cat /tmp/f | /bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span> | nc -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1234</span> &gt; /tmp/f</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line">$ nc host.example.com <span class="number">1234</span></span><br><span class="line">$ (shell prompt from host.example.com)</span><br></pre></td></tr></table></figure><h2 id="2-文件传输"><a href="#2-文件传输" class="headerlink" title="2. 文件传输"></a>2. 文件传输</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一端</span><br><span class="line">$ nc -l <span class="number">1234</span> &gt; filename.out</span><br><span class="line"></span><br><span class="line">另一端：</span><br><span class="line">$ nc host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">1234</span> &lt; filename.<span class="keyword">in</span></span><br></pre></td></tr></table></figure><h2 id="3-连接服务器"><a href="#3-连接服务器" class="headerlink" title="3. 连接服务器"></a>3. 连接服务器</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nc [-C] localhost <span class="number">25</span> &lt;&lt; EOF</span><br><span class="line">HELO host<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br><span class="line">MAIL FROM:&lt;user@host<span class="selector-class">.example</span><span class="selector-class">.com</span>&gt;</span><br><span class="line">RCPT TO:&lt;user2@host<span class="selector-class">.example</span><span class="selector-class">.com</span>&gt;</span><br><span class="line">DATA</span><br><span class="line">Body of email.</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="4-端口扫描"><a href="#4-端口扫描" class="headerlink" title="4. 端口扫描"></a>4. 端口扫描</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -zv host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">20</span>-<span class="number">30</span></span><br><span class="line">$ nc -zv host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">80</span> <span class="number">20</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><hr><p>参考:</p><ol><li>man nc</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netcat——瑞士军刀&lt;/p&gt;
&lt;h1 id=&quot;1-功能&quot;&gt;&lt;a href=&quot;#1-功能&quot; class=&quot;headerlink&quot; title=&quot;1. 功能&quot;&gt;&lt;/a&gt;1. 功能&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;TCP服务端客户端&lt;/li&gt;
&lt;li&gt;网络测试&lt;/li&gt;
&lt;li&gt;ssh的SOCKS或HTTP代理&lt;/li&gt;
&lt;li&gt;简单的端口扫描&lt;br&gt;…
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
      <category term="cli" scheme="http://suntus.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>shell IO重定向</title>
    <link href="http://suntus.github.io/2017/09/22/shell%20IO%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://suntus.github.io/2017/09/22/shell IO重定向/</id>
    <published>2017-09-22T03:49:02.000Z</published>
    <updated>2017-09-25T04:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>重定向没什么难理解的，只是有些命令会不熟悉，这里列出了一些常用的命令，以备后查。</p><p>标准输入：键盘，0<br>标准输出：屏幕，1<br>标准错误：屏幕，2<br><a id="more"></a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> 1&gt; <span class="selector-tag">haha</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将标准输出1重定向到文件haha.txt。注意1和&gt;之间没有空格。1可以省略，就成了常用的 ls &gt; haha.txt</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="number">1</span><span class="meta">&gt;&gt;</span>haha.txt</span><br></pre></td></tr></table></figure><p>1个&gt;是先清空haha.txt，再写入；两个&gt;是追加到haha.txt后边</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> <span class="selector-tag">-qw</span> 2&gt; <span class="selector-tag">haha</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将标准错误重定向到haha.txt</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="meta">&amp;&gt; haha.txt</span></span><br></pre></td></tr></table></figure><p>将标准输出、标准错误都重定向到haha.txt</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">i</span>&gt;&amp;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>将文件描述符i重定向到描述符j，也就是现在j也具有了i的能力，应用到i上的IO操作都可以应用到j上，效果一样。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#echo <span class="number">123456789</span> &gt;filename   把字符串写到文件filename中</span><br><span class="line">#exec <span class="number">3</span>&lt;&gt;filename           把文件filename打开，并指定文件标识符为<span class="number">3</span></span><br><span class="line">#read -n <span class="number">4</span> &lt;&amp;<span class="number">3</span>              从文件中读<span class="number">4</span>个字符，句柄已经指到第四个字符末尾</span><br><span class="line">#echo -n . &gt;&amp;<span class="number">3</span>              在第<span class="number">5</span>个字符处写一个点，覆盖第<span class="number">5</span>个字符，-n表示不换行</span><br><span class="line">#exec <span class="number">3</span>&gt;&amp;-                 关闭文件标识符<span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>3&lt;&gt;filename</code> 表示用描述符3打开filename<br><code>3&gt;&amp;-</code> 表示关闭输出描述符的文件</p><p><code>3&lt;&amp;-</code> 表示关闭输入描述符的文件</p><hr><p>参考</p><ol><li>IBM的资料：<a href="https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html</a></li><li>不知道这个跟上个是谁抄谁的一部分：<a href="http://manual.51yip.com/shell/io-redirection.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重定向没什么难理解的，只是有些命令会不熟悉，这里列出了一些常用的命令，以备后查。&lt;/p&gt;
&lt;p&gt;标准输入：键盘，0&lt;br&gt;标准输出：屏幕，1&lt;br&gt;标准错误：屏幕，2&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>命令_date</title>
    <link href="http://suntus.github.io/2017/09/20/%E5%91%BD%E4%BB%A4_date/"/>
    <id>http://suntus.github.io/2017/09/20/命令_date/</id>
    <published>2017-09-20T08:31:57.000Z</published>
    <updated>2017-09-22T08:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-显示和设置系统日期和时间"><a href="#1-显示和设置系统日期和时间" class="headerlink" title="1. 显示和设置系统日期和时间"></a>1. 显示和设置系统日期和时间</h2><p>date [OPTION]… [+FORMAT]<br>date [-u| –utc| -universal] [MMDDhhmm[[CC]UYY][.ss]]</p><h2 id="2-其实核心的只有1个功能："><a href="#2-其实核心的只有1个功能：" class="headerlink" title="2. 其实核心的只有1个功能："></a>2. 其实核心的只有1个功能：</h2><p><strong><em>输入特定格式的时间，转换成自己想要的时间格式</em></strong></p><a id="more"></a><h3 id="2-1-输入使用-d，后边跟描述时间的文字"><a href="#2-1-输入使用-d，后边跟描述时间的文字" class="headerlink" title="2.1 输入使用-d，后边跟描述时间的文字"></a>2.1 输入使用-d，后边跟描述时间的文字</h3><p>比如<br>“Sun, 29 Feb 2004 16:21:42 -0800”, “2004-02-29 16:21:42” , “next Thursday”, “-10day”, “+10min”等等，该描述性的文字由指示日历的日期，时间的天，时间的时区，天的星期，相对时间，相对日期和数字组成。空字符串表示这天的开始。</p><h3 id="2-2-输出使用-FORMAT，后边跟各种格式："><a href="#2-2-输出使用-FORMAT，后边跟各种格式：" class="headerlink" title="2.2 输出使用+FORMAT，后边跟各种格式："></a>2.2 输出使用+FORMAT，后边跟各种格式：</h3><p>%%: 符号%<br>%a: 本地星期缩写， Sun<br>%A: 本地星期全称， Sunday<br>%b: 本地月份缩写, Jan<br>%B: 本地月份全称, January<br>%c: 本地日期和时间, Thu Mar 3 23:-5:25 2005<br>%C: 世纪，类似%Y，DNA没有后两位, 20<br>%d: 月的第几天, 01<br>%D: 日期，%m/%d/%y<br>%e: 月的天数，用空格填充，类似%_d<br>%F: 完整的日期格式，类似%F-%m-%d<br>%g: ISO格式年的后两位<br>%G: ISO格式的年<br>%h: 跟%b一样<br>%H: 小时(00..23)<br>%I: 小时(01..12)<br>%j: 年的第几天(001..366)<br>%k: 小时，用空格填充(0..23); 类似%_H<br>%l: 小时，用空格填充(1..12) ； 类似%_I<br>%m: 月(01..12)<br>%M: 分钟(00..59)<br>%n: 换行<br>%N: 纳秒,nanoseconds(0000000000..999999999)<br>%p: 本地的AM或者PM<br>%P: 类似%p，但是是小写<br>%r：本地12小时制时钟时间  11:11:04 PM<br>%R: 24小时制的小时跟分钟，类似%H:%M<br>%s: 从1970-01-01 00:00:00 UTC开始的秒数，时间戳<br>%S: 秒(00..60)<br>%t: tab字符<br>%T: 时间，类似%H:%M:%S<br>%u: 星期的第几天(1..7),1是星期一<br>%U: 年的第几个星期(00..53)，周日是星期的开始<br>%V: ISO星期制，星期一是星期的开始（01..53）<br>%w: 星期的第几天(0..6)，0是星期天<br>%W: 年的第几个星期(00..53)，周一是星期的开始<br>%x:  本地日期表示(12/31/99)<br>%X: 本地时间表示(23:13:48)<br>%y: 年的后两位数字(00..99)<br>%Y: 年<br>另外还有几个符号，用于修饰<br>-  不填充<br>_ 用空格填充<br>0 用0填充<br>^ 用大写<br>#  用相反的大小写</p><h2 id="3-几个例子："><a href="#3-几个例子：" class="headerlink" title="3. 几个例子："></a>3. 几个例子：</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出今天开始时间</span></span><br><span class="line">date -d <span class="string">""</span></span><br><span class="line"><span class="comment"># 当前时间戳</span></span><br><span class="line">date +%s</span><br><span class="line"><span class="comment"># 输出好看的时间：2017-9-20 16:21:42</span></span><br><span class="line">date +<span class="string">"%F %T"</span></span><br><span class="line"><span class="comment"># 将时间戳转换成可读时间，对这里的时间戳前边要加@</span></span><br><span class="line">date -d @1505896166 +<span class="string">"%F %T"</span></span><br><span class="line"><span class="comment"># 输出10分钟前的时间戳</span></span><br><span class="line">date -d <span class="string">"-10min"</span> +%s</span><br></pre></td></tr></table></figure><p>至于设置系统时间，加个-s就行了。</p><hr><p>参考：</p><ol><li>man date</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-显示和设置系统日期和时间&quot;&gt;&lt;a href=&quot;#1-显示和设置系统日期和时间&quot; class=&quot;headerlink&quot; title=&quot;1. 显示和设置系统日期和时间&quot;&gt;&lt;/a&gt;1. 显示和设置系统日期和时间&lt;/h2&gt;&lt;p&gt;date [OPTION]… [+FORMAT]&lt;br&gt;date [-u| –utc| -universal] [MMDDhhmm[[CC]UYY][.ss]]&lt;/p&gt;
&lt;h2 id=&quot;2-其实核心的只有1个功能：&quot;&gt;&lt;a href=&quot;#2-其实核心的只有1个功能：&quot; class=&quot;headerlink&quot; title=&quot;2. 其实核心的只有1个功能：&quot;&gt;&lt;/a&gt;2. 其实核心的只有1个功能：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;输入特定格式的时间，转换成自己想要的时间格式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
      <category term="cli" scheme="http://suntus.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>用到的tmux</title>
    <link href="http://suntus.github.io/2017/09/19/%E7%94%A8%E5%88%B0%E7%9A%84tmux/"/>
    <id>http://suntus.github.io/2017/09/19/用到的tmux/</id>
    <published>2017-09-19T09:15:10.000Z</published>
    <updated>2018-02-06T03:59:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>终端复用软件，跟screen一样，但是要强大的多。</p><h2 id="1-典型应用场景"><a href="#1-典型应用场景" class="headerlink" title="1. 典型应用场景"></a>1. 典型应用场景</h2><p>自己电脑是客户端，平常ssh到linux服务器上编译运行调试软件，网络断开或者自己电脑挂掉之后，不想服务器上运行的程序也挂掉，这时候就可以用tmux了。还有就是tmux能方便的多开好几个窗口。tmux的作用是代理终端，以前你直接通过ssh通道来操作服务器的终端，现在通过ssh通道启动了1个tmux程序，由tmux程序代替你控制多个终端，这样你就拥有了一组终端，所以是个服务器开发神器。这个神器差不多长这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/280482-243749548e61fd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><a id="more"></a><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>跟vim差不多，也是要在服务器本用户主目录下边放一个配置文件<code>.tmux.conf</code>，直接用这个吧，有些东西自己想调整可以看着改：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># (‑●‑●)&gt; released under the WTFPL v2 license, by Gregory Pakosz (@gpakosz)</span></span><br><span class="line">unbind C-b</span><br><span class="line"><span class="keyword">set</span> -g prefix C-a</span><br><span class="line"></span><br><span class="line"><span class="meta">#up</span></span><br><span class="line">bind-key k select-pane -U</span><br><span class="line"><span class="meta">#down</span></span><br><span class="line">bind-key j select-pane -D</span><br><span class="line"><span class="meta">#left</span></span><br><span class="line">bind-key h select-pane -L</span><br><span class="line"><span class="meta">#right</span></span><br><span class="line">bind-key l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#select last window</span></span><br><span class="line">bind-key C-l select-window -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#copy-mode 将快捷键设置为vi 模式</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"><span class="meta"># use the powerline patched font variant of the theme, possible values are:</span></span><br><span class="line"><span class="meta"># - default</span></span><br><span class="line"><span class="meta"># - powerline</span></span><br><span class="line">tmux_conf_theme=<span class="keyword">default</span></span><br><span class="line"><span class="meta">#tmux_conf_theme=powerline</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display an indicator in the status line when the prefix key has been pressed,</span></span><br><span class="line"><span class="meta"># possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_prefix=disabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_prefix=enabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the battery information in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_battery=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_battery=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># style to use for the battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - bar</span></span><br><span class="line"><span class="meta"># - percentage</span></span><br><span class="line">tmux_conf_battery_style=bar</span><br><span class="line"><span class="meta">#tmux_conf_battery_style=percentage</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># symbols to use for battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - block</span></span><br><span class="line"><span class="meta"># - heart</span></span><br><span class="line">tmux_conf_battery_symbol=block</span><br><span class="line"><span class="meta">#tmux_conf_battery_symbol=heart</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># number of symbols to use for battery status</span></span><br><span class="line">tmux_conf_battery_symbol_count=auto</span><br><span class="line"><span class="meta">#tmux_conf_battery_symbol_count=5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># palette used for the battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - 'colour_full_fg,colour_empty_fg,colour_bg'</span></span><br><span class="line"><span class="meta"># - heat</span></span><br><span class="line"><span class="meta"># - gradient</span></span><br><span class="line">tmux_conf_battery_palette=<span class="string">'#d70000,#e4e4e4,#000000'</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=colour160,colour254,colour16</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=heat</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=gradient</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the battery status: charging (U+26A1) / discharging (U+1F50B)</span></span><br><span class="line">tmux_conf_battery_status=enabled</span><br><span class="line"><span class="meta">#tmux_conf_battery_status=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># or alternatively use an external tool, e.g. [https://github.com/Goles/Battery](https://github.com/Goles/Battery)</span></span><br><span class="line"><span class="meta">#tmux_conf_battery='#(battery -t) '</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the time in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_time=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_time=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the date in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_date=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_date=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the username in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line"><span class="meta"># - ssh</span></span><br><span class="line">tmux_conf_theme_username=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_username=disabled</span></span><br><span class="line"><span class="meta">#tmux_conf_theme_username=ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the hostname in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line"><span class="meta"># - ssh</span></span><br><span class="line">tmux_conf_theme_hostname=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_hostname=disabled</span></span><br><span class="line"><span class="meta">#tmux_conf_theme_hostname=ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># highlight focuse pane, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_highlight_focused_pane=disabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_highlight_focused_pane=enabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># should new windows retain current path, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_windows_retain_current_path=<span class="literal">false</span></span><br><span class="line"><span class="meta">#tmux_conf_new_windows_retain_current_path=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># should new panes reatin current path, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_panes_retain_current_path=<span class="literal">true</span></span><br><span class="line"><span class="meta">#tmux_conf_new_panes_retain_current_path=false</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># prompt for session name when creating a new session, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_session_prompt=<span class="literal">false</span></span><br><span class="line"><span class="meta">#tmux_conf_new_session_prompt=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># if you're running tmux within iTerm2</span></span><br><span class="line"><span class="meta"># - and tmux is 1.9 or 1.9a</span></span><br><span class="line"><span class="meta"># - and iTerm2 is configured to let option key act as +Esc</span></span><br><span class="line"><span class="meta"># - and iTerm2 is configured to send [1;9A -&gt; [1;9D for option + arrow keys</span></span><br><span class="line"><span class="meta"># then uncomment the following line to make Meta + arrow keys mapping work</span></span><br><span class="line"><span class="meta">#set -g terminal-overrides "*:kUP3=\e[1;9A,*:kDN3=\e[1;9B,*:kRIT3=\e[1;9C,*:kLFT3=\e[1;9D"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta"># this is the place to further customize tmux's configuration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#set -g history-limit 10000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-几个概念"><a href="#3-几个概念" class="headerlink" title="3. 几个概念"></a>3. 几个概念</h2><ol><li>session，会话</li><li>window，窗口</li><li>panel，面板</li></ol><p>关系是“1个会话会包含几个窗口，1个窗口会包含几个面板”<br>当然，1个ssh通道可以启动好几个会话，每个会话都可以detach和attach，从而一下子恢复一组工作空间。网络断开之后也会恢复哦，不过服务器重启就没办法了，毕竟tmux是跑在服务器上的软件。</p><h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h2><p><strong>在tmux之外的命令</strong><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 新建1个名叫hello的session</span></span><br><span class="line">tmux <span class="keyword">new</span> -s hello</span><br><span class="line"></span><br><span class="line"><span class="meta"># 列出当前有几个session</span></span><br><span class="line">tmux ls</span><br><span class="line"></span><br><span class="line"><span class="meta"># 挂接到名叫hello的session，恢复先前的工作空间</span></span><br><span class="line">tmux at -t hello</span><br></pre></td></tr></table></figure></p><p><strong>进入tmux后的命令</strong>。一般来说在tmux内部的常用命令都是组合键，先按下前缀键，再按下后边跟着的那个键。默认的前缀键是ctrl+b，上边的配置修改成了ctrl+a，因为a距离更近啊：）<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 退出当前panel；如果当前panel是该window的最后一个，就退出该window；如果该window是该session的最后1个，就退出该session。这个不带前缀键。</span></span><br><span class="line">ctrl+d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 安全退出当前session(detach)，这样你以后还能重新挂接(attach)上来恢复工作空间。</span></span><br><span class="line">ctrl+a, d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览并切换session</span></span><br><span class="line">ctrl+a, s</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览当前配置使用的快捷键列表，按q退出</span></span><br><span class="line">ctrl+a, ?</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建一个window</span></span><br><span class="line">ctrl+a, c</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在前后两个window之间跳转</span></span><br><span class="line">ctrl+a, ctrl+l</span><br><span class="line"></span><br><span class="line"><span class="meta"># 跳转到相应编号的window</span></span><br><span class="line">ctrl+a, <span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta"># 修改当前window的名称，默认都是个'bash'。是个逗号哈。</span></span><br><span class="line">ctrl+a, ,</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建垂直切分的panel</span></span><br><span class="line">ctrl+a, %</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建水平切分的panel</span></span><br><span class="line">ctrl+a, <span class="string">"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在panel之间切换啊，跟vim的方向一样，不过都需要加个前缀</span></span><br><span class="line"><span class="meta"># 向左</span></span><br><span class="line">ctrl+a, h</span><br><span class="line"><span class="meta"># 向右</span></span><br><span class="line">ctrl+a, l</span><br><span class="line"><span class="meta"># 向下</span></span><br><span class="line">ctrl+a, j</span><br><span class="line"><span class="meta"># 向上</span></span><br><span class="line">ctrl+a, k</span><br><span class="line"></span><br><span class="line"><span class="meta"># 暂时将当前panel占据整个window，再按一次就切换回去，在复制的时候很有用。</span></span><br><span class="line">ctrl+a, z</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览历史，进入后就可以按vim的进行操作了，常用的是j,k, ctrl+b(向上翻页)，ctrl+f(向下翻页)</span></span><br><span class="line">ctrl+a, [</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制关闭当前panel</span></span><br><span class="line">ctrl+a, x</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制关闭当前window</span></span><br><span class="line">ctrl+a, <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure></p><h1 id="切换panel布局，比如横向分屏变竖向"><a href="#切换panel布局，比如横向分屏变竖向" class="headerlink" title="切换panel布局，比如横向分屏变竖向"></a>切换panel布局，比如横向分屏变竖向</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+<span class="keyword">a</span>, <span class="literal">space</span></span><br></pre></td></tr></table></figure><h1 id="旋转panel布局，比如左1右2，变为左2右1"><a href="#旋转panel布局，比如左1右2，变为左2右1" class="headerlink" title="旋转panel布局，比如左1右2，变为左2右1"></a>旋转panel布局，比如左1右2，变为左2右1</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+<span class="selector-tag">a</span>, ctlr+o</span><br></pre></td></tr></table></figure><h1 id="微调panel大小，这个试一下就知道了"><a href="#微调panel大小，这个试一下就知道了" class="headerlink" title="微调panel大小，这个试一下就知道了"></a>微调panel大小，这个试一下就知道了</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+<span class="selector-tag">a</span>, ctrl+方向键</span><br></pre></td></tr></table></figure><p>好了，常用的就是这些了。</p><hr><p>参考：</p><ol><li><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终端复用软件，跟screen一样，但是要强大的多。&lt;/p&gt;
&lt;h2 id=&quot;1-典型应用场景&quot;&gt;&lt;a href=&quot;#1-典型应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. 典型应用场景&quot;&gt;&lt;/a&gt;1. 典型应用场景&lt;/h2&gt;&lt;p&gt;自己电脑是客户端，平常ssh到linux服务器上编译运行调试软件，网络断开或者自己电脑挂掉之后，不想服务器上运行的程序也挂掉，这时候就可以用tmux了。还有就是tmux能方便的多开好几个窗口。tmux的作用是代理终端，以前你直接通过ssh通道来操作服务器的终端，现在通过ssh通道启动了1个tmux程序，由tmux程序代替你控制多个终端，这样你就拥有了一组终端，所以是个服务器开发神器。这个神器差不多长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/280482-243749548e61fd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>用到的calibre</title>
    <link href="http://suntus.github.io/2017/09/13/%E7%94%A8%E5%88%B0%E7%9A%84calibre/"/>
    <id>http://suntus.github.io/2017/09/13/用到的calibre/</id>
    <published>2017-09-12T22:06:04.000Z</published>
    <updated>2017-09-21T08:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">calibre</a>是一个电子书管理器，最好的，没有之一。而且免费。</p><p>大概长这样：<br><img src="/img/calibre/1.png" alt="界面预览"></p><a id="more"></a><p>基本的导入导出就不再说了，主要介绍下用到的功能。</p><h1 id="1-多级目录管理"><a href="#1-多级目录管理" class="headerlink" title="1. 多级目录管理"></a>1. 多级目录管理</h1><p>建立像这样自定义的多级目录：<br><img src="/img/calibre/2.png" alt="多级目录"></p><p><strong>首先</strong>，首选项–&gt;添加栏目–&gt;添加自定义栏目–&gt;</p><p><img src="/img/calibre/3.png" alt="添加属性"><br><em>参考值</em>：是搜索的时候用到的词，最好是英文<br><em>栏目标题</em>：就是显示出来的顶级目录名<br><em>栏目类型</em>：这里选择第二个：<br><img src="/img/calibre/4.png" alt="添加属性"><br>确定—&gt;应用–&gt;重启calibre。</p><p><img src="/img/calibre/5.png" alt="调整标签的层级属性"></p><p><strong>然后</strong>，首选项–&gt;界面外观–&gt;标签浏览器，将刚刚定义的”suntus”定义为具有层次关系的分类。应用。<br>现在只是定义了顶层目录，还不会显示下级目录，下级目录在哪儿添加呢？</p><p><strong>再然后</strong>，导入一本书，编辑该书的元数据–&gt;自定义元数据，<br><img src="/img/calibre/6.png" alt="编辑元数据"></p><p>添加<code>这里是吃饭的.编程语言.python</code>。calibre中的层级关系使用点来表示，这个就会形成这样的目录结构：<br><img src="/img/calibre/7.png" alt="多级目录结构"></p><p>你可以同时批量编辑好多书的元数据，把它们放到同一个目录下。好吧，其他更快捷的办法我暂时没找到。</p><h1 id="2-筛选"><a href="#2-筛选" class="headerlink" title="2. 筛选"></a>2. 筛选</h1><p>点击某个具有下级分类的分类的时候，calibre会有4中筛选的方法，依次显示为：</p><p><img src="/img/calibre/8.png" alt="加号"><br><strong>加号</strong>：只显示该分组中的书籍。</p><p><img src="/img/calibre/9.png" alt="加加号"><br><strong>加加号</strong>：显示该分组及以下分组的所有书籍。</p><p><img src="/img/calibre/10.png" alt="减号"><br><strong>减号</strong>：显示除该分组外的所有书籍，包括该分组以下分组的。</p><p><img src="/img/calibre/11.png" alt="减减号"></p><p><strong>减减号</strong>：显示除该分组及该分组以下分组外的所有书籍。</p><h1 id="3-同步"><a href="#3-同步" class="headerlink" title="3. 同步"></a>3. 同步</h1><p>收集到这么多的书，肯定不想丢啊，那就全都放到谷歌硬盘(15G免费空间)上吧。直接把书库放到同步盘上就好了，到另外的环境安装个calibre，导入书库，就什么都一模一样了，简直绝配。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://calibre-ebook.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;calibre&lt;/a&gt;是一个电子书管理器，最好的，没有之一。而且免费。&lt;/p&gt;
&lt;p&gt;大概长这样：&lt;br&gt;&lt;img src=&quot;/img/calibre/1.png&quot; alt=&quot;界面预览&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>逻辑地址，线性地址，物理地址</title>
    <link href="http://suntus.github.io/2017/08/14/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"/>
    <id>http://suntus.github.io/2017/08/14/逻辑地址，线性地址，物理地址/</id>
    <published>2017-08-14T01:46:51.000Z</published>
    <updated>2018-01-09T07:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>。。。<br><a id="more"></a><br>首先，我们有1块物理内存，比如4G的DDR3，如果CPU想要找这个内存里边的一块区域存储的东西(0、1)，需要知道这块区域在哪里，最简单的就是把物理内存的一个个存储单元都编号，比如位置在最开头的就编号为0x00，接下来一个单元就编号0x01，…，这里每个单元都是1位，也就是只能存1个0或1个1，就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/280482-8bea53f7396c69e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>但是这样每一位都进行编号，整个地址编号就太多了，如果我们约定每8位编一个号，那整个地址就是原先的1/8，就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/280482-fb27017f9d421d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>为了方便，我们把每8位的一个单元叫做1个字节，0x00指向的就是物理内存中的第1个存储单元，也就是第1个字节，字节是物理内存的最小存储单元。如果想拿到第1个字节第3位中的数字1（标红的位置），那就需要把整个字节都先拿到，再去找里边的数字。</p><p>这里给物理内存编的1个号码就是1个物理地址，所有给物理内存编的号码就叫物理地址的地址空间。</p><p>CPU如果想拿到某个物理内存中的数字，需要发送一组电信号给物理内存芯片，芯片根据这组电信号查找相应地址，然后返回给CPU，这组电信号编码成数字就是物理地址了，就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/280482-99c05ac3dceedabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中CPU到内存控制芯片的这几根线叫地址线，比如常说的某个架构有20根地址线或者32根、36根地址线，就表明CPU可以寻址到的地址空间，比如32根地址线就可以最高寻址到2^32，也就是4G。我们这里画了4根，就可以寻址到2^4，也即是16个字节。</p><p>我们需要编写程序控制CPU进行逻辑处理、计算、存储等动作，当需要读写内存中的数据的时候，最简单的当然是用物理地址去指示CPU问内存控制芯片要哪个地址的数据了，比如：<br><img src="http://upload-images.jianshu.io/upload_images/280482-63214309b60c45e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们想要把0x00中的数据放到寄存器ax中，就把0x00这个地址给CPU，这就可以了，多简单。当然如果真的这么简单，大家都轻松了🙃。事实上，CPU为了能处理多任务，同时在一个任务中区分代码、数据、栈，就需要对内存进行划分，分别存放不同的内容，这样一是为了区分，二是为了保护（比如代码段不允许修改，某些数据只读）。先来想象一下可能的解决办法，我们的目的是想把一段处理逻辑控制在内存0x00~0x07这个段之间，让CPU在运行的时候不能超出这个内存范围去获取代码或数据，超过就要报错。一个简单的方法是设置一个标志位，该标志位表明指令中的地址都需要在0x00~0x07之间，不能超过。在指示0x08~0x15之间的内存的时候，再设置另一个标志位，起到同样的作用。这样就可以将整个内存分为2个段：0x00~0x07，0x08~0x15。每个段的长度是8个字节。每个段都设置一个标志位的方法有点儿笨，我们用每个段的首地址来表示这个段：0x00表示第1个段，0x08表示第2个段，再用跟段的首地址的偏移量来确认段内某个字节的地址。现在我们确定第1个段中第2个字节的地址就是0x00:1(第1个字节的地址是0)。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-7e0a876d7d50009e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>现在我们指令中用到的0x00:1就是逻辑地址，因为它在逻辑上将内存划分为了多个不同的段。我们要做的只是输入0x00:1这个地址，CPU会帮我们把逻辑地址翻译成0x01的物理地址🙂。</p><p>除了使用分段的方式划分内存外，还可以将物理内存直接划分为多个不同的页，称为页帧，一个物理页一般是4K大小，这样控制一页内的内存属性相同，多个不同的页可以使用不同的属性，就跟分段类似了，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-ad183344059e0d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这时候会出现个新问题：CPU已经使用逻辑地址来划分段了，如何去实现分页呢？其实肯定也想到了，在逻辑地址和物理地址之间加一个抽象层接口，也就是我们要说的最后一个地址：线性地址，也叫虚拟地址。线性地址的位置在逻辑地址和物理地址之间，比如在讲linux内核的书里边常见有这样的图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-e88812256a74ff18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>CPU将逻辑地址按照分段逻辑转换成线性地址，再按分页逻辑转换成物理地址。这里的转换都是依靠CPU电路完成的，但是怎样分段，怎样分页是需要内核程序先规定好才行。CPU怎样进行分段和分页的就不细说了，<a href="http://ilinuxkernel.com/?p=1276" target="_blank" rel="noopener">这里</a>讲的真好，可以去看看。<br>我们来对比一下分段和分页：</p><table><thead><tr><th></th><th>分段</th><th>分页</th></tr></thead><tbody><tr><td>目的</td><td>将内存按照不同的属性分隔，实现隔离和保护</td><td>将内存按照不同的属性分隔，实现隔离和保护</td></tr><tr><td>对象</td><td>对线性地址进行分隔</td><td>对物理页帧进行分隔</td></tr><tr><td>方法</td><td>使用逻辑地址（段基址:偏移）分隔不同的段</td><td>将线性地址分隔成不同的部分，一步步去寻找页对应的物理页帧，进而找到对应的物理地址</td></tr><tr><td>程序需要事先做好的准备</td><td>准备好GDT,LDT,IDT，也就是个个不同的段</td><td>准备好页目录，页表，也就是各个不同的页</td></tr><tr><td>大小</td><td>段大小可变，程序控制</td><td>页大小固定的几个值，4K,4M,2M，CPU规定好的</td></tr></tbody></table><p>好了，现在我们的CPU中地址关系如下：<br><img src="http://upload-images.jianshu.io/upload_images/280482-947492f9b5636b64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>看上去很复杂吧，其实理解了就没那么多东西，我画画的水平有限😅。</p><p>有个问题很多人都想知道，我一开始看内存这部分的时候也很着急：linux用户程序里边用的是什么地址？我先说答案：是逻辑地址。但很多书里边讲linux虚拟内存的分布，跟程序里用到的地址是一模一样的啊？其实linux用户程序中的地址是逻辑地址中的偏移，只不过linux把所有段的基址都设为0，这样段内偏移就跟线性地址一样了（因为段基址都是0啊，段偏移加上0还是段偏移）。为什么linux要把所有段基址都设为0呢？其实分段和分页都是对内存的分隔和保护，从用途上来说是重复的，分页更简单些，所有linux就只用了分页来实现内存保护。</p><p>还有另一个问题：linux中用户进程看到的内存都是一样的，0~4G，这是如何实现的？答案是基于分页，linux给每个进程都维护一个分页映射规则，每个分页规则对应一种线性地址到物理地址的映射，这样每个进程看到的都是同样的线性地址，但是后边对应的物理地址各不相同。</p><p>内存管理是linux内核中最复杂的系统之一，除了逻辑地址到线性地址再到物理地址的映射外，还有很多其他的特性辅助操作系统对物理内存实现管理，比如分段逻辑实现时用到的GDT、LDT、IDT、TSS、6个段寄存器，分页逻辑实现时用到的页目录、页表、页帧、CR3、PAE，CPU和物理内存之间的高速缓存等。骨架已经理清楚了，其他的理解就慢慢往里加吧。</p><hr><p>参考：</p><ol><li><a href="http://ilinuxkernel.com/?p=1276，讲linux内核的大牛，思路清晰，文笔优美。" target="_blank" rel="noopener">http://ilinuxkernel.com/?p=1276，讲linux内核的大牛，思路清晰，文笔优美。</a></li><li>《Linux内核设计与实现》Robert Love，极好的内核入门书。</li><li>《深入Linux内核架构》(德)Wolfgang.Mauerer，深入细节1。</li><li>《Understanding the Linux Kernel 》3rd_Edition，Daniel P. Bovet and Marco Cesati，深入细节2。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;。。。&lt;br&gt;
    
    </summary>
    
    
      <category term="os" scheme="http://suntus.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>《题龙阳县青草湖》  ——唐温如</title>
    <link href="http://suntus.github.io/2017/08/12/%E3%80%8A%E9%A2%98%E9%BE%99%E9%98%B3%E5%8E%BF%E9%9D%92%E8%8D%89%E6%B9%96%E3%80%8B%E2%80%94%E2%80%94%E5%94%90%E6%B8%A9%E5%A6%82/"/>
    <id>http://suntus.github.io/2017/08/12/《题龙阳县青草湖》——唐温如/</id>
    <published>2017-08-12T15:03:43.000Z</published>
    <updated>2017-09-02T08:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>西风垂老洞庭波，<br>一夜湘君白发多。<br>醉后不知天在水，<br>满船清梦压星河。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;西风垂老洞庭波，&lt;br&gt;一夜湘君白发多。&lt;br&gt;醉后不知天在水，&lt;br&gt;满船清梦压星河。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读过的书" scheme="http://suntus.github.io/tags/%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>IA32常用寄存器</title>
    <link href="http://suntus.github.io/2017/08/12/IA32%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://suntus.github.io/2017/08/12/IA32常用寄存器/</id>
    <published>2017-08-12T14:51:33.000Z</published>
    <updated>2017-08-12T14:58:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>看内核之前需要了解一些体系结构相关的知识，本文介绍IA32常用的几个寄存器。<a id="more"></a></p><ul><li>通用寄存器：EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP</li><li>段寄存器：CS,DS,ES,FS,GS,SS</li><li>EFLAGES寄存器</li><li>EIP寄存器</li><li>控制寄存器：CR0,CR1,CR2,CR3,CR4</li><li>GDTR,LDTR,IDTR寄存器</li><li>TR寄存器</li></ul><hr><h2 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1. 通用寄存器"></a>1. 通用寄存器</h2><p>用于存放：<br>　　1. 算数和逻辑操作的操作数<br>　　2. 地址操作的操作数<br>　　3. 内存指针<br>这些寄存器通常可以存放任何东西，但有时候会用作特定用途，比如：<br>　　<strong>EAX</strong>——存放累加操作数和结果，传递参数和结果等<br>　　<strong>EBX</strong>——指向DS数据段中数据的指针<br>　　<strong>ECX</strong>——字符串和循环操作的计数器<br>　　<strong>EDX</strong>——I/O指针<br>　　<strong>ESI</strong>——指向DS数据段中数据的指针；字符串操作的源指针<br>　　<strong>EDI</strong>——跟ES配合，指向目的数据的指针；字符串操作的目的指针<br>　　<strong>ESP</strong>——栈指针（在SS段中）<br>　　<strong>EBP</strong>——指向栈中的数据（SS段中），一般用作函数嵌套调用时的栈帧基址</p><h2 id="2-段寄存器"><a href="#2-段寄存器" class="headerlink" title="2. 段寄存器"></a>2. 段寄存器</h2><p>当用平坦内存模型(flat memory model)的时候，段寄存器都指向0，不分段。<br>当用段内存模型(segmented memory model)的时候，段寄存器指向各自的段，且有CPU的保护机制。<br>保护模式下(段内存模型)：<br>　　<strong>CS</strong>：保存当前指向代码段的段选择子，配合EIP，可以找到下一个要执行的代码。<br>　　<strong>DS,ES,FS,GS</strong>：保存四个数据段的段选择子，可以让当前任务同时获取四个数据段，比如一个指向当前特权级的数据段，另一个指向更高特权级的数据段，第三个指向动态创建的数据结构，第四个指向跟另一个程序共享的数据段。<br>　　<strong>SS</strong>：保存当前栈的段选择子。<br>段寄存器中保存着段选择子，根据该选择子可以选择GDTR(或LDTR)指向的GDT(或LDT)表中的某一项（段描述符），然后根据该项可以找到相应的段（选择的时候CPU可以进行权限检查等）。如果CPU每次都从段寄存器拿到段选择子，再根据GDTR找到相应的项，再找到段就太麻烦了，所以这几个段寄存器都有个隐藏的寄存器，不暴露给开发人员，只是CPU内部使用的，用于缓存段地址，加快处理速度。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-ffec51fb130990cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="段寄存器"></p><h2 id="3-EFLAGS"><a href="#3-EFLAGS" class="headerlink" title="3. EFLAGS"></a>3. EFLAGS</h2><p>　　存储CPU的一些内部状态。<br><img src="http://upload-images.jianshu.io/upload_images/280482-e00572d62610c5ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EFLAGS寄存器"></p><h2 id="4-EIP寄存器"><a href="#4-EIP寄存器" class="headerlink" title="4. EIP寄存器"></a>4. EIP寄存器</h2><p>　　用于存放下一个要执行的代码的地址，非常重要，通过特定的指令（JMP,Jcc,CALL,RET,IRET）可以改变值，不能被直接读取，只能在call调用的时候从栈中读取，可以直接赋值，然后用RET或IRET跳转（内核用于向高特权级翻转）。</p><h2 id="5-控制寄存器"><a href="#5-控制寄存器" class="headerlink" title="5. 控制寄存器"></a>5. 控制寄存器</h2><p><img src="http://upload-images.jianshu.io/upload_images/280482-e5b7ac1693891e48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制寄存器"><br>CR0——包含控制处理器操作模式和状态的标志<br>CR1——保留<br>CR2——包含缺页中断时的线性地址<br>CR3——包含分页的第一层结构的基址和两个标志位（PCD,PWT）<br>CR4——包含一些架构扩展，指定特定的处理器兼容。<br>一些位解释如下：<br>PG： Paging，是否分页<br>CD：Cache Disable，是否使用物理缓存<br>PE：Protection Enable，打开保护模式，该标志位不会启动分页，只会启动基于段的保护（分页和段都是保护，其实是重复的，linux只用了分页保护）。</p><h2 id="6-GDTR-LDTR-IDTR"><a href="#6-GDTR-LDTR-IDTR" class="headerlink" title="6. GDTR,LDTR,IDTR"></a>6. GDTR,LDTR,IDTR</h2><p>存放GDT,LDT,IDT的基址。</p><p><strong>GDT</strong>：Global Descriptor Table，全局描述符表，存放全局的段描述符的数组，只有1份，通过该表可以找到所有的段，也只有通过该表才能实现处理器基于段的保护。</p><p><strong>LDT</strong>：Local Descriptor Table，局部描述符表，存放局部的段描述符的数组，可以有多份，当前的LDT基址存放在LDTR中。另外，每一份LDT都要在GDT中有一个描述符（说明一个LDT本身也是内存中的一个段）。通过LDT可以获取当前任务的相关段。</p><p><strong>IDT</strong>：Interrupt Descriptor Table，中断描述符，存放处理器的各个中断的地方。</p><h2 id="7-TR寄存器"><a href="#7-TR寄存器" class="headerlink" title="7. TR寄存器"></a>7. TR寄存器</h2><p>存放当前TSS的基址。<br>CPU处理多任务的时候，需要在各个任务之间切换，保存当前任务状态，加载下一个任务的状态，然后执行下一个任务，状态保存在多个地方，其中栈的相关信息保存在TSS中。</p><hr><p>参考：</p><ol><li>《Intel® 64 and IA-32 Architectures Software Developer’s Manual<br>Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4》</li><li>《Understanding the Linux Kernel 3rd Edition》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看内核之前需要了解一些体系结构相关的知识，本文介绍IA32常用的几个寄存器。
    
    </summary>
    
    
      <category term="os" scheme="http://suntus.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>《Orange&#39;s：一个操作系统的实现》</title>
    <link href="http://suntus.github.io/2017/08/12/%E3%80%8AOrange-s%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    <id>http://suntus.github.io/2017/08/12/《Orange-s：一个操作系统的实现》/</id>
    <published>2017-08-12T14:47:23.000Z</published>
    <updated>2018-01-09T07:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　真的是挺好的一本书，从最基础的boot一直讲到进程调度、文件系统、内存管理，最最重要的是每一步都能自己动手实践，不止理解了概念，还对过程有了自己的感性认识，这是别的操作系统书里很难有的。<a id="more"></a><br>　　经过这些，对计算机如何工作理解的更深刻了。CPU从硬盘中将文件读入到内存，数据和代码都存在在内存，因为涉及到保护之类的，这些内容按段分布，代码控制CPU的逻辑流向。中断让CPU能更及时且准确的处理外来任务。<br>　　学习操作系统最大的感受，一个是CPU如何跟各个外设进行交互，另一个就是事无巨细都要一点点去实现，要对整个系统完全掌控才心里有底。<br>　　目前我觉得学习操作系统的顺序应该是了解其中的几个基本概念：文件系统、内存管理、进程调度、中断机制，然后开始从boot了解，一步步串起来，才会在整个过程中不那么艰难，看完其实操作系统也就那么回事儿了。<br> 　　这是对里边涉及到的一些概念的印象，还有待充实。<br><img src="http://upload-images.jianshu.io/upload_images/280482-23c52d7b89998330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Orange&#39;s：一个操作系统的实现"></p><hr><ol><li>IA32 CPU的数据总体结构：<br><img src="http://upload-images.jianshu.io/upload_images/280482-23ffe6a8354e95a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU的数据结构"></li><li>GDT的作用是用来提供段式存储机制，这种机制是通过段寄存器和GDT中的描述符共同提供的。</li><li>描述符的种类：<ul><li>代码段描述符</li><li>数据段描述符</li><li>系统段描述符</li><li>门描述符</li></ul></li><li>IA32的分段机制中，特权级共有4个级别，从高到低分别是0，1，2，3。数字越小表示的特权级越大</li><li><p>处理器通过识别CPL,DPL,RPL这3中特权级进行特权级检验<br><strong>CPL: current privilege level</strong>，当前执行的程序或任务的特权级。存储在cs和ss的第0位和第1位上。通常，CPL等于代码所在的段的特权级，当程序转移到不同特权级的代码段时，处理器将改变CPL。一致代码段可以被相同或者更低特权级的代码访问。当处理器访问一个与CPL特权级不同的一致代码段时，CPL不会被改变。<br><strong>RPL: requested privilege level</strong>.存储在段选择子的第0和第1位。处理器通过检查RPL和CPL来确认一个访问请求是否合法。RPL占主导。<br><strong>DPL: descriptor privilege level</strong>，表示段或者门的特权级。存储在段或门描述符的DPL字段。当当前代码段试图访问一个段或门时，DPL将会和CPL以及段或门选择子的RPL相比较，根据段或门类型的不同，DPL将会被区别对待：</p><ul><li>数据段：DPL规定了可以访问此段的最低特权级。</li><li>非一致代码段（不使用调用门的情况下）：DPL规定访问此段的特权级。比如，一个非一致代码段的特权级为0，那么只有CPL为0的程序才能访问它。</li><li>调用门：DPL规定了当前执行的程序或者任务可以访问此调用门的最低特权级。</li><li>一致代码段和通过调用门访问的非一致代码段：DPL规定了访问此段的最高特权级。比如一个一致代码段的DPL是2，那么CPL为0和1的程序将无法访问此段。</li><li>TSS: DPL规定了可以访问此TSS的最低特权级。</li></ul></li><li><p>程序控制转移的发生：<code>jmp, call, ret, sysenter, sysexit, int n, iret</code>，或者中断、异常 </p></li><li>jmp、call指令可以实现4种转移：<ul><li>目标操作数包含目标代码段的段选择子</li><li>目标操作数指向一个包含目标代码段选择子的调用门描述符 </li><li>目标操作数指向一个包含目标代码段选择子的TSS</li><li>目标操作数指向一个任务门，这个任务门指向一个包含目标代码段选择子的TSS</li></ul></li><li>门描述符种类<ul><li>调用门 (call gates)</li><li>中断门（interrupt gates）</li><li>陷阱门（trap gates）</li><li>任务门（task gates）</li></ul></li><li>每个任务最多可能在4个特权级间转移，所以每个任务实际上需要4个堆栈，这时候需要TSS（task-state stack）来存储。</li><li>8259A芯片用于处理外部中断，可设置优先级，可屏蔽</li><li><img src="http://upload-images.jianshu.io/upload_images/280482-004fd591f38e870e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一致代码段说明"><ul><li>一致代码段是给低特权级执行高特权级代码提供的一条通道，没有这条通道，从低到高或者反过来都不能执行</li><li>数据段都是非一致的，但是高的可以无条件访问低的数据段</li></ul></li><li>系统一开始进入的是0，也就是最高特权级，往特权级低的方向移动使用ret，往高处移动使用call，一个任务最多会用到4个特权级，而TSS只是在低特权级到高特权级移动的时候才会用到，所以TSS只会保存前三个。</li><li>分页是CPU提供的功能，使用两个东西，PDE和PTE，一个PDE和相应的PTE组成一套对应关系，说明一种线性地址和物理地址的对应关系。逻辑地址到线性地址用到的是分段机制。<br>线性地址提供的相当于一个胶水层，将上层应用（程序使用的逻辑地址）跟下层物理实现（CPU提供的物理地址）分割开来<br><img src="http://upload-images.jianshu.io/upload_images/280482-e3d92c595409a785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分页地址转换"><br>因为有多套不同的（PDE，PTE），所以形同的线性地址可能就对应不同的物理地址，这也就是常说的操作系统提供的统一内存空间。</li><li>IDT的作用是将每一个中断向量和描述符对应起来。</li><li>C调用约定：后面的参数先入栈，调用者负责清理堆栈。在处理可变参数时C调用约定表现良好，因为只有调用者知道此次调用包含了几个参数，于是可以方便清理堆栈</li><li>用到的芯片<ul><li><strong>8259A</strong>：处理中断</li><li><strong>8253</strong>：PIT（programmable interval timer），可编程定时器</li></ul></li><li>敲击键盘有两方面的含义：动作和内容。动作：按下、保持按住的状态、放开；内容：字母键、数字键、回车和其他键。</li><li>tty设备跟普通文件的不同：1.怎样才算“输入结束”，是每次键盘敲击之后都算结束，还是等回车才算结束，或者其他；2. 是否要让文件系统等待输入过程结束。</li></ol><hr><p>于渊</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　真的是挺好的一本书，从最基础的boot一直讲到进程调度、文件系统、内存管理，最最重要的是每一步都能自己动手实践，不止理解了概念，还对过程有了自己的感性认识，这是别的操作系统书里很难有的。
    
    </summary>
    
    
      <category term="os" scheme="http://suntus.github.io/tags/os/"/>
    
      <category term="读过的书" scheme="http://suntus.github.io/tags/%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/"/>
    
  </entry>
  
</feed>
