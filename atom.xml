<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morning~Sun。</title>
  
  <subtitle>ha</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suntus.github.io/"/>
  <updated>2020-04-24T11:59:38.527Z</updated>
  <id>http://suntus.github.io/</id>
  
  <author>
    <name>suntus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>printf族</title>
    <link href="http://suntus.github.io/2020/04/24/printf%E6%97%8F/"/>
    <id>http://suntus.github.io/2020/04/24/printf族/</id>
    <published>2020-04-24T11:59:14.000Z</published>
    <updated>2020-04-24T11:59:38.527Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>不带<code>v</code>的处理不定长参数(见<a href="/2020/03/20/不定长参数/" title="不定长参数">不定长参数</a>，处理完<code>ap</code>参数就变得不再确定了)，带<code>v</code>处理固定参数。</p><p>带<code>n</code>写最多<code>size</code>字节到<code>str</code>中(包括结尾的<code>&#39;\0&#39;</code>)。</p><p>成功就返回写出去的字节数(包括结尾的<code>&#39;\0&#39;</code>)。带<code>n</code>的需要注意，<strong>返回值表示能够装下输出结果的大小，也就是说，如果返回值大于<code>size</code>，说明输出结果被截断了，只输出了<code>size</code>大小——不包括<code>&#39;\0&#39;</code></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, ...)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FILE *stream, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, ...)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, ...)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;snprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, ...)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdarg.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;vprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, va_list ap)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;vfprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FILE *stream, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, va_list ap)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;vsprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, va_list ap)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;vsnprintf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; size, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *format, va_list ap)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>用到的hexo</title>
    <link href="http://suntus.github.io/2020/04/24/%E7%94%A8%E5%88%B0%E7%9A%84hexo/"/>
    <id>http://suntus.github.io/2020/04/24/用到的hexo/</id>
    <published>2020-04-24T11:29:06.000Z</published>
    <updated>2020-04-24T11:59:38.541Z</updated>
    
    <content type="html"><![CDATA[<p>用到的一些零碎东西</p><a id="more"></a><h1 id="1-图片链接"><a href="#1-图片链接" class="headerlink" title="1. 图片链接"></a>1. 图片链接</h1><p>简单的格式：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">这里是图片示例</span>](<span class="link">/img/calibre/1.png</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/img/calibre/1.png" alt="这里是图片示例"></p><h1 id="2-站内链接"><a href="#2-站内链接" class="headerlink" title="2. 站内链接"></a>2. 站内链接</h1><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">post_link</span> ticket相关%&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><a href="/2020/03/14/ticket相关/" title="ticket相关">ticket相关</a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用到的一些零碎东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="tool" scheme="http://suntus.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>不定长参数</title>
    <link href="http://suntus.github.io/2020/03/20/%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0/"/>
    <id>http://suntus.github.io/2020/03/20/不定长参数/</id>
    <published>2020-03-20T12:37:04.000Z</published>
    <updated>2020-04-24T11:59:38.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>使用特定函数操作不定长列表，初始化——操作——结束。<br><a id="more"></a></p><h1 id="2-具体"><a href="#2-具体" class="headerlink" title="2. 具体"></a>2. 具体</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdarg.h&gt;</span></span><br><span class="line">void va_start(va_list ap, last);</span><br><span class="line">type va_arg(va_list ap, type);</span><br><span class="line">void va_end(va_list ap);</span><br><span class="line">void va_copy(va_list dest, va_list src);</span><br></pre></td></tr></table></figure><ul><li><code>va_start()</code>：初始化不定长参数列表类型<code>ap</code>，<code>last</code>是不定长参数<code>...</code>之前挨着的一个已知类型参数。<code>ap</code>是自己声明的一个变量。必须在所有要用到<code>ap</code>的函数之前调用该函数。</li><li><code>va_arg()</code>: 从<code>ap</code>中<strong>依次</strong>取出相应的参数。应用需要从另外的地方知道不定参数的个数，比如<code>printf()</code>中的格式化字符串。如果下一个没有参数了，会返回随机错误。</li><li><code>va_copy()</code>: 将<code>src</code>的不定参数列表复制到<code>dest</code>中，但要注意，不同系统实现方式不同，不要直接自己去操作<code>ap</code>列表，需要调用这些特定函数去操作。</li><li><code>va_end()</code>：最后结束了必须要调用这个。可以多次顺序调用<code>va_start()</code>和<code>va_end()</code>，但必须成对儿。</li></ul><p>man给出的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">foo(<span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">char</span> c, *s;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    <span class="keyword">while</span> (*fmt)</span><br><span class="line">        <span class="keyword">switch</span> (*fmt++) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:              <span class="comment">/* string */</span></span><br><span class="line">            s = va_arg(ap, <span class="keyword">char</span> *);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"string %s\n"</span>, s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:              <span class="comment">/* int */</span></span><br><span class="line">            d = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"int %d\n"</span>, d);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>:              <span class="comment">/* char */</span></span><br><span class="line">            <span class="comment">/* need a cast here since va_arg only</span></span><br><span class="line"><span class="comment">                takes fully promoted types */</span></span><br><span class="line">            c = (<span class="keyword">char</span>) va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"char %c\n"</span>, c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h1><ol><li>linux man手册</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;使用特定函数操作不定长列表，初始化——操作——结束。&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>PSK相关</title>
    <link href="http://suntus.github.io/2020/03/20/PSK%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2020/03/20/PSK相关/</id>
    <published>2020-03-20T12:20:03.000Z</published>
    <updated>2020-04-24T11:59:38.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么"><a href="#1-为什么" class="headerlink" title="1. 为什么"></a>1. 为什么</h1><p>TLS通常用证书体系(PKI)进行认证，先回顾一下传统的RSA证书认证过程，</p><ol><li>server发送证书给client, 证书中包含RSA的公钥，只有server有证书中公钥对应的私钥;</li><li>client收到证书后，对证书进行校验(PKI体系一层层往CA验证，直到根CA)，校验通过后，用证书中的公钥对预主密钥(client每次随机生成)进行加密，将加密后的数据发送给server；</li><li>只有server能解密数据，取出其中的预主密钥。这样，server和client之间就有了共同的秘钥，可以用于后续的加密了。<a id="more"></a>这里的关键是只有server有对应的RSA私钥，然后server的RSA公钥可以由信任的根CA一层层校验，这样，client就可以认为它正在通信的对方是自己想要通信的server。server对client进行的过程认证基本一样。</li></ol><p>但使用证书有几个问题：</p><ol><li>证书需要非对称算法，不管是RSA还是ECC，加密相同强度都比对称算法慢；</li><li>证书的PKI体系部署管理比较麻烦，需要根CA、子CA、server证书、证书私钥，client证书等；</li><li>认证过程需要发送证书，证书通常比较大，需要传输时间比较长。</li></ol><p>所以，PSK就解决这样的问题:</p><ol><li>PSK可以只需要对称算法，不使用非对称算法；</li><li>PSK在可控的封闭环境中容易部署；如果应用使用其他办法能生成一个共享的秘钥，PSK就可以用该秘钥建立TLS连接了;</li><li>认证时PSK可以传输较小的数据量。</li></ol><h1 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2. 是什么"></a>2. 是什么</h1><p>PSK——pre-shared key，预共享密钥——就是通信双方使用提前部署好的预共享密钥(用于对称算法)建立TLS连接的机制。</p><p>PSK的主要逻辑是：</p><ol><li>分别在client和server部署相同的对称加密秘钥(<code>psk_key</code>)；</li><li>每个<code>psk_key</code>对应有一个<code>psk_id</code>， client发送该<code>psk_id</code>给server,server通过<code>psk_id</code>查找对应的<code>psk_key</code>，如果查到，就用该<code>psk_key</code>去直接加密后续的数据，不再进行非对称加密。</li></ol><h1 id="3-TLS1-2及之前的PSK"><a href="#3-TLS1-2及之前的PSK" class="headerlink" title="3. TLS1.2及之前的PSK"></a>3. TLS1.2及之前的PSK</h1><p>PSK机制需要使用加密套件来确定是否使用PSK机制。<br>最开始的3组加密套件为:<br>| ciphersuite                       | key exchange | cipher       | hash |<br>|—————————————————-|———————|———————|———|<br>| TLS_PSK_WITH_RC4_128_SHA          | PSK          | RC4_128      | SHA  |<br>| TLS_PSK_WITH_3DES_EDE_CBC_SHA     | PSK          | 3DES_EDE_CBC | SHA  |<br>| TLS_PSK_WITH_AES_128_CBC_SHA      | PSK          | AES_128_CBC  | SHA  |<br>| TLS_PSK_WITH_AES_256_CBC_SHA      | PSK          | AES_256_CBC  | SHA  |<br>| TLS_DHE_PSK_WITH_RC4_128_SHA      | DHE_PSK      | RC4_128      | SHA  |<br>| TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA | DHE_PSK      | 3DES_EDE_CBC | SHA  |<br>| TLS_DHE_PSK_WITH_AES_128_CBC_SHA  | DHE_PSK      | AES_128_CBC  | SHA  |<br>| TLS_DHE_PSK_WITH_AES_256_CBC_SHA  | DHE_PSK      | AES_256_CBC  | SHA  |<br>| TLS_RSA_PSK_WITH_RC4_128_SHA      | RSA_PSK      | RC4_128      | SHA  |<br>| TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA | RSA_PSK      | 3DES_EDE_CBC | SHA  |<br>| TLS_RSA_PSK_WITH_AES_128_CBC_SHA  | RSA_PSK      | AES_128_CBC  | SHA  |<br>| TLS_RSA_PSK_WITH_AES_256_CBC_SHA  | RSA_PSK      | AES_256_CBC  | SHA  |</p><p>是按照秘钥交换算法进行的分组，分别为<code>PSK, DHE_PSK, RSA_PSK</code>。</p><ul><li><code>PSK</code>是只是用对称加密算法，适合要求性能的地方；</li><li><code>DHE_PSK</code>同时使用PSK和DHE算法，可以抵御字典攻击，也提供前向安全性；</li><li><code>RSA_PSK</code>同时使用PSK和RSA算(还是使用RSA证书)，可以提供额外的认证。</li></ul><p>不同的秘钥交换算法使用的握手消息不太一样，下面分别详细说明。</p><h2 id="3-1-PSK"><a href="#3-1-PSK" class="headerlink" title="3.1. PSK"></a>3.1. <code>PSK</code></h2><p>使用单独的PSK(<code>plain PSK</code>)进行协商的主要步骤如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Client                              Server</span><br><span class="line">------                              ------</span><br><span class="line">ClientHello       --------&gt;</span><br><span class="line">                                ServerHello</span><br><span class="line">                                (Certificate)</span><br><span class="line">                                ServerKeyExchange*</span><br><span class="line">                                (CertificateRequest)</span><br><span class="line">                  &lt;--------     ServerHelloDone</span><br><span class="line">(Certificate)</span><br><span class="line">ClientKeyExchange</span><br><span class="line">(CertificateVerify)</span><br><span class="line">ChangeCipherSpec</span><br><span class="line">Finished          --------&gt;</span><br><span class="line">                                ChangeCipherSpec</span><br><span class="line">                  &lt;--------     Finished</span><br><span class="line">Application Data  &lt;-------&gt;     Application Data</span><br></pre></td></tr></table></figure></p><ol><li>client如果希望使用PSK进行握手，就在<code>CH</code>中加入PSK加密套件发送给server;</li><li>server如果也希望使用PSK，就在<code>SH</code>中回复相应的PSK加密套件；</li><li>server不再发送<code>Certificate</code>和<code>CertificateRequest</code>，因为这时候不需要证书了；</li><li>client和server都可能有多组<code>psk_key</code>，server可以在<code>SKE</code>中发送一个<code>psk identity hint</code>的东西(类似索引之类的)帮助client去选择相应的<code>psk_key</code>；如果没有<code>psk identity hint</code>，就不发送<code>SKE</code>了；</li><li>client把希望使用的<code>psk_key</code>对应的<code>psk_id</code>放到<code>CKE</code>中，发送给server;</li><li>server收到<code>CKE</code>后，根据其中的<code>psk_id</code>选择相应的<code>psk_key</code>，然后将<code>psk_key</code>当做预主密钥(pre master secret)进行后续的秘钥推导；</li></ol><p>相关的消息格式:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">    <span class="comment">/* other cases for rsa, diffie_hellman, etc. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> psk: <span class="comment">/* NEW */</span></span><br><span class="line">        opaque psk_identity_hint&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ServerKeyExchange;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">    <span class="comment">/* other cases for rsa, diffie_hellman, etc. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> psk: <span class="comment">/* NEW */</span></span><br><span class="line">        opaque psk_identity&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    &#125; exchange_keys;</span><br><span class="line">&#125; ClientKeyExchange;</span><br></pre></td></tr></table></figure></p><h2 id="3-2-DHE-PSK"><a href="#3-2-DHE-PSK" class="headerlink" title="3.2. DHE_PSK"></a>3.2. <code>DHE_PSK</code></h2><p>协商的步骤跟<code>plain PSK</code>大体一致，其中：<br>\4. server不管有没有<code>psk identity hint</code>，都需要发送<code>SKE</code>，其中一定要包含server的DH秘钥交换参数；<br>\5. client把希望使用的<code>psk_key</code>对应的<code>psk_id</code>放到<code>CKE</code>中，并将client的DH秘钥交换参数一并放入发送给server;<br>\6. server收到<code>CKE</code>后，根据其中的<code>psk_id</code>选择相应的<code>psk_key</code>，并使用收到的DH参数生成DH的共享秘钥，然后跟<code>psk_key</code>一起构建出预主密钥(pre master secret)进行后续的秘钥推导；</p><p>并且消息格式有差别：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">    <span class="comment">/* other cases for rsa, diffie_hellman, etc. */</span></span><br><span class="line"></span><br><span class="line">    case <span class="keyword">diffie_hellman_psk: </span><span class="comment">/* NEW */</span></span><br><span class="line">        opaque psk_identity_hint&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">        ServerDHParams params<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125; ServerKeyExchange<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">    <span class="comment">/* other cases for rsa, diffie_hellman, etc. */</span></span><br><span class="line"></span><br><span class="line">    case <span class="keyword">diffie_hellman_psk: </span><span class="comment">/* NEW */</span></span><br><span class="line">        opaque psk_identity&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">        ClientDiffieHellmanPublic public<span class="comment">;</span></span><br><span class="line">    &#125; exchange_keys<span class="comment">;</span></span><br><span class="line">&#125; ClientKeyExchange<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li><p><code>ServerDHParams</code>：保存的是server临时生成的DH公开参数(其中<code>dh_Ys</code>相当于server的公钥)。格式为:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    opaque dh_p&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    opaque dh_g&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    opaque dh_Ys&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">&#125; ServerDHParams; <span class="comment">/* Ephemeral DH parameters */</span></span><br></pre></td></tr></table></figure></li><li><p><code>ClientDiffieHellmanPublic</code>: client生成的DH公开参数(其中<code>dh_Yc</code>相当于client的公钥),格式为:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    <span class="keyword">select</span> (PublicValueEncoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">implicit</span>:</span><br><span class="line">        struct &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> explicit:</span><br><span class="line">        opaque dh_Yc&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;;</span><br><span class="line">    &#125; dh_public;</span><br><span class="line">&#125; ClientDiffieHellmanPublic;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-RSA-PSK"><a href="#3-3-RSA-PSK" class="headerlink" title="3.3. RSA_PSK"></a>3.3. <code>RSA_PSK</code></h2><p>协商的步骤跟<code>plain PSK</code>大体一致，其中：<br>\3. server需要发送包含RSA证书的<code>Certificate</code>；<br>\5. client把希望使用的<code>psk_key</code>对应的<code>psk_id</code>放到<code>CKE</code>中，并生成一串随机数<code>secret</code>，用serve证书中的公钥加密，一并发送给server;<br>\6. server收到<code>CKE</code>后，根据其中的<code>psk_id</code>选择相应的<code>psk_key</code>，并使用RSA私钥对其中的加密数据解密，得到一个跟client共享的秘钥，然后跟<code>psk_key</code>一起构建出预主密钥(pre master secret)进行后续的秘钥推导；</p><p>消息格式为：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">    <span class="comment">/* other cases for rsa, diffie_hellman, etc. */</span></span><br><span class="line"></span><br><span class="line">    case rsa_psk: <span class="comment">/* NEW */</span></span><br><span class="line">        opaque psk_identity_hint&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125; ServerKeyExchange<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">    <span class="comment">/* other cases for rsa, diffie_hellman, etc. */</span></span><br><span class="line"></span><br><span class="line">    case rsa_psk: <span class="comment">/* NEW */</span></span><br><span class="line">        opaque psk_identity&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">        EncryptedPreMasterSecret<span class="comment">;</span></span><br><span class="line">    &#125; exchange_keys<span class="comment">;</span></span><br><span class="line">&#125; ClientKeyExchange<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>其中<code>EncryptedPreMasterSecret</code>格式见<code>rfc2246-tls1.0</code>。</p><h2 id="3-4-使用PSK构建预主密钥"><a href="#3-4-使用PSK构建预主密钥" class="headerlink" title="3.4. 使用PSK构建预主密钥"></a>3.4. 使用PSK构建预主密钥</h2><p>使用PSK构建预主密钥的通用格式为:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    opaque other_secret&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    opaque psk&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中<code>psk</code>就是根据<code>psk_id</code>查找出来的对应的<code>psk_key</code>，而<code>other_secret</code>是根据不同的秘钥交换算法而定的：</p><ul><li><code>PSK</code>: 跟psk相同长度的0字节串；</li><li><code>DHE_PSK</code>: client和server使用DH交换参数生成了共享秘钥<code>Z</code>，去掉<code>Z</code>的前导0，将其填入<code>other_secret</code>中；</li><li><code>RSA_PSK</code>: client生成的随机secret，用RSA公钥加密后发送给server，这样就得出了共享秘钥，将其填入<code>other_secret</code>中。</li></ul><h1 id="4-TLS1-3的PSK"><a href="#4-TLS1-3的PSK" class="headerlink" title="4. TLS1.3的PSK"></a>4. TLS1.3的PSK</h1><p>TLS1.3的PSK机制改变很大，虽然也有一部分之前TLS版本的PSK的功能，但还整合了其他功能：</p><ol><li>TLS1.2的PSK相当于外部导入PSK机制，用户预先在client和server部署<code>psk_key</code>(手动部署或使用其他秘钥交换算法进行)。TLS1.3也保留了这部分功能，支持外部导入；</li><li>TLS1.2使用的session ID(server有状态)和ticket(server无状态)的会话恢复机制，现在统一整合到PSK中，这时候相当于<code>psk_key</code>从上次完整会话中生成。</li><li>PSK还用于支持TLS1.3特有的<code>0-RTT</code>早期数据，通过牺牲前向安全性，来在client发起连接时，使用PSK的<code>psk_key</code>直接加密用户数据，发给server，server可以直接使用查找得到的<code>psk_key</code>解密数据。加快应用数据的交换过程。</li></ol><p>用于不同目的的PSK在细节处有些不一样，下面分别说明。</p><h2 id="4-1-外部导入PSK"><a href="#4-1-外部导入PSK" class="headerlink" title="4.1. 外部导入PSK"></a>4.1. 外部导入PSK</h2><h3 id="4-1-1-协商过程"><a href="#4-1-1-协商过程" class="headerlink" title="4.1.1 协商过程"></a>4.1.1 协商过程</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">client                                      server</span><br><span class="line">ClientHello</span><br><span class="line">    + key_share*</span><br><span class="line">    + psk_key_exchange_modes</span><br><span class="line">    + pre_shared_key        --------&gt;</span><br><span class="line">                                            ServerHello</span><br><span class="line">                                                + pre_shared_key</span><br><span class="line">                                                + key_share*</span><br><span class="line">                                            &#123;EncryptedExtensions&#125;</span><br><span class="line">                                            &#123;Finished&#125;</span><br><span class="line">                            &lt;--------       [Application Data*]</span><br><span class="line">&#123;Finished&#125;                  --------&gt;</span><br><span class="line"></span><br><span class="line">[Application Data]          &lt;-------&gt;       [Application Data]</span><br></pre></td></tr></table></figure><ol><li>client如果希望使用PSK进行握手，就在<code>CH</code>中加入<code>psk_key_exchange_modes</code>和<code>pre_shared_key</code>扩展项，其中<code>psk_key_exchange</code>指示是使用单纯的PSK还是同时使用PSK和DHE进行秘钥交换;<code>pre_shared_key</code>中存放的就是之前的<code>psk_id</code>和一些相关信息；如果是<code>psk_ke</code>就不需要发送<code>key_share</code>扩展了，如果是<code>psk_dhe_ke</code>，还需要发送<code>key_share</code>扩展，以携带DHE相关的参数；</li><li>server如果也希望使用PSK，就在<code>SH</code>中回复选择哪个<code>psk_id</code>；</li><li>server不再发送<code>Certificate</code>和<code>CertificateRequest</code>，因为这时候不需要证书了；</li><li>client和server可以从<code>psk_ke</code>和<code>psk_dhe_ke</code>两种秘钥交换算法中得出共享的秘钥，然后使用它进行其他秘钥推导。</li></ol><p>相关的消息格式为：</p><h3 id="4-1-2-psk-key-exchange-modes扩展项格式"><a href="#4-1-2-psk-key-exchange-modes扩展项格式" class="headerlink" title="4.1.2. psk_key_exchange_modes扩展项格式"></a>4.1.2. <code>psk_key_exchange_modes</code>扩展项格式</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123; <span class="title">psk_ke</span>(0), <span class="title">psk_dhe_ke</span>(1), (255) &#125; <span class="title">PskKeyExchangeMode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PskKeyExchangeMode ke_modes&lt;<span class="number">1</span>..<span class="number">255</span>&gt;;</span><br><span class="line">&#125; PskKeyExchangeModes;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>psk_ke</code>：类似于于TLS1.2的<code>plain PSK</code>机制，就是只使用PSK进行认证协商，不使用其他秘钥交换算法。这时候不能发送<code>key_share</code>扩展了。</li><li><code>psk_dhe_ke</code>：类似于TLS1.2的<code>DHE_PSK</code>机制，同时使用DH和PSK进行认证协商。必须同时发送<code>key_share</code>。</li></ul><h3 id="4-1-3-pre-shared-key扩展项格式"><a href="#4-1-3-pre-shared-key扩展项格式" class="headerlink" title="4.1.3. pre_shared_key扩展项格式"></a>4.1.3. <code>pre_shared_key</code>扩展项格式</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    select (Handshake.msg_type) &#123;</span><br><span class="line">    case client_hello:</span><br><span class="line">        OfferedPsks<span class="comment">;</span></span><br><span class="line">    case server_hello:</span><br><span class="line">        uint16 selected_identity<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125; PreSharedKeyExtension<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    PskIdentity identities&lt;<span class="number">7</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    PskBinderEntry <span class="keyword">binders&lt;33..2^16-1&gt;;</span></span><br><span class="line"><span class="keyword">&#125; </span>OfferedPsks<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    opaque identity&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    uint32 obfuscated_ticket_age<span class="comment">;</span></span><br><span class="line">&#125; PskIdentity<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">opaque PskBinderEntry&lt;<span class="number">32</span>..<span class="number">255</span>&gt;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>identity</code>: 跟TLS1.2中<code>psk_id</code>效果类似，都是用于查找相应的<code>psk_key</code>的；但由于TLS1.3集成了会话恢复的功能，会有一些其他内容：1）如果是外部导入PSK，这个值就是TLS1.2一样的<code>psk_id</code>，用以查找相应的<code>psk_key</code>。2）如果是用于会话恢复的PSK，分为session ID和ticket实现机制，如果是session ID机制，这里存放的相当于TLS1.2中的session ID，用于指导server查找相应的session加密状态；如果是ticket实现机制，这里存放的就是TLS1.2的ticket，server收到之后，使用ticket中的<code>key_name</code>查找对应的解密秘钥，解密出ticket中的内容，进而恢复session加密状态。但总体来看，client和server可以通过<code>identity</code>得到相应的加密状态——不管是外部导入，还是会话恢复。</li><li><code>obfuscated_ticket_age</code>: client计算<code>psk_key</code>已存活的时间，使用一种混淆方式。如果是外部导入PSK，值是0；如果是用于会话恢复的PSK，值的计算见下边<code>NewSessionTicket</code>。</li><li><code>identities</code>: client可能会提供多个psk供server选择，所以这是个列表。如果client同时发送了0-RTT数据，那应用数据就必须使用第1个psk去加密(编号从0开始)。</li><li><code>binders</code>: 使用每个PSK的<code>psk_key</code>对当前trans-hash计算的一个HMAC值，用于将PSK和当前握手绑定到一起。计算顺序跟<code>identities</code>中的一样。</li><li><code>selected_identity</code>: server希望使用哪个psk进行后续握手，填编号，编号从0开始。</li></ul><h3 id="4-1-4-binders计算"><a href="#4-1-4-binders计算" class="headerlink" title="4.1.4. binders计算"></a>4.1.4. <code>binders</code>计算</h3><p>主要使用HMAC计算，HMAC详细过程见<a href="/2019/05/09/HKDF算法/" title="HKDF算法">HKDF算法</a>。<br>这里，需要计算的数据需要注意：</p><ol><li>如果是计算第一个<code>ClientHello</code>中的psk binder，需要先计算<code>Truncate(ClientHello1)</code>——<code>pre_shared_key</code>扩展项按要求必须放在<code>ClientHello</code>最后，也就是说，其中的<code>psk_binder</code>是在最后的最后，只去掉binders列表，剩下的前边的<code>ClientHello</code>就是<code>Truncate(ClientHello)</code>了。这里<code>ClientHello</code>消息中前边的长度值也需要填好，因为最后计算的binder都是按照HMAC中的hash算法输出的长度，所以长度在计算HMAC值之前就可以确定下来了。在计算<code>Transcript-Hash(Truncate(ClientHello1))</code>，然后使用HMAC对结果进行计算，得到一个个binder值；</li><li>如果是server发送了HRR，需要对<code>Transcript-Hash(ClientHello, HelloRetryRequest, Truncate(ClientHello2)))</code>进行HMAC，这里的<code>ClientHello1</code>是重组后的<code>&quot;message_hash&quot;</code>结构，见TLS1.3的RFC。</li></ol><p>计算时使用的hash算法：</p><ol><li>如果是外部导入的PSK，需要用户提供一个对应的HASH算法，没有提供就默认SHA256；</li><li>如果是上次会话生成的PSK，就用上次会话使用的加密套件中的HASH算法。</li></ol><p>使用的秘钥如何生成后续再完整描述。</p><h2 id="4-2-会话恢复PSK"><a href="#4-2-会话恢复PSK" class="headerlink" title="4.2. 会话恢复PSK"></a>4.2. 会话恢复PSK</h2><h3 id="4-2-1-协商过程"><a href="#4-2-1-协商过程" class="headerlink" title="4.2.1. 协商过程"></a>4.2.1. 协商过程</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 第一次协商</span></span><br><span class="line"><span class="xml">client                                      server</span></span><br><span class="line"><span class="xml">ClientHello</span></span><br><span class="line"><span class="xml">    + key_share             --------&gt;</span></span><br><span class="line"><span class="xml">                                            ServerHello</span></span><br><span class="line"><span class="xml">                                                + key_share</span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;EncryptedExtensions&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;CertificateRequest*&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;Certificate*&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;CertificateVerify*&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;Finished&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">--------</span>       [<span class="attr">Application</span> <span class="attr">Data</span>*]</span></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;Certificate*&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;CertificateVerify*&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;Finished&#125;</span><span class="xml">                  --------&gt;</span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">--------</span>       [<span class="attr">NewSessionTicket</span>]</span></span></span><br><span class="line"><span class="xml">[Application Data]          <span class="tag">&lt;<span class="name">-------</span>&gt;</span>       [Application Data]</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 第二次协商</span></span><br><span class="line"><span class="xml">client                                      server</span></span><br><span class="line"><span class="xml">ClientHello</span></span><br><span class="line"><span class="xml">    + key_share*</span></span><br><span class="line"><span class="xml">    + psk_key_exchange_modes</span></span><br><span class="line"><span class="xml">    + pre_shared_key        --------&gt;</span></span><br><span class="line"><span class="xml">                                            ServerHello</span></span><br><span class="line"><span class="xml">                                                + pre_shared_key</span></span><br><span class="line"><span class="xml">                                                + key_share*</span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;EncryptedExtensions&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                                            </span><span class="template-variable">&#123;Finished&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">                            <span class="tag">&lt;<span class="name">--------</span>       [<span class="attr">Application</span> <span class="attr">Data</span>*]</span></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;Finished&#125;</span><span class="xml">                  --------&gt;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">[Application Data]          <span class="tag">&lt;<span class="name">-------</span>&gt;</span>       [Application Data]</span></span><br></pre></td></tr></table></figure><ol><li>第一次完整握手，server会发送证书等相关信息，进行认证握手。在协商完成后，server会发送<code>NewSessionTicket</code>给client，其中携带的有session ID或ticket；</li><li>第二次会话恢复，流程跟外部导入PSK一致，只不过其中PSK中的<code>psk_key</code>不再是外部导入，而是上次会话生成的。</li></ol><h3 id="4-2-2-NewSessionTicket消息格式"><a href="#4-2-2-NewSessionTicket消息格式" class="headerlink" title="4.2.2. NewSessionTicket消息格式"></a>4.2.2. <code>NewSessionTicket</code>消息格式</h3><p>见<a href="/2020/03/14/ticket相关/" title="ticket相关">ticket相关</a>。</p><h2 id="4-3-支持早期数据"><a href="#4-3-支持早期数据" class="headerlink" title="4.3. 支持早期数据"></a>4.3. 支持早期数据</h2><h3 id="4-3-1-协商流程"><a href="#4-3-1-协商流程" class="headerlink" title="4.3.1. 协商流程"></a>4.3.1. 协商流程</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                      Server</span><br><span class="line">ClientHello</span><br><span class="line">    + early_data</span><br><span class="line">    + key_share*</span><br><span class="line">    + psk_key_exchange_modes</span><br><span class="line">    + pre_shared_key</span><br><span class="line">(Application Data*)         --------&gt;</span><br><span class="line">                                            ServerHello</span><br><span class="line">                                                + pre_shared_key</span><br><span class="line">                                                + key_share*</span><br><span class="line">                                            &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                + early_data*</span><br><span class="line">                                            &#123;Finished&#125;</span><br><span class="line">                            &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;                  --------&gt;</span><br><span class="line"></span><br><span class="line">[Application Data]          &lt;-------&gt;       [Application Data]</span><br></pre></td></tr></table></figure><ol><li>client使用<code>pre_shared_key</code>中的第一个<code>psk_key</code>对用户数据进行加密。其他流程不变。</li></ol><h2 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4. 其他"></a>4.4. 其他</h2><h3 id="4-4-1-PSK跟server-name的关系"><a href="#4-4-1-PSK跟server-name的关系" class="headerlink" title="4.4.1. PSK跟server_name的关系"></a>4.4.1. PSK跟<code>server_name</code>的关系</h3><p>TLS1.3之前的版本中，SNI应该是跟session状态绑定到一起的，也就是说，每次会话恢复的时候，还是使用之前保存的session状态中的SNI，用户不能再重新设置。但很多实现没有处理好，导致恢复的SNI和用户提供的SNI不一致，这样SNI的最终确定是由client进行判断的。<br>TLS1.3中的SNI强制跟session绑定到一起，在会话恢复中必须明确带上SNI，而server不需要将SNI存储到ticket中，每次都根据<code>CH</code>去重新选择。</p><h1 id="5-openssl关于PSK的API"><a href="#5-openssl关于PSK的API" class="headerlink" title="5. openssl关于PSK的API"></a>5. openssl关于PSK的API</h1><p>这里只是有关外部的导入PSK的相关操作。会话恢复的一些操作见<a href="/2020/03/14/ticket相关/" title="ticket相关">ticket相关</a>。</p><h2 id="5-1-设置client期望使用的PSK"><a href="#5-1-设置client期望使用的PSK" class="headerlink" title="5.1. 设置client期望使用的PSK"></a>5.1. 设置client期望使用的PSK</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*SSL_psk_client_cb_func)</span><span class="params">(SSL *ssl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">char</span> *hint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">char</span> *identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">int</span> max_identity_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">char</span> *psk,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">int</span> max_psk_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_set_psk_client_callback</span><span class="params">(SSL_CTX *ctx, SSL_psk_client_cb_func cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_set_psk_client_callback</span><span class="params">(SSL *ssl, SSL_psk_client_cb_func cb)</span></span>;</span><br></pre></td></tr></table></figure><p>这俩函数也能用于TLS1.3，但建议限于TLS1.2及之前的client的PSK设置。<br>回调函数在TLS1.2的触发时机：</p><ol><li>client发送<code>SKE</code>的时候，会触发该回调。其中<code>hint</code>是server发给client的<code>psk_identity_hint</code>字符串，应用根据<code>hint</code>挑选相应的PSK，把选中的PSK的<code>psk_id</code>放入<code>*identity</code>中，在<code>psk</code>中放入相应的<code>psk_key</code>。</li></ol><p>回调函数返回0表示成功，同样设置了有效的<code>psk</code>的话，可以使用PSK。返回其他值会导致握手失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*SSL_psk_use_session_cb_func)</span><span class="params">(SSL *ssl, <span class="keyword">const</span> EVP_MD *md,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">size_t</span> *idlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        SSL_SESSION **sess)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_set_psk_use_session_callback</span><span class="params">(SSL_CTX *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        SSL_psk_use_session_cb_func cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_set_psk_use_session_callback</span><span class="params">(SSL *s, SSL_psk_use_session_cb_func cb)</span></span>;</span><br></pre></td></tr></table></figure><p>这俩函数只限于TLS1.3的PSK。<br>回调函数<code>SSL_psk_use_session_cb_func()</code>触发时机:</p><ol><li>client发送<code>CH</code>的时候，在组建PSK相关扩展项时，会触发一次，这时候<code>md</code>是<code>NULL</code>, 用户需要在回调中将希望使用的<code>psk_id</code>放到<code>**id</code>中，将PSK的其他相关信息放到<code>**sess</code>中。<code>*id</code>指向的内存还是由应用管理，但用户在握手完成之后才能删除它。</li><li>在client收到<code>SH</code>后，如果server也期望使用PSK，则会回复<code>pre_share_key</code>扩展，这时候会再触发一次，这时候server已经协商出了一个加密套件，其中的摘要算法会在<code>md</code>中给应用提供，应用提供的PSK中的摘要算法必须跟给出的一样，否则就不能使用。两次触发时应用返回的PSK可以不一样。</li></ol><p><code>**sess</code>指向的<code>SSL_SESSION</code>中至少要有以下信息：</p><ul><li><code>master key</code>：可以用<code>SSL_SESSION_set1_master_key()</code>去设置，就是设置<code>psk_key</code>的；</li><li><code>ciphersuite</code>：一个加密套件，PSK只关心其中的摘要算法(hash)，因为后续计算PSK binder的时候会用到，server也会根据相应的摘要算法选择最后协商的加密套件。可以设置任何TLS1.3的加密套件。</li><li><code>protocol version</code>: 只能是<code>TLS1_3_VERSION</code>。</li><li>如果需要支持PSK，需要用<code>SSL_SESSION_set_max_early_data()</code>设置早期数据最大长度。</li></ul><p>在回调中返回正确，但不返回<code>sess</code>，说明应用想继续握手，但不想用PSK。返回失败会导致握手失败。</p><h2 id="5-2-在server中选择PSK"><a href="#5-2-在server中选择PSK" class="headerlink" title="5.2. 在server中选择PSK"></a>5.2. 在server中选择PSK</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*SSL_psk_server_cb_func)</span><span class="params">(SSL *ssl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">char</span> *identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">char</span> *psk,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">int</span> max_psk_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_use_psk_identity_hint</span><span class="params">(SSL_CTX *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *hint)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_use_psk_identity_hint</span><span class="params">(SSL *ssl, <span class="keyword">const</span> <span class="keyword">char</span> *hint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_set_psk_server_callback</span><span class="params">(SSL_CTX *ctx, SSL_psk_server_cb_func cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_set_psk_server_callback</span><span class="params">(SSL *ssl, SSL_psk_server_cb_func cb)</span></span>;</span><br></pre></td></tr></table></figure><p>TLS1.2及以前用这俩函数。<br>了解PSK机制和client端的设置的话，这里的就很容易看懂了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*SSL_psk_find_session_cb_func)</span><span class="params">(SSL *ssl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">size_t</span> identity_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            SSL_SESSION **sess)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_set_psk_find_session_callback</span><span class="params">(SSL_CTX *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        SSL_psk_find_session_cb_func cb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_set_psk_find_session_callback</span><span class="params">(SSL *s, SSL_psk_find_session_cb_func cb)</span></span>;</span><br></pre></td></tr></table></figure><p>TLS1.3尽量用这俩函数。<br>回调函数在server收到<code>CH</code>时处理，lib会将<code>psk_id</code>放到<code>identity</code>中，返回给应用，应用根据<code>identity</code>去选择相应的PSK,将PSK的相关信息存储到<code>sess</code>中，返回给lib。<code>sess</code>中相关信息见上边client的配置。</p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h1><ol><li>以上只是针对正常逻辑，具体的异常逻辑需要查阅相应RFC。</li><li>理解这些协议机制，其实就是了解过程和相应的数据结构，就差不多了。</li></ol><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><ol><li>PSK的RFC: <a href="https://tools.ietf.org/html/rfc4279" target="_blank" rel="noopener">RFC4279-Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</a></li><li><code>ServerDHParams</code>格式: <a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener">RFC2246-tls1.0</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-为什么&quot;&gt;&lt;a href=&quot;#1-为什么&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么&quot;&gt;&lt;/a&gt;1. 为什么&lt;/h1&gt;&lt;p&gt;TLS通常用证书体系(PKI)进行认证，先回顾一下传统的RSA证书认证过程，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;server发送证书给client, 证书中包含RSA的公钥，只有server有证书中公钥对应的私钥;&lt;/li&gt;
&lt;li&gt;client收到证书后，对证书进行校验(PKI体系一层层往CA验证，直到根CA)，校验通过后，用证书中的公钥对预主密钥(client每次随机生成)进行加密，将加密后的数据发送给server；&lt;/li&gt;
&lt;li&gt;只有server能解密数据，取出其中的预主密钥。这样，server和client之间就有了共同的秘钥，可以用于后续的加密了。
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>TLS中ChangeCipherSpec为什么是个单独的协议类型</title>
    <link href="http://suntus.github.io/2020/03/14/TLS%E4%B8%ADChangeCipherSpec%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://suntus.github.io/2020/03/14/TLS中ChangeCipherSpec为什么是个单独的协议类型/</id>
    <published>2020-03-14T14:27:25.000Z</published>
    <updated>2020-04-24T11:59:38.521Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tools.ietf.org/html/rfc5226" target="_blank" rel="noopener">RFC5246</a>中说:</p><blockquote><p>Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.</p></blockquote><p>为了避免pipeline stall，<code>ChangeCipherSpec</code>是个单独的协议类型，不属于握手协议。这里什么是pipeline stall？</p><a id="more"></a><h1 id="1-pipeline-stall"><a href="#1-pipeline-stall" class="headerlink" title="1. pipeline stall"></a>1. pipeline stall</h1><p>通俗点的理解是，在CPU流水线设计中，有些指令必须在某些指令之后执行，中间需要停顿一下，等待前一个指令执行完，才能开始后一个指令；或者逻辑分支时，需要控制程序指令转移，导致流水线停顿。如果这样的stall过多，就会影响的性能。可以采取一些办法减少或避免停顿。</p><h1 id="2-TLS1-2及之前的ChangeCipherSpec"><a href="#2-TLS1-2及之前的ChangeCipherSpec" class="headerlink" title="2. TLS1.2及之前的ChangeCipherSpec"></a>2. TLS1.2及之前的ChangeCipherSpec</h1><p>为什么<code>ChangeCipherSpec</code>需要是单独的类型呢？如果是握手协议类型，TLS协议规定相同协议类型的数据可以集中到一个record中发送，也就是说，一个record中可以同时存放<code>ClientKeyExchange,ChangeCipherSpec,Finished</code>这三个消息，其中<code>ClientKeyExchange,ChangeCipherSpec</code>这两个是不加密的，<code>Finished</code>是需要加密的。但TLS的加密是以record为单位的，一个record只能加密或不加密，不能其中一部分数据加密，另一部分不加密。所以在实现的时候，必须将<code>Finished</code>放入一个单独的record中，另外，在<code>ChangeCipherSpec</code>和<code>Finished</code>之间，也需要将连接状态从明文状态转换到加密状态，就需要停顿一下。</p><p>但是，并不一定每个实现都能很好的遵循”将<code>Finished</code>放入单独的record中发送”这个约定，这样就在协议设计的时候添加了这样的冗余，相当于使用<code>ChangeCipherSpec</code>将<code>ClientKeyExchange</code>和<code>Finished</code>强制分配到两个record中。</p><h1 id="3-TLS1-3的ChangeCipherSpec"><a href="#3-TLS1-3的ChangeCipherSpec" class="headerlink" title="3. TLS1.3的ChangeCipherSpec"></a>3. TLS1.3的ChangeCipherSpec</h1><p>TLS1.3中并不需要该消息，因为协议本身保证了在状态转换前发送的消息都是确定的，比如握手消息在<code>ClientHello, ServerHello</code>之后都是加密的，应用消息在发送完<code>Finished</code>之后也都是加密的，而且TLS1.3的秘钥推导跟之前版本的也都不一样，不需要CCS这样的冗余设计。但为了兼容性，还是保留了一些。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><code>ChangeCipherSpec</code>是TLS1.2及之前的协议设计的冗余消息，目的是从协议上避免实现时的流水线停顿问题。</p><p><strong>参考</strong></p><ol><li><a href="https://www.technipages.com/definition/pipeline-stall" target="_blank" rel="noopener">pipeling stall</a></li><li><a href="https://security.stackexchange.com/questions/24755/why-is-change-cipher-spec-an-independent-protocol-content-type-and-not-part-of-h" target="_blank" rel="noopener">CCS pipeling stall</a></li><li><a href="https://www.cnblogs.com/hrhguanli/p/3788316.html" target="_blank" rel="noopener">OpenSSL再曝CCS注入漏洞</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC5246&lt;/a&gt;中说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了避免pipeline stall，&lt;code&gt;ChangeCipherSpec&lt;/code&gt;是个单独的协议类型，不属于握手协议。这里什么是pipeline stall？&lt;/p&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>ticket相关</title>
    <link href="http://suntus.github.io/2020/03/14/ticket%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2020/03/14/ticket相关/</id>
    <published>2020-03-14T14:08:23.000Z</published>
    <updated>2020-04-24T11:59:38.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么"><a href="#1-为什么" class="headerlink" title="1. 为什么"></a>1. 为什么</h1><p>ticket给TLS提供一个不需要在server存储会话状态(session)的机制来恢复会话。适用于TLS1.0, 1.1, 1.2。在以下情况下很有用:</p><ol><li>server需要处理大量不同用户的session;</li><li>server希望长时间存储session;</li><li>需要使用跨server的负载均衡;</li><li>在内存很少的嵌入式的server上。<a id="more"></a></li></ol><p>之前使用session ID的方法需要server将各种加密参数保存在本地，client下次希望恢复session的时候，就将session ID一并带上，server根据session ID查找本地缓存，找到对应的参数，然后直接建立握手。对照上面几个情况，看session ID为什么不适用：</p><ol><li>server处理大量会话需要在本地保存很多加密参数，内存占用和查找效率都会受影响；</li><li>长时间存储session导致长时间占用内存；</li><li>session通常保存在一个server上，如果跨server负载均衡，需要将session统一存储，或支持跨server查询；</li><li>内存占用。</li></ol><h1 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2. 是什么"></a>2. 是什么</h1><h2 id="2-1-主要流程"><a href="#2-1-主要流程" class="headerlink" title="2.1. 主要流程"></a>2.1. 主要流程</h2><ol><li>第一次完整握手，client在ClientHello中发送一个空的session_ticket扩展，表示client支持ticket会话恢复机制，</li><li>server回复一个空的session_ticket扩展，表示自己将会发送一个新的ticket。server会在发送CCS之前发送一个NewSessionTicket的消息，里边存放着用于会话恢复的各种参数，并加密。</li><li>client收到后将ticket和本地的session一并存储。</li><li>第二次会话恢复，client在ClientHello中发送不为空的session_ticket扩展，表示client希望进行会话恢复；</li><li>server收到后，解密校验，如果校验正确，就使用该session参数进行会话恢复。</li><li>不管server接受不接受client发送的ticket，只要server觉得需要签发一个新的ticket，都要发送session_ticket扩展，也就是说，ServerHello中的session_ticket就是指示server是否发送NewSessionTicket的。</li></ol><p>server签发ticket的过程如下：<img src="/img/ticket相关/ticket.png" alt="ticket签发"></p><h2 id="2-2-ticket的生命周期"><a href="#2-2-ticket的生命周期" class="headerlink" title="2.2. ticket的生命周期"></a>2.2. ticket的生命周期</h2><p>开始：</p><ol><li>client从server接收新签发的ticket，保存到本地。</li></ol><p>结束：</p><ol><li>ticket在client的缓存中超时；</li><li>ticket由client的本地策略提前结束使用；</li><li>server新签发了ticket，需要更新本地的ticket；</li><li>会话恢复时出错的时，需要删除ticket。</li></ol><h2 id="2-3-ticket的相关结构"><a href="#2-3-ticket的相关结构" class="headerlink" title="2.3. ticket的相关结构"></a>2.3. ticket的相关结构</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    HandshakeType msg_type;</span><br><span class="line">    uint24 length;</span><br><span class="line">    select (HandshakeType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">hello_request:</span> HelloRequest;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">client_hello:</span> ClientHello;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">server_hello:</span> ServerHello;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">certificate:</span> Certificate;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">server_key_exchange:</span> ServerKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">certificate_request:</span> CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">server_hello_done:</span> ServerHelloDone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">certificate_verify:</span> CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">client_key_exchange:</span> ClientKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">finished:</span> Finished;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">session_ticket:</span> NewSessionTicket; <span class="comment">/* NEW */</span></span><br><span class="line">    &#125; body;</span><br><span class="line">&#125; Handshake;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    uint32 ticket_lifetime_hint;</span><br><span class="line">    opaque ticket&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">&#125; NewSessionTicket;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    opaque key_name[<span class="number">16</span>];</span><br><span class="line">    opaque iv[<span class="number">16</span>];</span><br><span class="line">    opaque encrypted_state&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    opaque mac[<span class="number">32</span>];</span><br><span class="line">&#125; ticket;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>ticket_lifetime_hint</code>: server签发的该ticket的存活时间，从client收到NewSessionTicket开始计算，client以此判断该ticket的超时时间，单位是秒。</li><li><code>ticket</code>: server签发的ticket的具体内容，包含加密的一些参数。</li><li><code>key_name</code>: 表示该ticket用的是哪组秘钥加密认证的，通过该参数，server能很容易判断该ticket是不是自己签发的。通常是在server启动时随机生成的。</li><li><code>iv</code>: server使用AES128-CBC模式去加密<code>encrypted_state</code>，用到的IV保存在这里，IV每次签发ticket的时候都随机生成，每个ticket都不一样。- <code>encrypted_state</code>：使用AES128-CBC和<code>iv</code>加密的实际session参数。</li><li><code>mac</code>: server使用HMAC-SHA256生成消息认证码MAC，认证的消息为: <code>key_name + iv + encrypted_state_len + encrypted_state</code>。</li><li>server加密需要两个秘钥——AES128-CBC使用的加密秘钥，HMAC-SHA256使用的认证秘钥。</li></ul><p>其中<code>encrypted_state</code>中没有规定，建议是：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ProtocolVersion protocol_version;</span><br><span class="line">    CipherSuite cipher_suite;</span><br><span class="line">    CompressionMethod compression_method;</span><br><span class="line">    opaque master_secret[<span class="number">48</span>];</span><br><span class="line">    ClientIdentity client_identity;</span><br><span class="line">    uint32 timestamp;</span><br><span class="line">&#125; StatePlaintext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    anonymous(<span class="number">0</span>),</span><br><span class="line">    certificate_based(<span class="number">1</span>),</span><br><span class="line">    psk(<span class="number">2</span>)</span><br><span class="line">&#125; ClientAuthenticationType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ClientAuthenticationType client_authentication_type;</span><br><span class="line">    <span class="keyword">select</span> (ClientAuthenticationType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="symbol">anonymous:</span> <span class="class"><span class="keyword">struct</span> &#123;&#125;;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="symbol">certificate_based:</span></span><br><span class="line">            ASN.<span class="number">1</span>Cert certificate_list&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>&gt;;</span><br><span class="line">        <span class="keyword">case</span> <span class="symbol">psk:</span></span><br><span class="line">            opaque psk_identity&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;; <span class="regexp">/* from [RFC4279] */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ClientIdentity;</span><br></pre></td></tr></table></figure></p><p>其中:</p><ul><li><code>protocol_version</code>: 签发该ticket时候使用的协议版本。</li><li><code>cipher_suite</code>: 签发该ticket时候使用的加密套件。</li><li><code>master_secret</code>: 签发该ticket时候使用的主秘钥。</li><li><code>timestamp</code>: server用来判断ticket是否超时的。</li><li><code>client_identity</code>: 如果进行了client认证，这里会包含一些对client认证的消息。</li><li><code>certificate_based</code>: client认证使用了证书，这里就包含client的证书列表</li><li><code>psk_identity</code>: client使用了PSK认证，这里就包含了psk的id，用该id可以查找到psk的相关信息。</li></ul><h2 id="2-4-ticket跟原有的session-ID机制的交互使用"><a href="#2-4-ticket跟原有的session-ID机制的交互使用" class="headerlink" title="2.4. ticket跟原有的session ID机制的交互使用"></a>2.4. ticket跟原有的session ID机制的交互使用</h2><ol><li>第一次握手，如果server表示会签发新的ticket，session ID就为空；</li><li>第二次握手，server拒绝使用ticket，可以发送非空的session ID表示自己支持有状态的会话恢复；</li><li>client收到NewSessionTicket的话，就丢掉任何从ServerHello中获取的session ID；</li><li>client发送ticket的时候，也可以生成一个session ID放在CH中； server如果接受ticket，也可以在SH中返回同样的session ID，这样，client就能区分server什么时候在进行会话恢复，什么时候回退到完整握手——server接受了ticket，就使用ticket进行会话恢复，此时session ID跟client发送的一样，server不接受ticket，如果返回跟client一样的session ID，就表示自己支持有状态的会话恢复，如果返回空，就表示自己不支持会话恢复，会回退到完整握手。同时，因为这个session ID是client自己生成的，所以server不接受ticket的话，也查不到session，只能回复空的session ID，client就能根据session ID是否为空，来判断是否进行会话恢复。</li><li>client发送ticket的时候，server禁止使用session ID进行有状态的恢复；</li><li>总结起来就是：有限使用ticket机制。如果client自己生成了session ID，同时又发送了ticket，server也表示要用该ticket恢复，就返回同样的session ID。</li></ol><h1 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h1><ol><li>恢复失败的session会同时将ticket失效。</li><li>被盗的ticket也无所谓，因为ticket是加密的</li><li>伪造的ticket会导致握手失败</li><li>DoS攻击的话，使用<code>key_name</code>可以抵御一部分，另外对ticket的解密校验尽量轻量化，比如使用对称加密算法。</li><li>加密ticket的key的管理建议：<ol><li>key需要随机生成；</li><li>key最少128位；</li><li>key除了加密和校验ticket，不能用作他用；</li><li>key应该周期性更新；</li><li>ticket格式或加密算法更新的话，key需要同时更新。</li></ol></li><li>ticket的有效时间可能超过24小时；</li></ol><h1 id="4-TLS1-3的ticket机制"><a href="#4-TLS1-3的ticket机制" class="headerlink" title="4. TLS1.3的ticket机制"></a>4. TLS1.3的ticket机制</h1><p>TLS1.3将有状态和无状态的会话恢复机制都整合到PSK机制中，当然，PSK也跟最开始诞生的功能有些不一样了，所以TLS1.3的PSK集中了原有的PSK功能、有状态的会话恢复功能(session ID)、无状态的会话恢复功能(ticket)。现在只简单说下PSK的会话恢复功能，TLS1.3的PSK的完整介绍后续再说。</p><p>TLS1.3的会话恢复完全抛弃了CH和SH中session_id字段的功能，但为了兼容考虑，还会在会话恢复的时候进行相应的设置——TLS1.3的client跟TLS1.2的server协商的时候。</p><h2 id="4-1-主要流程"><a href="#4-1-主要流程" class="headerlink" title="4.1. 主要流程"></a>4.1. 主要流程</h2><ol><li>第一次握手，server如果支持会话恢复，就在握手完成后，发送<code>NewSessionTicket</code>消息；</li><li>client如果收到<code>NewSessionTicket</code>消息，就将当前session和其中的ticket存储到一起；</li><li>第二次握手，client在CH中发送<code>pre_shared_key</code>扩展项，其中携带ticket。</li><li>server收到psk扩展后，先解密校验ticket，然后用ticket中的PSK相关key去校验psk。</li><li>server在握手完成后，还可能再签发一个新的<code>NewSessionTicket</code>用于替换之前的。</li></ol><h2 id="4-2-消息格式"><a href="#4-2-消息格式" class="headerlink" title="4.2. 消息格式"></a>4.2. 消息格式</h2><h3 id="4-2-1-server新签发的ticket的NewSessionTicket的消息格式为："><a href="#4-2-1-server新签发的ticket的NewSessionTicket的消息格式为：" class="headerlink" title="4.2.1. server新签发的ticket的NewSessionTicket的消息格式为："></a>4.2.1. server新签发的ticket的<code>NewSessionTicket</code>的消息格式为：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    uint32 ticket_lifetime;</span><br><span class="line">    uint32 ticket_age_add;</span><br><span class="line">    opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">    opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">    Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">&#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>ticket_lifetime</code>: ticket从签发开始的有效时间，单位是秒。server不能签发超过7天(604800s)的ticket。为0表示该ticket应该立即丢掉。由于往返时间，server可以认为稍微超过一段有效时间的过期ticket仍然有效；</li><li><code>ticket_age_add</code>: 每次签发ticket都生成的一个随机数。用于隐藏CH中<code>pre_shared_key</code>扩展项中的ticket的有效时间，防止攻击者关联起多个连接。psk中的有效时间 = (client自己保存的ticket有效时间(单位毫秒)  + ticket_age_add ) module 2^32。</li><li><code>ticket_nonce</code>: 该连接上签发的ticket的唯一标识，从0开始依次递增；</li><li><code>ticket</code>：用做CH中psk的identity，可以是一个索引(类似session ID一样的，这时候就是有状态的会话恢复)或者加密签名后的数据(类似原始的ticket，这时候就是无状态的会话恢复)。无状态的数据结构类似TLS1.2的ticket。</li><li><code>extensions</code>：TLS1.3现在只定义了一个扩展项——<code>early_data</code>，用于表示server最大能接受的早期数据大小(未加密的明文数据，不包括填充等，纯用户数据长度)。</li></ul><h3 id="4-2-2-PSK扩展项"><a href="#4-2-2-PSK扩展项" class="headerlink" title="4.2.2. PSK扩展项"></a>4.2.2. PSK扩展项</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    opaque identity&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    uint32 obfuscated_ticket_age<span class="comment">;</span></span><br><span class="line">&#125; PskIdentity<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">opaque PskBinderEntry&lt;<span class="number">32</span>..<span class="number">255</span>&gt;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    PskIdentity identities&lt;<span class="number">7</span>..<span class="number">2</span>^<span class="number">16</span>-1&gt;<span class="comment">;</span></span><br><span class="line">    PskBinderEntry <span class="keyword">binders&lt;33..2^16-1&gt;;</span></span><br><span class="line"><span class="keyword">&#125; </span>OfferedPsks<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">    select (Handshake.msg_type) &#123;</span><br><span class="line">        case client_hello: OfferedPsks<span class="comment">;</span></span><br><span class="line">        case server_hello: uint16 selected_identity<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125; PreSharedKeyExtension<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>identity</code>: 就是<code>NewSessionTicket.ticket</code>。</li><li><code>obfuscated_ticket_age</code>：隐藏的ticket有效时间，外部导入的PSK该值是0，上次会话建立的PSK的有效时间 = (client自己保存的ticket有效时间(单位毫秒) + ticket_age_add ) module 2^32。注意该值是以ms为单位。</li><li><code>identities</code>： cilent希望用的一个identity列表，要是有0-RTT数据，必须用第一个identity(序号是0);</li><li><code>binders</code>: 一列HMAC的值，按照<code>identities</code>的顺序依次排列。目的是将psk(ticket或者sesssion ID或者外部导入的PSK)跟当前握手绑定。</li><li><code>selected_identity</code>: server如果使用psk会话恢复，返回选择的identity的序号(从0开始)。</li></ul><h2 id="4-3-TLS1-3中ticket的安全性考虑"><a href="#4-3-TLS1-3中ticket的安全性考虑" class="headerlink" title="4.3. TLS1.3中ticket的安全性考虑"></a>4.3. TLS1.3中ticket的安全性考虑</h2><p>具体跟0-RTT的早期数据相关，后续再补。</p><h1 id="5-openssl中关于ticket的相关接口"><a href="#5-openssl中关于ticket的相关接口" class="headerlink" title="5. openssl中关于ticket的相关接口"></a>5. openssl中关于ticket的相关接口</h1><h2 id="5-1-处理ticket中的加密数据"><a href="#5-1-处理ticket中的加密数据" class="headerlink" title="5.1. 处理ticket中的加密数据"></a>5.1. 处理ticket中的加密数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/tls1.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_tlsext_ticket_key_evp_cb</span><span class="params">(SSL_CTX sslctx,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> (*cb)(SSL *s, <span class="keyword">unsigned</span> <span class="keyword">char</span> key_name[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH],</span></span></span><br><span class="line"><span class="function"><span class="params">               EVP_CIPHER_CTX *ctx, EVP_MAC_CTX *hctx, <span class="keyword">int</span> enc))</span></span>;</span><br><span class="line"><span class="comment">// OpenSSL 3.0引入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_tlsext_ticket_key_cb</span><span class="params">(SSL_CTX sslctx,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> (*cb)(SSL *s, <span class="keyword">unsigned</span> <span class="keyword">char</span> key_name[<span class="number">16</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH],</span></span></span><br><span class="line"><span class="function"><span class="params">               EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, <span class="keyword">int</span> enc))</span></span>;</span><br><span class="line"><span class="comment">// OpenSSL 3.0中被废除</span></span><br></pre></td></tr></table></figure><p>因为没有必要为每一个session都维护一个单独的加密状态，所以就交给用户去维护，然后用户负责ticket中部分参数的生成和和状态维护。</p><p>server收到client发来的空的<code>session_ticket</code>扩展项，<code>enc</code>参数为1，表示这是要签发一个新的ticket，应用需要设置<code>key_name, iv, ctx, hctx</code> 给lib，lib会使用这些信息去创建并加密ticket。<br>server收到client发来的非空的<code>session_ticket</code>扩展项，<code>enc</code>参数为0， 表示这是要解析一个ticket，lib会传给应用<code>key_name, iv</code>，应用需要设置<code>ctx, hctx</code>给lib，用以解密校验ticket。<br>返回值表示应用是否希望签发使用新的ticket:</p><ul><li>2: 表示应用已经设置了<code>ctx, hctx</code>，可以继续处理当前收到的ticket，另外需要重新签发一个ticket，该cb会在签发新ticket的时候再被调用一次，这次<code>enc</code>会被设为1.</li><li>1: <code>ctx, hctx</code>已经设置了，可以继续按默认情况处理。</li><li>0: 表示应用无法处理该ticket，需要进行完整握手或者使用session ID会话恢复机制。</li><li>小于0: 出错了。</li></ul><h2 id="5-2-设置签发和校验ticket时候的用户接口和数据"><a href="#5-2-设置签发和校验ticket时候的用户接口和数据" class="headerlink" title="5.2. 设置签发和校验ticket时候的用户接口和数据"></a>5.2. 设置签发和校验ticket时候的用户接口和数据</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (<span class="name">*SSL_CTX_generate_session_ticket_fn</span>)(<span class="name">SSL</span> *s, void *arg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef SSL_TICKET_RETURN (<span class="name">*SSL_CTX_decrypt_session_ticket_fn</span>)(<span class="name">SSL</span> *s, SSL_SESSION *ss, const unsigned char *keyname, size_t keyname_len, SSL_TICKET_STATUS status, void *arg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int SSL_CTX_set_session_ticket_cb(<span class="name">SSL_CTX</span> *ctx, SSL_CTX_generate_session_ticket_fn gen_cb, SSL_CTX_decrypt_session_ticket_fn dec_cb, void *arg)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>gen_cb()</code>是给应用提供的在生成ticket的时候进行的回调，在回调中应用可以调用<code>SSL_SESSION_set1_ticket_appdata()</code>在ticket中设置用户数据。<code>gen_cb()</code>中的参数<code>arg</code>就是<code>SSL_CTX_set_session_ticket_cb()</code>中的<code>arg</code>。<br>默认情况下，会话恢复的时候，TLS1.2不会再签发新的ticket，TLS1.3每次会话恢复都会签发新的ticket，可以用<code>SSL_CTX_set_tlsext_ticket_key_cb()</code>改变这个行为。</p><p><code>dec_cb()</code>是在库尝试解密ticket之后，给应用提供的回调。如果解密成功，<code>ss</code>中存放的是session，<code>keyname</code>和<code>keyname_len</code>是解密ticket使用的秘钥标识，<code>status</code>是解密是否成功，<code>arg</code>就是<code>SSL_CTX_set_session_ticket_cb()</code>中的<code>arg</code>。该回调被调用的时候，<code>sessionss</code>还没绑定到SSL<code>s</code>上。做任何操作前， 都要先检查<code>status</code>：</p><ul><li><code>SSL_TICKET_EMPTY</code>: 空的ticket数据，就是CH中发送了空的<code>session_ticket</code>扩展，表示client支持ticket机制。只在TLS1.2之前使用，TLS1.3没意义。</li><li><code>SSL_TICKET_NO_DECRYPT</code>: 无法解密ticket，没有ticket数据可用，且应该给client<br>发送新的ticket。</li><li><code>SSL_TICKET_SUCCESS</code>: ticket解密成功，可以使用应用数据，不应该发送新的ticket。</li><li><code>SSL_TICKET_SUCCESS_RENEW</code>: 跟<code>SSL_TICKET_SUCCESS</code>一样，但要发送新的ticket。</li></ul><p><code>dec_cb()</code>的返回值可以是：</p><ul><li><code>SSL_TICKET_RETURN_ABORT</code>: 应用判断需要中止握手，可能是由于检测ticket相关数据失败了。注意，TLS1.3一次握手可能会签发多个ticket，一个ticket失效不代表其他也失效，需要小心使用该返回值。</li><li><code>SSL_TICKET_RETURN_IGNORE</code>: 不使用该ticket，也不要签发新的ticket。</li><li><code>SSL_TICKET_RETURN_IGNORE_RENEW</code>:不使用该ticket，但签发一个新的ticket。</li><li><code>SSL_TICKET_RETURN_USE</code>: 使用ticket，但不签发新的ticket。</li><li><code>SSL_TICKET_RETURN_USE_RENEW</code>: 使用ticket，签发新的ticket。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_SESSION_set1_ticket_appdata</span><span class="params">(SSL_SESSION *ss, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_SESSION_get0_ticket_appdata</span><span class="params">(SSL_SESSION *ss, <span class="keyword">void</span> **data, <span class="keyword">size_t</span> *len)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SSL_SESSION_set1_ticket_appdata(()</code>可以将用户数据存入ticket发送给client。</p><h2 id="5-3-设置TLS1-3中ticket签发个数"><a href="#5-3-设置TLS1-3中ticket签发个数" class="headerlink" title="5.3. 设置TLS1.3中ticket签发个数"></a>5.3. 设置TLS1.3中ticket签发个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_num_tickets</span><span class="params">(SSL *s, <span class="keyword">size_t</span> num_tickets)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> SSL_get_num_tickets(SSL *s);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_num_tickets</span><span class="params">(SSL_CTX *ctx, <span class="keyword">size_t</span> num_tickets)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> SSL_CTX_get_num_tickets(SSL_CTX *ctx);</span><br></pre></td></tr></table></figure><p>设置TLS1.3完整握手后，server可以发送多少个ticket。默认是2个，也可以是0个。会话恢复之后默认发送1个新的ticket，会话恢复后发送的个数不能用这些函数改变，可以用<code>SSL_CTX_set_tlsext_ticket_key_cb</code>改变。<br>TLS1.3中，server使用<code>SSL_verify_client_post_handshake()</code>进行握手后认证，client发来证书后，还会签发新的ticket，这个ticket个数跟开始的握手时签发的个数一样，如果开始的是完整握手，那也可以在调用<code>SSL_verify_client_post_handshake()</code>之前调用<code>SSL_set_num_tickets</code>重新设置签发个数。</p><p><strong>参考</strong>:</p><ol><li><a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_num_tickets.html" target="_blank" rel="noopener">openssl手册</a></li><li><a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC8446-TLS1.3 PSK,ticket</a></li><li><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246-TLS1.2 session ID</a></li><li><a href="https://tools.ietf.org/html/rfc5077" target="_blank" rel="noopener">RFC5077-Transport Layer Security (TLS) Session Resumption without<br>Server-Side State</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-为什么&quot;&gt;&lt;a href=&quot;#1-为什么&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么&quot;&gt;&lt;/a&gt;1. 为什么&lt;/h1&gt;&lt;p&gt;ticket给TLS提供一个不需要在server存储会话状态(session)的机制来恢复会话。适用于TLS1.0, 1.1, 1.2。在以下情况下很有用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;server需要处理大量不同用户的session;&lt;/li&gt;
&lt;li&gt;server希望长时间存储session;&lt;/li&gt;
&lt;li&gt;需要使用跨server的负载均衡;&lt;/li&gt;
&lt;li&gt;在内存很少的嵌入式的server上。
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>ALPN相关</title>
    <link href="http://suntus.github.io/2019/08/30/ALPN%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2019/08/30/ALPN相关/</id>
    <published>2019-08-30T06:11:25.000Z</published>
    <updated>2020-04-24T11:59:38.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么需要ALPN"><a href="#1-为什么需要ALPN" class="headerlink" title="1. 为什么需要ALPN"></a>1. 为什么需要ALPN</h3><p>　　TLS只负责建立加密通道，不负责上层到底是什么应用，所以如果用户想在1个地址上支持多种应用协议，比如1个443端口，既想支持HTTP/1.1，还能支持HTTP/2、SPDY/1，没有ALPN（App-Layer Protocol Negotiation）的话，用户需要在ssl建立连接之后，再协商是用哪个协议，然后分发到各个协议的处理流程中，这样多了一个来回。ALPN把应用层协商附带到握手协商中，让用户在握手建立之后就立即知道使用的应用协议，这样节省了一个来回。<br><a id="more"></a></p><h3 id="2-TLS中的具体实现"><a href="#2-TLS中的具体实现" class="headerlink" title="2. TLS中的具体实现"></a>2. TLS中的具体实现</h3><p>　　主要见 <a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">RFC 7301</a>。</p><p>　　ALPN作为扩展项存在ClientHello和ServerHello中，ALPN格式为：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">       application_layer_protocol_negotiation(<span class="number">16</span>), (<span class="number">65535</span>)</span><br><span class="line">&#125; ExtensionType;</span><br><span class="line"></span><br><span class="line">The <span class="string">"extension_data"</span> field <span class="keyword">of</span> the (<span class="string">"application_layer_protocol_negotiation(16)"</span>) extension SHALL</span><br><span class="line">contain a <span class="string">"ProtocolNameList"</span> value.</span><br><span class="line"></span><br><span class="line">opaque ProtocolName&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">8</span>-<span class="number">1</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       ProtocolName protocol_name_list&lt;<span class="number">2</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;</span><br><span class="line">&#125; ProtocolNameList;</span><br></pre></td></tr></table></figure></p><p>　　协商过程:</p><ol><li>client在ClientHello中设置期望的协议列表，优先支持的放在前边。</li><li>server设置支持的应用协议列表，优先支持的放到前边。收到ClientHello后，应用选择支持的协议。</li><li>server在ServerHello中返回支持的1个应用协议，此后的应用层就使用该协议。</li><li><p>client收到ServerHello中的应用协议，此后的应用层就使用该协议。</p></li><li><p>如果server没有支持的协议，会返回握手失败的警告。</p></li></ol><p>　　需要注意的是ALPN协商每次都在握手的时候进行，不会保存到session中，所以即使会话恢复，也会重新协商。会话恢复是TLS层的东西，不是应用层的，不管是哪个协议的应用，都可以使用TLS恢复的会话。</p><h3 id="3-openssl中的接口"><a href="#3-openssl中的接口" class="headerlink" title="3. openssl中的接口"></a>3. openssl中的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client或者server设置支持的应用协议，格式是带1个字节长度前缀的协议，类似</span></span><br><span class="line"><span class="comment">// "\x08HTTP/1.1" 或者 "\x08HTTP/1.1\x06SPDY/1"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_CTX_set_alpn_protos</span><span class="params">(SSL_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *protos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> protos_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_set_alpn_protos</span><span class="params">(SSL *ssl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *protos,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> protos_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置协商回调，server在收到ALPN时会调用该回调，让用户去进行协商和一些其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_CTX_set_alpn_select_cb</span><span class="params">(SSL_CTX *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> (*cb) (SSL *ssl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **out,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">char</span> *outlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">int</span> inlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// openssl提供的标准的协商过程，应用可以在握手的时候就知道准备用什么协议了。</span></span><br><span class="line"><span class="comment">// 该函数应该在SSL_CTX_set_alpn_select_cb()设置的回调中使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SSL_select_next_proto</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> **out, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *server,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> server_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> client_len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//  取出已经协商好的应用协议</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSL_get0_alpn_selected</span><span class="params">(<span class="keyword">const</span> SSL *ssl, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> *len)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">RFC 7301</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为什么需要ALPN&quot;&gt;&lt;a href=&quot;#1-为什么需要ALPN&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要ALPN&quot;&gt;&lt;/a&gt;1. 为什么需要ALPN&lt;/h3&gt;&lt;p&gt;　　TLS只负责建立加密通道，不负责上层到底是什么应用，所以如果用户想在1个地址上支持多种应用协议，比如1个443端口，既想支持HTTP/1.1，还能支持HTTP/2、SPDY/1，没有ALPN（App-Layer Protocol Negotiation）的话，用户需要在ssl建立连接之后，再协商是用哪个协议，然后分发到各个协议的处理流程中，这样多了一个来回。ALPN把应用层协商附带到握手协商中，让用户在握手建立之后就立即知道使用的应用协议，这样节省了一个来回。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>RSA算法</title>
    <link href="http://suntus.github.io/2019/06/17/RSA%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/06/17/RSA算法/</id>
    <published>2019-06-17T10:49:51.000Z</published>
    <updated>2020-04-24T11:59:38.520Z</updated>
    
    <content type="html"><![CDATA[<p>比较浅显的理解，主要是对RSA算法有一些数学上的认识。<br><a id="more"></a></p><h3 id="1-数学原理"><a href="#1-数学原理" class="headerlink" title="1. 数学原理"></a>1. 数学原理</h3><h4 id="1-1-质数很容易生成"><a href="#1-1-质数很容易生成" class="headerlink" title="1.1 质数很容易生成"></a>1.1 质数很容易生成</h4><p>给定一个长度，很容易找到符合这个长度的一个随机质数。这个结论依赖两点：</p><ol><li>质数在任意长度内都广泛存在；</li><li>即使数很大(比如4096位)，也很容易判断它到底是不是个质数。</li></ol><p>要生成一个质数，先随机生成一批给定长度的数字，然后判断它们是不是质数。根据<code>Prime Number Theorem</code>，找到一个质数，需要判断的候选数字个数在$\ln(x)$的阶上($O(\ln(x))$???), $x$是给定的长度。</p><p>之前判断一个数是不是质数需要找它所有的因子，看是不是只有1和它本身，如果是那就是质数。现在的方法是判断一个数是不是有质数的一些性质。如果不能很快判断一个数是不是质数，现代的很多公钥算法就很难实际应用了。</p><h4 id="1-2-乘法很容易计算"><a href="#1-2-乘法很容易计算" class="headerlink" title="1.2 乘法很容易计算"></a>1.2 乘法很容易计算</h4><p>有两个很大(512位以上)的质数$p, q$, 很容易算出他们的乘积$n = pq$。</p><h4 id="1-3-因式分解很难"><a href="#1-3-因式分解很难" class="headerlink" title="1.3 因式分解很难"></a>1.3 因式分解很难</h4><p>尽管经过几百年的研究，现在因式分解的方法比一个个查找的方法快很多(现在最快的能接近$\sqrt{n}$)，但还是很慢，非常慢。</p><h4 id="1-4-幂的模很容易计算"><a href="#1-4-幂的模很容易计算" class="headerlink" title="1.4 幂的模很容易计算"></a>1.4 幂的模很容易计算</h4><p>给定$n, m, e$, 很容易算出来$c = m^e \text{ mod } n$</p><h4 id="1-5-如果给出因子，很容易计算出模的根"><a href="#1-5-如果给出因子，很容易计算出模的根" class="headerlink" title="1.5 如果给出因子，很容易计算出模的根"></a>1.5 如果给出因子，很容易计算出模的根</h4><p>给定$n, e, c$，还有$n$的质数因子$p, q$, 很容易计算出$c = m^e \text{ mod } n$中的$m$<br>方法就是存在$d$满足$m = (m ^ e) ^ d \text{ mod } n = c^d \text{ mod } n$</p><p>其中d按如下方法计算：<br>$L = LCM(p-1, q-1)$，LCM是$p-1,q-1$的最小公倍数，$d$是所有满足 $d \cdot e \text{ mod } L = 1$的数，也就是说，$d$和$e$是关于$\text{ mod } L$的倒数，$e$跟$p-1$和$q-1$互质保证了$d$一定存在。模倒数可以用扩展欧几里得算法很容易算出来。</p><h4 id="1-6-如果不给出因子，计算模的根很难"><a href="#1-6-如果不给出因子，计算模的根很难" class="headerlink" title="1.6 如果不给出因子，计算模的根很难"></a>1.6 如果不给出因子，计算模的根很难</h4><p>如果只给出$n, e, c$，不给出n的因子$p, q$，就很难计算出$c = m^e \text{ mod } n$中的$m$。</p><p>要恢复$m$，需要先找到$d$，事实上，任何确定d的方法都会转到因式分解$n$的路上。</p><h3 id="2-RSA加解密"><a href="#2-RSA加解密" class="headerlink" title="2. RSA加解密"></a>2. RSA加解密</h3><p>有了以上的基础，现在可以描述一下RSA密钥对儿的生成步骤了。</p><p>加密系统中的公钥包含$n$和$e$，$n$叫<em>模数(modulus)</em>，$e$叫<em>公钥指数(public exponent)</em>。私钥包含$n$和$d$，$d$叫<em>私钥指数(private exponent)</em>。</p><p>生成步骤如下：</p><ol><li>生成一对儿很大的随机质数$p,q$</li><li>计算模数$n = pq$</li><li>在[3,n-1]之间挑选一个奇数$e$, 作为公钥指数，并保证$e$和 $p-1、q-1$互质。</li><li>用$e, p, q$计算私钥指数$d$。 先算$L = LCM(p-1, q-1)$, LCM是$p-1$和$q-1$的最小公倍数，$d$满足$d \cdot e \text{ mod } L = 1$， 可以用扩展欧几里得算法算出来。</li><li>$(n, e)$就是公钥， $(n, d)$就是私钥。</li></ol><p>加密操作：</p><script type="math/tex; mode=display">c = m^e \text{ mod } n</script><p>解密操作:</p><script type="math/tex; mode=display">m = c^d \text{ mod } n</script><p>签名操作：</p><script type="math/tex; mode=display">s = m^d \text{ mod } n</script><p>验签操作：</p><script type="math/tex; mode=display">m = s^e \text{ mod } n</script><p>我们常数的RSA 4096指的是$n$的位数，表示RSA算法一次可以加密多少位的数据。</p><h3 id="3-openssl相关的几个问题"><a href="#3-openssl相关的几个问题" class="headerlink" title="3. openssl相关的几个问题"></a>3. openssl相关的几个问题</h3><ol><li><code>RSA_size()</code>和<code>RSA_bits()</code>的返回值<br><code>RSA_size()</code>返回的是rsa-&gt;n的字节数，这个值乘8就是期望的1024, 2048, 4096等值。<br><code>RSA_bits()</code>返回的是rsa-&gt;n的有效位数，这个值不一定就是1024这些值，因为最高有效位可能是0。(其实openssl内置的rsa密钥生成函数中，保证了n的最高4个有效位必须在[0x9, 0xf]之间)。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>讲RSA非常好的一个，基本是这篇的摘要: The Mathematics of the RSA Public-Key Cryptosystem</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较浅显的理解，主要是对RSA算法有一些数学上的认识。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>ECC算法</title>
    <link href="http://suntus.github.io/2019/05/31/ECC%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/05/31/ECC算法/</id>
    <published>2019-05-31T11:04:38.000Z</published>
    <updated>2020-04-24T11:59:38.519Z</updated>
    
    <content type="html"><![CDATA[<p>对TLS1.3中用到的ECC相关算法，比如ECDH, ECDSA, X25519等进行一下基础说明，起码知道group、curve之类的是什么意思。<br><a id="more"></a></p><h2 id="1-椭圆曲线-Elliptic-Curves"><a href="#1-椭圆曲线-Elliptic-Curves" class="headerlink" title="1. 椭圆曲线(Elliptic Curves)"></a>1. 椭圆曲线(Elliptic Curves)</h2><p>椭圆曲线的Weierstrass标准形式：</p><script type="math/tex; mode=display">y^2 = x^3 + ax + b</script><script type="math/tex; mode=display">4a^3 + 27b^2 != 0</script><p>定义0表示椭圆曲线上的无限远点，这样组成的椭圆曲线是这样的：</p><script type="math/tex; mode=display">\left\{ (x, y) \in \mathbb{R}^2\ |\ y^2 = x^3 + ax + b,\ 4 a^3 + 27 b^2 \ne 0 \right\}\ \cup\ \left\{ 0 \right\}</script><h2 id="2-群-Group"><a href="#2-群-Group" class="headerlink" title="2. 群(Group)"></a>2. 群(Group)</h2><p>$\mathbb{G}$是一个集合，在集合中定义一个对两个元素的操作，记为<code>&quot;加&quot;</code>,用<code>+</code>表示，集合中两个元素a和b,<code>&quot;加&quot;</code>操作表示为$a+b$，如果$a+b$这个操作满足一下4个特性，$\mathbb{G}$就是一个群(Group):</p><ul><li>闭合性closure: a, b是$\mathbb{G}$的元素，$a+b$也是；</li><li>结合性associativity: $(a+b)+c=a+(b+c)$</li><li>存在单位元identity element 0, 有$a+0=0+a=a$</li><li>每个元素都有一个相反数，对每个元素a都存在b使$a+b=0$, b就是a的相反数，可以表示为$-a$</li></ul><p>如果再加一条特性：</p><ul><li>交换律：$a+b=b+a$<br>这样的群就要阿贝尔群(Abelian Group)</li></ul><p>这个”加+”操作，也可以用”乘*”来表示，这个操作只是表示集合上两个元素的一个操作，此时</p><ul><li>$a \cdot b$ 也是 $\mathbb{G}$ 上的一个元素；</li><li>$(a \cdot b) \cdot c=a \cdot (b \cdot c)$</li><li>单位元1， $a \cdot 1=1 \cdot a=a$</li><li>$a \cdot b=1$， b可以表示为$a^{-1}$</li></ul><p>在讨论ECC的时候，一些旧的文献通常用<code>+</code>，新的通常用<code>*</code>，另外，在密码学中讨论加密强度的时候，通常按照指数(幂)、读书来讨论，比如长听到取离散对数问题。本文都用<code>+</code>来表示。</p><h2 id="3-椭圆曲线上的群"><a href="#3-椭圆曲线上的群" class="headerlink" title="3. 椭圆曲线上的群"></a>3. 椭圆曲线上的群</h2><p>可以定义一个在椭圆曲线上的群$\mathbb{G}$：</p><ul><li>一个椭圆曲线上的点是$\mathbb{G}$中的元素;</li><li>单位元定义为无穷远处的点0</li><li>一个点P的相反数是关于x轴对称的点</li><li><code>加</code>定义为： $P, Q, R$是斜率相同的点(一条直线跟椭圆曲线相交的3个点)，有$P+Q+R=0$</li></ul><p>这样就有$R=-(P+Q)$，如果要用计算机去算，需要转换成代数的方法计算R的x,y坐标<br>记</p><script type="math/tex; mode=display">P=(x_P, y_P), Q=(x_Q, y_Q), R=(x_R, y_R)</script><p>则:</p><script type="math/tex; mode=display">m = \frac{y_P - y_Q}{x_R - x_Q}</script><script type="math/tex; mode=display">x_R = m^2 - x_P - x_Q</script><script type="math/tex; mode=display">y_R = y_P + m(x_R - x_P)</script><p>这样，就能根据$P, Q$算出$R$了。</p><h2 id="4-标量乘法"><a href="#4-标量乘法" class="headerlink" title="4. 标量乘法"></a>4. 标量乘法</h2><script type="math/tex; mode=display">nP = \underbrace{P + P + \cdots + P}_{n\ \text{times}}</script><p>叫做<code>标量乘法</code>.<br>有个快速算法：<code>double and add</code>，<br>比如 $n = 151$， 用2进制表示为$10010111b$，然后</p><script type="math/tex; mode=display">\begin{array}{rcl}    151 & = & 1 \cdot 2^7 + 0 \cdot 2^6 + 0 \cdot 2^5 + 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 \\    & = & 2^7 + 2^4 + 2^2 + 2^1 + 2^0\end{array}</script><p>就可以很方便的用计算机去算了。</p><h2 id="5-对数"><a href="#5-对数" class="headerlink" title="5. 对数"></a>5. 对数</h2><p>对$Q=nP$,如果知道$n$和$P$，可以很容易算出$Q$(double and add)， 但如果知道$Q$和$P$，却很难算出$n$——数学上没有很快的算法。<br>如果用<code>*</code>来表示，那就是$Q=P^n$,知道$Q$和$P$，很难算出指数$n$，这就是取对数难题，也是密码学中的基石。</p><h2 id="6-有限域-Finite-Field"><a href="#6-有限域-Finite-Field" class="headerlink" title="6. 有限域(Finite Field)"></a>6. 有限域(Finite Field)</h2><p>有限域，就是域中元素是有限个数的域，整个实数域是无限的，如果对实数取$ \text{ mod }  p$，就可以得到元素个数为p的有限域了，<br>域中多一个操作乘，符合结合律：$x \cdot (y+z)=x \cdot y+x \cdot z$</p><p>先了解mod运算</p><script type="math/tex; mode=display">(18+9)  \text{ mod }  23=4</script><script type="math/tex; mode=display">-5  \text{ mod }  23 = 18</script><script type="math/tex; mode=display">9^{-1}  \text{ mod }  23 = 18</script><p>因为在域23上，$9^{-1} = 18$(因为 $9 \cdot 18  \text{ mod }  23 = 1, 9 \cdot 9{^-1} mod 23 = 1$, 域上1个元素有且只有1个倒数，所以$9^{-1} = 18$，9的倒数是18)</p><h2 id="7-mod-p-除法"><a href="#7-mod-p-除法" class="headerlink" title="7. mod p 除法"></a>7. mod p 除法</h2><p>要计算$\frac{x}{y}$，需要计算$x \cdot y^{^-1}$,也是就是我们要先找到y的倒数，然后再乘上x<br>取一个数的倒数用扩展欧几里得算法可以很简单算出来。</p><h2 id="8-有限域-GF-p-中的椭圆曲线"><a href="#8-有限域-GF-p-中的椭圆曲线" class="headerlink" title="8. 有限域$GF(p)$中的椭圆曲线"></a>8. 有限域$GF(p)$中的椭圆曲线</h2><p>先前的椭圆曲线是实数域上的，现在挑选其中在有限域$GF(p)$上的点，就组成了椭圆曲线上的有限域——或者有限域上的椭圆曲线。</p><h2 id="9-有限域上的椭圆曲线的加法"><a href="#9-有限域上的椭圆曲线的加法" class="headerlink" title="9. 有限域上的椭圆曲线的加法"></a>9. 有限域上的椭圆曲线的加法</h2><p>还是$P+Q+R=0$，但$P，Q, R$在有限域上怎么斜率相同呢？——在一条直线上即可。但有限域上的直线跟是实数域上有些不同，只要有限域中的点$(x,y)$符合$ax+by+c ( \text{ mod }  p) = 0 ( \text{ mod }  p)$，就说这些点在同一条直线上——这样的直线画出来可能有很多并行的条，都算同一条直线。</p><p>这样，有限域上的加法用计算机计算，公式是这样的</p><script type="math/tex; mode=display">x_R = (m^2-x_P-x_Q)  \text{ mod }  p</script><script type="math/tex; mode=display">y_R = [y_P + m(x_R-x_P)]  \text{ mod }  p = [y_Q + m(x_R-x_Q)]  \text{ mod }  p</script><p>这样就可以用计算机计算$P + Q = R$了</p><h2 id="10-一个椭圆曲线群的阶order"><a href="#10-一个椭圆曲线群的阶order" class="headerlink" title="10. 一个椭圆曲线群的阶order"></a>10. 一个椭圆曲线群的阶<code>order</code></h2><p>首先，一个群上的点的元素个数，叫做这个群的阶。<br>定义在一个有限域上的一个椭圆曲线的元素个数是多少呢？有个快速的算法可以计算: <code>Schoof’s algorithm</code>。可以方便计算椭圆曲线在有限域上的元素个数。</p><h2 id="11-标量乘法和曲线子群"><a href="#11-标量乘法和曲线子群" class="headerlink" title="11. 标量乘法和曲线子群"></a>11. 标量乘法和曲线子群</h2><p>标量乘法是这样的</p><script type="math/tex; mode=display">n P = \underbrace{P + P + \cdots + P}_{n\ \text{times}}</script><p>但在有限域上，我们可以想象出<br>$1P$<br>$2P$<br>$3P$<br>$…$<br>得出的结果最终会形成一个循环，而且循环中的所有结果都在有限域上，这样，我们根据$P$生成了一个曲线子群，$P$就叫做这个子群的生成因子后者基准点。曲线子群就是ECC和其他加密系统的基础。</p><p>现在我们梳理一下：</p><ul><li>一开始我们有实数群$\mathbb{G}$,</li><li>我们取椭圆曲线，得出椭圆曲线上的点，形成一个小一点的群</li><li>接着定义有限域，然后将椭圆曲线限制到有限域上，这样框出来的椭圆曲线上的点，形成一个更小一点的群</li><li>最后，我们取其中一个点作为基准点，取基准点的向量倍数，生成一个再小一点的子群，这个群，就是我们的ECC要用的群了。</li></ul><h2 id="12-子群的阶"><a href="#12-子群的阶" class="headerlink" title="12. 子群的阶"></a>12. 子群的阶</h2><p>我们想知道，由基准点$P$生成的子群的阶是多少。现在不能用<code>Schoof’s</code>算法，它是工作在整个椭圆曲线上，而不是其中的一个子群。<br>要算子群的阶，需要知道：</p><ol><li>子群的阶就是子群中的元素个数，等价于 $nP=0$，其$n$是正整数，且$n$是其中最小的1个，这个$n$就是子群的阶。</li><li>根据拉格朗日定理，子群$P$的阶，是父群阶的一个因子，比如一个椭圆曲线有$N$个元素，它的一个子群有$n$个元素，$n$能整除$N$</li></ol><p>接着我们开始算子群P的阶：</p><ol><li>用<code>Schoof&#39;s</code>算法计算椭圆曲线的阶$N$</li><li>找出$N$的所有因子</li><li>对$N$的每一个因子$n$，计算$nP$</li><li>找出使$nP=0$的最小的$n$，这个$n$就是子群的阶.</li></ol><p>比如对$GP(37)$有限域上的椭圆曲线 $y^2 = x^3 - x + 3$,  它的阶$N=42$，子群可能有的阶$n = 1, 2, 3, 6, 7, 14, 21, 42$,  如果我们取基准点$P = (2, 3)$，那么</p><script type="math/tex; mode=display">P != 0, 2P !=0, 3P != 0, 6P!= 0, 7P=0</script><p>那么就说，$P$的阶是$n = 7$</p><h2 id="13-找一个基准点"><a href="#13-找一个基准点" class="headerlink" title="13. 找一个基准点"></a>13. 找一个基准点</h2><p>对ECC算法来说，我们希望子群拥有更高的阶。<br>我们先计算椭圆曲线的阶$N$，找一个比较大的因子$n$，然后根据$n$找出一个合适的基准点。<br>也就是说，我们先找子群的阶，再根据子群的阶找其中的基准点。而不是先找基准点，再算子群的阶。</p><p>再加一个信息：根据拉格朗日定理，$h = N/n$肯定是个整数（因为$n$是$N$的一个因子）。这个$h$叫做子群的协因子(cofactor).</p><p>对一个椭圆曲线上的任意一点来说， $NP = 0$,因为$N$总是任何一个$n$的倍数；<br>也就是 $n(hP) = 0$<br>取$n$是素数，点$G = hP$生成一个阶为$n$的子群。<br>这样，我们就根据选择的阶$n$，算出了一个基准点。</p><h2 id="14-离散对数"><a href="#14-离散对数" class="headerlink" title="14. 离散对数"></a>14. 离散对数</h2><p>在连续的椭圆曲线上，我们如果知道$P$和$Q$很难算出$k$，使得$Q = kP$，<br>那么，<br>在有限域上的椭圆曲线，这个也是很多难的，叫做椭圆曲线的离散对数问题。</p><p>ECC有意思的一点是，这个离散对数问题“更难”，也就是要达到相同的加密强度，$k$的位数可以更少。这也是有RSA，还有开发ECC的原因。</p><h2 id="15-定义一个ECC的域需要的参数"><a href="#15-定义一个ECC的域需要的参数" class="headerlink" title="15. 定义一个ECC的域需要的参数"></a>15. 定义一个ECC的域需要的参数</h2><ol><li>有限域的大小是个素数$p$</li><li>椭圆曲线中的系数$a,b$</li><li>子群基准点$G$</li><li>子群的阶$n$</li><li>子群的协因子$h$</li></ol><p>所以，定义一个我们ECC需要的问题域需要6个因子$（p, a, b , G, n, h）$</p><h2 id="16-随机曲线"><a href="#16-随机曲线" class="headerlink" title="16. 随机曲线"></a>16. 随机曲线</h2><p>并不是所有的椭圆曲线上的离散对数都那么难，比如$p = hn$的椭圆曲线就可以用<code>Smart</code>方法攻击。而且我们也不知道还有没有哪些椭圆曲线的攻击方法我们没发现。<br>一个更具密码学强度的方法是，我们选一个随机因子$S$，对$S$取hash，然后衍生出$a、b$或者$G$，或者两者都用$S$生成，那么攻击者就不知道我们用的是什么参数，会更安全些。<br>但是，NIST规定了一些$S$，我们也不知道$S$是不是精心挑选的。。。。。。</p><h2 id="17-ECC算法"><a href="#17-ECC算法" class="headerlink" title="17. ECC算法"></a>17. ECC算法</h2><ol><li>私钥就是从$[1,n-1]$($n$是子群的阶)中随机挑选的一个整数$d$</li><li>公钥就是点$H = dG$($G$是子群的基准点)</li></ol><p>知道$d$和$G$，算出$H$很简单，但反过来就很难。<br>这是个非对称加密算法，基于此，衍生出两个算法ECDH（用于密钥交换），ECDSA（用于签名）</p><h2 id="18-ECDH"><a href="#18-ECDH" class="headerlink" title="18. ECDH"></a>18. ECDH</h2><ol><li>Alice和Bob各自生成自己的公私钥，Alice的私钥是$d_A$, 公钥是$H_A = d_A \cdot G$，Bob的是$d_B$和$H_B=d_B \cdot G$。注意Alice和Bob用的是同一个有限域上的同一个椭圆曲线的同一个基准点$G$</li><li>Alice和bob在一个未加密的通道上交换公钥$H_A$和$H_B$,</li><li>Alice计算$S = d_A \cdot H_B$, Bob计算$S = d_B \cdot H_A$, 两个计算出来的$S$是一样的</li></ol><p>这样Alice和Bob就得出了同一个$S$，就可用于对称加密了。</p><p>一个例子</p><ul><li>$p$ = 0xffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f</li><li>$a$ = 0</li><li>$b$ = 7</li><li>$x_G$ = 0x79be667e f9dcbbac 55a06295 ce870b07 029bfcdb 2dce28d9 59f2815b 16f81798</li><li>$y_G$ = 0x483ada77 26a3c465 5da4fbfc 0e1108a8 fd17b448 a6855419 9c47d08f fb10d4b8</li><li>$n$ = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141</li><li>$h$ = 1<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Curve: secp256k1</span><br><span class="line">Alice's private key: 0xe<span class="number">32868331</span>fa8ef<span class="number">0138</span>de0de<span class="number">85478346</span>aec5e<span class="number">3912</span>b<span class="number">6029</span>ae<span class="number">7169</span>1c<span class="number">384237</span>a3eeb</span><br><span class="line">Alice's public key: (<span class="number">0</span>x86b1aa5120f079594348c67647679e7ac4c365b2c01330db782b0ba611c1d677, <span class="number">0</span>x5f4376a23eed633657a90f385ba21068ed7e29859a7fab09e953cc5b3e89beba)</span><br><span class="line">Bob's private key: 0xcef<span class="number">147652</span>aa<span class="number">9016</span>2e1fff9cf07f<span class="number">2605</span>ea<span class="number">0552</span>9ca215a<span class="number">0435</span>0a98ecc24aa<span class="number">3434</span>2</span><br><span class="line">Bob's public key: (<span class="number">0</span>x4034127647bb7fdab7f1526c7d10be8b28174e2bba35b06ffd8a26fc2c20134a, <span class="number">0</span>x9e773199edc1ea792b150270ea3317689286c9fe239dd5b9c5cfd9e81b4b632)</span><br><span class="line">Shared secret: (<span class="number">0</span>x3e2ffbc3aa8a2836c1689e55cd169ba638b58a3a18803fcf7de153525b28c3cd, <span class="number">0</span>x43ca148c92af58ebdb525542488a4fe6397809200fe8c61b41a105449507083)</span><br></pre></td></tr></table></figure></li></ul><p>PS：每次都生成新的公私钥，就叫ECDHE，E表示Ephermeral，瞬时的，短暂的</p><h2 id="19-ECDSA"><a href="#19-ECDSA" class="headerlink" title="19. ECDSA"></a>19. ECDSA</h2><p>Alice使用私钥$d_A$签名消息，Bob使用Alice的公钥$H_A$验签。<br>ECDSA需要对消息的摘要进行签名，而不是对任意长度的消息签名。消息摘要需要截断到跟子群的阶$n$一样长度的位数，截断的摘要用作为一个整数$z$</p><p>签名:</p><ol><li>从$[1,n-1]$($n$是子群的阶)中随机选择一个整数$k$</li><li>计算$P=kG$（$G$是子群的基准点）</li><li>计算$r = x_P  \text{ mod }  n$($x_P$是$P$的x坐标)</li><li>如果$r=0$，重新选择$k$</li><li>计算$s = k^{-1}(z + r \cdot d_A)  \text{ mod }  n$（$d_A$是Alice的私钥，$k^{-1}$是$k$的乘法倒数 mod n）</li><li>如果$s=0$，重新选择$k$</li></ol><p>$(r,s)$组成的对儿就是签名</p><p>验签：</p><ol><li>计算$u_1 = s^{-1} \cdot z  \text{ mod }  n$</li><li>计算$u_2 = s^{-1} \cdot r  \text{ mod }  n$</li><li>计算点$P = u_1G+u_2H_A$<br>如果$r = x_P \text{ mod } n$， 就说明签名正确</li></ol><p>例子<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Curve</span>: secp256k1</span><br><span class="line">Private <span class="attribute">key</span>: <span class="number">0</span>x9f4c9eb899bd86e0e83ecca659602a15b2edb648e2ae4ee4a256b17bb29a1a1e</span><br><span class="line">Public <span class="attribute">key</span>: (<span class="number">0</span>xabd9791437093d377ca25ea974ddc099eafa3d97c7250d2ea32af6a1556f92a, <span class="number">0</span>x3fe60f6150b6d87ae8d64b78199b13f26977407c801f233288c97ddc4acca326)</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hello!'</span></span><br><span class="line"><span class="attribute">Signature</span>: (<span class="number">0</span>xddcb8b5abfe46902f2ac54ab9cd5cf205e359c03fdf66ead1130826f79d45478, <span class="number">0</span>x551a5b2cd8465db43254df998ba577cb28e1ee73c5530430395e4fba96610151)</span><br><span class="line"><span class="attribute">Verification</span>: signature matches</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hi there!'</span></span><br><span class="line"><span class="attribute">Verification</span>: invalid signature</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hello!'</span></span><br><span class="line">Public <span class="attribute">key</span>: (<span class="number">0</span>xc40572bb38dec72b82b3efb1efc8552588b8774149a32e546fb703021cf3b78a, <span class="number">0</span>x8c6e5c5a9c1ea4cad778072fe955ed1c6a2a92f516f02cab57e0ba7d0765f8bb)</span><br><span class="line"><span class="attribute">Verification</span>: invalid signature</span><br></pre></td></tr></table></figure></p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ </a>: 这个系列非常好，基本是翻译了这篇原文.</li><li><a href="https://tools.ietf.org/html/rfc8422" target="_blank" rel="noopener">RFC8442-Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</a>: 定义了TLS1.2及以前的协议使用的ECC曲线都有哪些，比如X25591,secp256r1等.</li><li><a href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener">RFC7748-Elliptic Curves for Security</a>: 具体定义了X25519,X448曲线算法.</li><li><a href="https://tools.ietf.org/html/rfc6090" target="_blank" rel="noopener">RFC6090-Fundamental Elliptic Curve Cryptography Algorithms</a>: ECC基本定义.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对TLS1.3中用到的ECC相关算法，比如ECDH, ECDSA, X25519等进行一下基础说明，起码知道group、curve之类的是什么意思。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>HKDF算法</title>
    <link href="http://suntus.github.io/2019/05/09/HKDF%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/05/09/HKDF算法/</id>
    <published>2019-05-09T11:14:44.000Z</published>
    <updated>2020-04-24T11:59:38.519Z</updated>
    
    <content type="html"><![CDATA[<p>　　是tls1.3中关于密钥生成的重要的基础算法，跟密钥推导密切相关。<br><a id="more"></a><br>　　HKDF叫<code>HMAC-based KDF(key derivation function)，基于HMAC的密钥推导函数</code>，所以我们先认识HMAC算法。</p><h2 id="1-HMAC"><a href="#1-HMAC" class="headerlink" title="1. HMAC"></a>1. HMAC</h2><p>　　基于一个共同密钥，在两个对端之间提供消息完整性确认的机制叫<code>&quot;message authentication codes(MAC)，消息认证码&quot;</code>。其实就是将消息进行hash，得到的hash值附加到消息之后，随消息一起发送，对端接收后，同样进行hash，来验证消息是否被篡改——关键点在不同数据得到的hash值一定不同——其中得到的hash值就是MAC（在别的语境里边也叫消息摘要）。另外，为了避免使用同样的hash函数对相同数据进行操作总是得出同样的摘要，额外加入一个密钥，这样使用不同密钥就可以得出不同的MAC，当然，这个密钥是两个对端都知道的。这样，我们就得到了基于加密hash的消息完整性认证的算法——Hash-based MAC。</p><h3 id="1-1-HMAC定义如下："><a href="#1-1-HMAC定义如下：" class="headerlink" title="1.1 HMAC定义如下："></a>1.1 HMAC定义如下：</h3><p>输入：</p><ol><li>使用的加密hash函数H，输出长度为hashLen</li><li>使用的密钥K,长度hashLen &lt;= Klen &lt;= 64，如果K的长度超过64，则先用hash函数进行一次hash，用得到的值作为K</li><li>需要认证的数据text</li></ol><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息完整性认证码HMAC</span><br></pre></td></tr></table></figure></p><p>过程：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义 ipad = <span class="number">64</span>个<span class="number">0</span>x36, opad = <span class="number">64</span>个<span class="number">0</span>x5c</span><br><span class="line">HMAC = HMAC-Hash(H, K, <span class="built_in">text</span>) = H(K <span class="built_in">XOR</span> opad, H(K <span class="built_in">XOR</span> ipad, <span class="built_in">text</span>))</span><br></pre></td></tr></table></figure></p><p>目的：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为<span class="built_in">text</span>生成一个HMAC消息完整性认证码，输出长度就是hash函数的输出长度</span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf1.png" alt="HMAC"></p><h2 id="2-HKDF"><a href="#2-HKDF" class="headerlink" title="2. HKDF"></a>2. HKDF</h2><p>　　HKDF的主要目的使用原始的密钥材料,派生出一个或更多个能达到密码学强度的密钥(主要是保证随机性)——就是将较短的密钥材料扩展成较长的密钥材料，过程中需要保证随机性。<br>　　HKDF包含两个基本模块,或者说两个基本使用步骤:<code>1. 提取 Extract, 2. 扩展 Expand</code>。</p><ol><li><strong><em>提取</em></strong>：使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥</li><li><strong><em>扩展</em></strong>：使用第1步骤提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。</li></ol><h3 id="2-1-HKDF-Extract"><a href="#2-1-HKDF-Extract" class="headerlink" title="2.1 HKDF-Extract"></a>2.1 HKDF-Extract</h3><p>输入：</p><pre><code>1. HMAC使用的hash函数H，H输出长度是hashLen2. 原始密钥材料IKM(input keying material)3. 另外的随机源salt, 如果没有，默认是hashLen长度的0串</code></pre><p>输出:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashLen长度的伪随机密钥prk(pseudorandom <span class="built_in">key</span>)</span><br></pre></td></tr></table></figure></p><p>过程:<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prk = HKDF-<span class="keyword">Extract</span>(H, salt, IKM) = HMAC-<span class="keyword">Hash</span>(H, salt, IKM)</span><br><span class="line">其实就相当于用salt作为HMAC-<span class="keyword">Hash</span>的<span class="keyword">K</span>，对IKM进行消息完整性认证</span><br></pre></td></tr></table></figure></p><p>目的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用salt增加IKM的随机性</span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf2.png" alt="HKDF-Extract"></p><h3 id="2-2-HKDF-Expand"><a href="#2-2-HKDF-Expand" class="headerlink" title="2.2 HKDF-Expand"></a>2.2 HKDF-Expand</h3><p>输入：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>HMAC使用的hash函数H，H输出长度是hashLen</span><br><span class="line"><span class="bullet">2. </span>第一步生成的PRK</span><br><span class="line"><span class="bullet">3. </span>另外的随机元info，可以为空</span><br><span class="line"><span class="bullet">4. </span>期望生成的密钥长度L</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L长度的OKM(<span class="keyword">output</span> keying material)</span><br></pre></td></tr></table></figure></p><p>过程:<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">N</span> = ceil(L/hashLen)</span><br><span class="line">    <span class="built_in">T</span> = <span class="built_in">T</span>(<span class="number">1</span>) || <span class="built_in">T</span>(<span class="number">2</span>) || <span class="built_in">T</span>(<span class="number">3</span>) || ... || <span class="built_in">T</span>(<span class="built_in">N</span>)</span><br><span class="line">    OKM = <span class="built_in">T</span>的前L字节</span><br><span class="line"></span><br><span class="line">    <span class="built_in">T</span>(<span class="number">0</span>) = 空</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">1</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">0</span>) || <span class="built_in">info</span> || <span class="number">0</span>x01)</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">2</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">1</span>) || <span class="built_in">info</span> || <span class="number">0</span>x02)</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">3</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">2</span>) || <span class="built_in">info</span> || <span class="number">0</span>x03)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>目的:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将PRK扩展到指定长度L，同时保持密码学强度<span class="comment">(随机性)</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf3.png" alt="HKDF-Expand"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol><li>HKDF是密钥推导算法，根据一个原始密钥材料，推导出指定长度的密钥；</li><li>HKDF基于HMAC；</li><li>HMAC是基于加密hash函数的消息完整性认证算法，主要目的是认证消息完整性。在这里被用于增加原始密钥材料的随机性；</li><li>HKDF包含两步：(1) 提取Extract, (2) 扩展Expand；</li><li>HKDF-Extract就是HMAC，取IKM的认证码，也就相当于用额外的随机源salt(Key)增加了IKM(text)的随机性；</li><li>HKDf-Expand就是将短密钥变长，同时保证随机性。</li></ol><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc5869" target="_blank" rel="noopener">RFC5869: HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a></li><li><a href="https://www.ietf.org/rfc/rfc2104.txt" target="_blank" rel="noopener">RFC2104: HMAC: Keyed-Hashing for Message Authentication</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　是tls1.3中关于密钥生成的重要的基础算法，跟密钥推导密切相关。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>顺时针规则--C语言声明</title>
    <link href="http://suntus.github.io/2017/12/19/%E9%A1%BA%E6%97%B6%E9%92%88%E8%A7%84%E5%88%99--C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/"/>
    <id>http://suntus.github.io/2017/12/19/顺时针规则--C语言声明/</id>
    <published>2017-12-19T05:44:49.000Z</published>
    <updated>2020-04-24T11:59:38.543Z</updated>
    
    <content type="html"><![CDATA[<p>The “Clockwise/Spiral Rule”<br>By David Anderson</p><p>每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!<br><a id="more"></a><br>该规则只有简单的3步：</p><ol><li><p>从未知元素开始，沿顺时针/螺旋方向移动；当遇到如下元素的时候，用相应的自然语言陈述出来：</p><ul><li>[X] 或者 [] =&gt; 大小为…的数组X 或 未知大小数组的…(Array X size of… or Array undefined size of…)</li><li>(type1, type2) =&gt; 传入type1和type2参数、返回…的函数(function passing type1 and type2 returning…)</li><li>* =&gt; 指向…的指针(pointer(s) to…)</li></ul></li><li><p>一直沿着顺时针往下进行，直到覆盖了所有的元素。</p></li><li>括号内的永远优先!</li></ol><p>其实对英文来说就是不断在后边加定语，但对汉语来说，就需要不断在前边加定语。</p><h2 id="1-简单声明"><a href="#1-简单声明" class="headerlink" title="1.简单声明"></a>1.简单声明</h2><pre><code>                 +-------+                 | +-+   |                 | ^ |   |            char *str[10];             ^   ^   |   |             |   +---+   |             +-----------+</code></pre><p>首先需要问的是：<code>str</code>是什么？</p><blockquote><p>str 是个…(str is an…)</p><ul><li>我们从<code>str</code>开始顺时针移动，碰到的第一个元素是<code>[</code>，这意味着我们碰到了个数组，于是就有…<br>str是个大小是10、…的数组(str is an array 10 of…)</li><li>继续顺时针，下一个遇到的是<code>*</code>,这意味着我们碰到了个指针，就有…<br>str是个大小是10、指向…指针的数组(str is an array 10 of pointers to…)</li><li>继续，下一个是该行结尾<code>;</code>；继续，接下来是<code>char</code>，因此…<br>str是个大小是10、指向字符的指针的数组(str is an array 10 of pointers to char)</li></ul></blockquote><h2 id="2-指向函数的指针的声明"><a href="#2-指向函数的指针的声明" class="headerlink" title="2.指向函数的指针的声明"></a>2.指向函数的指针的声明</h2><pre><code>                 +--------------------+                 | +---+              |                 | |+-+|              |                 | |^ ||              |            char *(*fp)( int, float *);             ^   ^ ^  ||              |             |   | +--+|              |             |   +-----+              |             +------------------------+</code></pre><p>还是一样，首先要问：<code>fp</code>是什么？</p><blockquote><p>fp 是个…(fp is a…)</p><ul><li>顺时针移动，首先看到了<code>)</code>，因此<code>fp</code>就在括号中了，我们在括号中顺时针移动，下一个看到的是<code>*</code>，因此…<br>fp 是个指向…的指针(fp is a pointer to…)</li><li>跳出括号，继续顺时针转动，看到了<code>(</code>，这表明遇到了一个函数，就有…<br>fp 是个指向传入参数是int和指向float的指针、返回值是…的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning…)</li><li>继续顺时针，看到了<code>*</code>，说明…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向…的指针的函数的指针(fp is a pointer to a funciton passing an int and a pointer to float returning a pointer to…)</li><li>继续，遇到<code>;</code>；再继续，遇到了<code>char</code>，因此…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向char的指针的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char)</li></ul></blockquote><h2 id="3-终极形态"><a href="#3-终极形态" class="headerlink" title="3.终极形态"></a>3.终极形态</h2><pre><code>                  +-----------------------------+                  |                  +---+      |                  |  +---+           |+-+|      |                  |  ^   |           |^ ||      |            void (*signal(int, void (*fp)(int)))(int);             ^    ^      |      ^    ^  ||      |             |    +------+      |    +--+|      |             |                  +--------+      |             +----------------------------------+</code></pre><p>依然是:<code>signal</code>是什么?<br>注意<code>signal</code>在括号中，需要先解决它</p><ul><li>顺时针移动，首先遇到<code>(</code>，因此…<blockquote><p>signal是个传入参数为int和…,返回…的函数(signal is a function passing an int and a…)</p></blockquote></li><li>接着，我们可以对<code>fp</code>用相同的规则，<code>fp</code>是什么？<code>fp</code>在括号中，首先遇到的是<code>*</code>，于是…<blockquote><p>fp是个指向…的指针(fp is a pointer to…)</p></blockquote></li><li>继续会遇到<code>(</code>，就有…<blockquote><p>fp是个指向传入参数是int、返回…的函数的指针(fp is a pointer to a function passing int returning…)</p></blockquote></li><li>接着，看到了<code>void</code>…<blockquote><p>fp 是个指向传入参数是int、返回值为空(void)的函数的指针(fp is a pointer to a function passing int returning nothing (void))</p></blockquote></li><li>现在结束了对<code>fp</code>的解析，接着看<code>signal</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为…的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning…)</p></blockquote></li><li>现在还在括号内，接着的元素是<code>*</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为指向…的指针的函数(signal is a function passing an int and a pointer to a funciton passing an int returning nothing(void) returning a pointer to…)</p></blockquote></li><li>再继续，碰到了<code>(</code>…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为…的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning…)</p></blockquote></li><li>终于到最后了，我们只剩下<code>void</code>这一个元素了，最终<code>signale</code>的定义为…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为空的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning nothing(void))</p></blockquote></li></ul><h2 id="const和volatile的例子"><a href="#const和volatile的例子" class="headerlink" title="const和volatile的例子"></a><code>const</code>和<code>volatile</code>的例子</h2><p>规则一样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *chptr:</span><br></pre></td></tr></table></figure></p><p><code>chptr</code>是个指向一个char常量(constant)的指针(chptr is a pointer to a char constant)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向char的常量指针(chptr is a constant pointer to char)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向一个char原子(volatile)的常量指针(chptr is a constant pointer to a char volatile)</p><hr><p>C的复杂声明其实就不断加定语，但是这个定语在修饰的是哪个主语，需要按照顺时针/螺旋规则来解释。熟悉了就好。</p><hr><p>原文: <a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The ``Clockwise/Spiral Rule’’</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The “Clockwise/Spiral Rule”&lt;br&gt;By David Anderson&lt;/p&gt;
&lt;p&gt;每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="tr" scheme="http://suntus.github.io/tags/tr/"/>
    
  </entry>
  
  <entry>
    <title>软件的12个要素</title>
    <link href="http://suntus.github.io/2017/12/08/%E8%BD%AF%E4%BB%B6%E7%9A%8412%E4%B8%AA%E8%A6%81%E7%B4%A0/"/>
    <id>http://suntus.github.io/2017/12/08/软件的12个要素/</id>
    <published>2017-12-08T09:37:57.000Z</published>
    <updated>2020-04-24T11:59:38.539Z</updated>
    
    <content type="html"><![CDATA[<ul><li>由Heroku创始人Adam Wiggins在2012年发布。</li><li>是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。</li><li>使用于任意语言和后端服务开发的应用程序。</li><li>最佳阅读人员：服务器开发和运维人员。</li><li>中心思想是隔离。</li></ul><a id="more"></a><h2 id="1-基准代码"><a href="#1-基准代码" class="headerlink" title="1.基准代码"></a>1.基准代码</h2><p>1个模块只有1份基准代码，多个模块组成的是一个分布式系统。基准代码应该用版本管理工具加以控制，每个基准代码应该独占1个库，同属1个系统的多个基准代码库可以加入组。</p><h2 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2.依赖"></a>2.依赖</h2><ul><li>显示声明依赖。</li><li>通过依赖隔离工具来确保程序不会调用系统种存在但清单中未声明的依赖项。这种做法应该统一应用到开发和生产环境。</li></ul><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><ul><li>与代码分离。</li><li>推荐保存到环境变量。</li></ul><h2 id="4-后端服务"><a href="#4-后端服务" class="headerlink" title="4.后端服务"></a>4.后端服务</h2><ul><li>把后端服务当做附加资源。如数据库，MQ,SMTP，缓存等。</li><li>应该保证应用在不改动任何代码的情况下，将本地mysql换成第三方服务(如Amazon RDS)</li></ul><h2 id="5-构建，发布，运行"><a href="#5-构建，发布，运行" class="headerlink" title="5.构建，发布，运行"></a>5.构建，发布，运行</h2><p>严格分离构建和运行<br>基准代码转换成一份部署需要三个阶段：<br>1）构建阶段：将代码转化成可执行包的过程。构建时会使用指定版本的代码，获取和打包依赖项，编译成二进制文件和资源文件<br>2）发布阶段：将构建结果和当前部署所需配置相结合，并能够立即在运行环境中投入使用<br>3）运行阶段：只针对选定的发布版本，在执行环境中启动一系列运行程序进程</p><h2 id="6-进程"><a href="#6-进程" class="headerlink" title="6.进程"></a>6.进程</h2><ul><li>系统可以有1个或多个进程，进程必须无状态且无共享，任何需要持久化的数据都存储在后端服务中（比如数据库）。</li><li>内存和磁盘可以作为进程在进行某种事务型操作时的缓存（比如下载一个很大的文件）。不考虑这些缓存的内容是不是可以保留给之后的请求使用。</li><li>如果需要在内存中保存数据，优先考虑使用redis等内存数据库。</li></ul><h2 id="7-端口绑定"><a href="#7-端口绑定" class="headerlink" title="7.端口绑定"></a>7.端口绑定</h2><ul><li>使用端口提供服务。</li></ul><h2 id="8-并发"><a href="#8-并发" class="headerlink" title="8.并发"></a>8.并发</h2><ul><li>应该更多考虑水平扩展的可能。</li><li>不需要自己设置守护进程，而应交给其他进程托管系统。</li></ul><h2 id="9-易处理"><a href="#9-易处理" class="headerlink" title="9.易处理"></a>9.易处理</h2><ul><li>可以瞬间开启或停止，有利于快速、弹性的伸缩应用</li><li>进程接收到终止信号会优雅的终止。对网络进程，优雅就是停止监听服务的端口，拒绝信的请求，并执行当前已接收到的请求，然后退出。对worker进程，优雅终止就是当前任务退出队列。任务都应该可重复，使重复操作幂等实现。</li><li>应该可以处理 意外的、不优雅的终止。</li></ul><h2 id="10-开发环境与线上环境等价"><a href="#10-开发环境与线上环境等价" class="headerlink" title="10.开发环境与线上环境等价"></a>10.开发环境与线上环境等价</h2><p>尽可能保持开发、预发布、线上环境相同<br>开发环境和线上环境的差异有：</p><ol><li>时间差异：开发的代码可能几天，几周才会上线</li><li>人员差异：开发人员编写代码，运维人员部署代码</li><li>工具差异： 开发人员或许使用nginx，sqlite， osx，线上环境使用apache，mysql，linux</li></ol><h2 id="11-日志"><a href="#11-日志" class="headerlink" title="11.日志"></a>11.日志</h2><p>把日志当做事件流。<br>日志使应用程序运行的动作变得透明。服务器环境中，日志通常被写在文件中，但这只是一种输出格式。<br>日志应该是事件流的汇总，将所有运行中进程和后端服务的数据流按照时间顺序收集起来。<br>应用本身不应考虑存储自己的数据流，不应该试图去写或管理日志文件，都应该直接输出的标准输出（stdout）。最后汇总到统一的日志处理系统中。</p><h2 id="12-管理进程"><a href="#12-管理进程" class="headerlink" title="12.管理进程"></a>12.管理进程</h2><p>后台管理任务当做一次性进程运行。</p><hr><p>参考：<br><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">The Twelve-Factor App</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;由Heroku创始人Adam Wiggins在2012年发布。&lt;/li&gt;
&lt;li&gt;是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。&lt;/li&gt;
&lt;li&gt;使用于任意语言和后端服务开发的应用程序。&lt;/li&gt;
&lt;li&gt;最佳阅读人员：服务器开发和运维人员。&lt;/li&gt;
&lt;li&gt;中心思想是隔离。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ongoing" scheme="http://suntus.github.io/tags/ongoing/"/>
    
  </entry>
  
  <entry>
    <title>用到的docker</title>
    <link href="http://suntus.github.io/2017/12/08/%E7%94%A8%E5%88%B0%E7%9A%84docker/"/>
    <id>http://suntus.github.io/2017/12/08/用到的docker/</id>
    <published>2017-12-08T00:34:42.000Z</published>
    <updated>2020-04-24T11:59:38.540Z</updated>
    
    <content type="html"><![CDATA[<p>都是在ubuntu系统中<br><a id="more"></a></p><h2 id="1-修改container时区"><a href="#1-修改container时区" class="headerlink" title="1.修改container时区"></a>1.修改container时区</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加shell命令</span><br><span class="line">echo <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone </span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span>同步主机时区</span><br><span class="line">启动时挂载`/etc/localtime`文件</span><br></pre></td></tr></table></figure><p>docker run -it -v /etc/localtime:/etc/localtime <img><br>```</p><hr><p>参考</p><ol><li><a href="https://brickyang.github.io/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/" target="_blank" rel="noopener">时区</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是在ubuntu系统中&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>docker search时列出tag</title>
    <link href="http://suntus.github.io/2017/12/07/docker%20search%E6%97%B6%E5%88%97%E5%87%BAtag/"/>
    <id>http://suntus.github.io/2017/12/07/docker search时列出tag/</id>
    <published>2017-12-07T02:24:23.000Z</published>
    <updated>2020-04-24T11:59:38.522Z</updated>
    
    <content type="html"><![CDATA[<p>使用这个脚本docker-show-repo-tag.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple script that will display docker repository tags.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#   $ docker-show-repo-tags.sh ubuntu centos</span></span><br><span class="line"><span class="keyword">for</span> Repo <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">  curl -s -S <span class="string">"https://registry.hub.docker.com/v2/repositories/library/<span class="variable">$Repo</span>/tags/"</span> | \</span><br><span class="line">    sed -e <span class="string">'s/,/,\n/g'</span> -e <span class="string">'s/\[/\[\n/g'</span> | \</span><br><span class="line">    grep <span class="string">'"name"'</span> | \</span><br><span class="line">    awk -F\<span class="string">" '&#123;print <span class="variable">$4</span>;&#125;' | \</span></span><br><span class="line"><span class="string">    sort -fu | \</span></span><br><span class="line"><span class="string">    sed -e "</span>s/^/<span class="variable">$&#123;Repo&#125;</span>:/<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这样用:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./docker-show-repo-tags.sh ubuntu centos</span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">14.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">16.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">17.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span>latest</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty<span class="number">-20171117</span></span><br><span class="line"><span class="symbol">ubuntu:</span>xenial</span><br><span class="line"><span class="symbol">ubuntu:</span>xenial<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">ubuntu:</span>zesty</span><br><span class="line"><span class="symbol">ubuntu:</span>zesty<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.7</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.8</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">7</span></span><br><span class="line"><span class="symbol">centos:</span>centos6</span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.6</span></span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.7</span></span><br><span class="line"><span class="symbol">centos:</span>centos7</span><br><span class="line"><span class="symbol">centos:</span>latest</span><br></pre></td></tr></table></figure></p><hr><p>参考：<a href="https://stackoverflow.com/a/34054903/2955061" target="_blank" rel="noopener">https://stackoverflow.com/a/34054903/2955061</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用这个脚本docker-show-repo-tag.sh&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Simple script that will display docker repository tags.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Usage:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#   $ docker-show-repo-tags.sh ubuntu centos&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; Repo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; $* ; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  curl -s -S &lt;span class=&quot;string&quot;&gt;&quot;https://registry.hub.docker.com/v2/repositories/library/&lt;span class=&quot;variable&quot;&gt;$Repo&lt;/span&gt;/tags/&quot;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sed -e &lt;span class=&quot;string&quot;&gt;&#39;s/,/,\n/g&#39;&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&#39;s/\[/\[\n/g&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grep &lt;span class=&quot;string&quot;&gt;&#39;&quot;name&quot;&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    awk -F\&lt;span class=&quot;string&quot;&gt;&quot; &#39;&amp;#123;print &lt;span class=&quot;variable&quot;&gt;$4&lt;/span&gt;;&amp;#125;&#39; | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sort -fu | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sed -e &quot;&lt;/span&gt;s/^/&lt;span class=&quot;variable&quot;&gt;$&amp;#123;Repo&amp;#125;&lt;/span&gt;:/&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker精简镜像体积</title>
    <link href="http://suntus.github.io/2017/12/07/docker%E7%B2%BE%E7%AE%80%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"/>
    <id>http://suntus.github.io/2017/12/07/docker精简镜像体积/</id>
    <published>2017-12-07T01:58:20.000Z</published>
    <updated>2020-04-24T11:59:38.523Z</updated>
    
    <content type="html"><![CDATA[<ol><li>命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。</li><li>找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。<a id="more"></a></li><li>ubuntu安装软件的时候，区分 build时依赖和runtime时依赖，build的依赖（比如gcc,g++,cmake,make等等）可以在最后删除，runtime的当然就不能删除啦。</li><li>安装时使用<code>--no-install-recommands</code>选项，也就是<code>apt-get install -y --no-install-recommands  cmake3</code>，不安装apt-get推荐的依赖，只相信我们自己 : )</li><li>删除的时候用这个: <code>apt-get purge -y --auto-remove $buildDeps</code>，删的更干净。</li><li>删除apt-get安装时候的一些日志： <code>rm /var/log/dpkg.log /var/log/alternatives.log /var/log/apt/*.log</code>。</li><li>记得把安装时候不需要的源码删掉，能少一点儿是一点儿。</li></ol><hr><p>参考</p><ol><li><a href="http://blog.fleeto.us/translation/refactoring-dockerfile-image-size" target="_blank" rel="noopener">优化 Dockerfile，缩减镜像尺寸</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。&lt;/li&gt;
&lt;li&gt;找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>librdkafka相关</title>
    <link href="http://suntus.github.io/2017/12/04/librdkafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2017/12/04/librdkafka相关/</id>
    <published>2017-12-04T07:59:13.000Z</published>
    <updated>2020-04-24T11:59:38.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-offset管理"><a href="#1-offset管理" class="headerlink" title="1.offset管理"></a>1.offset管理</h2><p>kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个<code>__consumer_offsets</code>的topic中。<br>zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。<br><a id="more"></a><br>librdkafka支持两种offset管理方式：</p><ol><li>存放到本地文件</li><li>存放到集群中</li></ol><p>librdkafka consumer的high level API支持存放到broker中，low level API支持存放到本地文件</p><p><strong>存放到集群</strong><br>影响的配置有这么几个：</p><ul><li>group.id: 设置consumer组，因为offset是按组来管理的，所以必须有这个东西</li><li>enable.auto.commit: 设置是否自动保存，[true, false]</li><li>auto.commit.interval.ms: 自动保存的的时间，默认是5000(5s)</li></ul><p>下面是一段示例代码<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conf = rd_kafk<span class="built_in">a_conf</span>_new()<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"group.id"</span>,<span class="string">"hehe"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"enable.auto.commit"</span>,<span class="string">"true"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"auto.commit.interval.ms"</span>,<span class="string">"1000"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rk = rd_kafk<span class="built_in">a_new</span>(RD_KAFK<span class="built_in">A_CONSUMER</span>, conf, errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 创建个topic_partition list</span><br><span class="line">rtkp_list = rd_kafk<span class="built_in">a_topic</span>_partition_list_new(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"># 将名字为topic_test的topic添加到rtkp_list中，并将offset设置为RD_KAFK<span class="built_in">A_OFFSET</span>_STORED，也就是consumer上次存储在broker中的offset。rd_kafk<span class="built_in">a_topic</span>_partition_list_add()返回的是<span class="number">1</span>个rd_kafk<span class="built_in">a_topic</span>_partition_t。</span><br><span class="line">rd_kafk<span class="built_in">a_topic</span>_partition_list_add(rtkp_list,<span class="string">"topic_test"</span>,<span class="number">0</span>)-&gt;offset = RD_KAFK<span class="built_in">A_OFFSET</span>_STORED<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 这里是确定订阅哪个topic了</span><br><span class="line">rd_kafk<span class="built_in">a_assign</span>(rk, rtkp_list)<span class="comment">;</span></span><br><span class="line">while(<span class="number">1</span>)&#123;</span><br><span class="line">    msg  = rd_kafk<span class="built_in">a_consumer</span>_poll(rk, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用这个去查看存储的offset到哪儿了<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-consumer-offset-checker.sh --zookeeper localhost:2181 --topic topic_test  --group hehe</span><br><span class="line"></span><br><span class="line">Group           Topic                          Pid Offset          logSize         Lag             Owner</span><br><span class="line">hehe            topic_test                    0   6483667         1674985741      1668502074      none</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset就是当前存储的offset，logSize是当前最大的offset，lag是还没消费的msg个数</span></span><br></pre></td></tr></table></figure></p><p><strong>存放到本地</strong><br>诶，参考上边吧</p><h2 id="2-high-level-API多topic操作"><a href="#2-high-level-API多topic操作" class="headerlink" title="2.high level API多topic操作"></a>2.high level API多topic操作</h2><p>有时候需要在一个进程中订阅多个topic，并且每个topic需要单独操作，这时候就可以多申请几个<code>rd_kafka_topic_partition_list_t</code>，分别在每个<code>rd_kafka_topic_partition_list_t</code>中加入各自的topic，在订阅消息的时候，使用<code>rd_kafka_assign(rk, rktp_list);</code>来切换各个topic。就可以了。</p><h2 id="3-high-level-API手动存储consumer的offset"><a href="#3-high-level-API手动存储consumer的offset" class="headerlink" title="3.high level API手动存储consumer的offset"></a>3.high level API手动存储consumer的offset</h2><p>先设置这几个参数<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rk_conf的配置</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.offset.store = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 一般还会设置这个配置，指示在broker没有存储offset(最开始时候)或offset出现错误的时候，系统应该初始化的offset位置，默认是latest</span></span><br><span class="line"><span class="literal">auto</span>.offset.reset = [earliest, latest, <span class="literal">none</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始时候topic_conf的几个配置会让人迷惑，auto.commit.enable 只针对 low level API, high level API需要使用rk_conf的全局配置，enable.autom.commit是auto.commit.enable的别名</span></span><br><span class="line"><span class="literal">auto</span>.commit.enable = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>操作的话，需要用到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个是实际将offset提交到broker的操作，async为false的时候，该操作阻塞。</span></span><br><span class="line"><span class="comment">// 两个的区别是，第一个可以控制提交的offset的具体值，第二个只能提交msg的offset，不能手动控制。</span></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_topic_partition_list_t</span> *offsets, <span class="keyword">int</span> async);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit_message(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_message_t</span> *rkmessage, <span class="keyword">int</span> async);</span><br></pre></td></tr></table></figure></p><p>另外，还有个跟offset相关的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_offset_store(<span class="keyword">rd_kafka_topic_t</span> *rkt,</span><br><span class="line">                                          <span class="keyword">int32_t</span> partition, <span class="keyword">int64_t</span> offset);</span><br></pre></td></tr></table></figure></p><p>这个函数只是把offset提交到内存，并不是提交到broker存储起来，所以还是需要调用*commit()函数</p><p><strong>注意：如果多topic切换的时候，需要先commit，再切换，否则切换回来还是会从原先的offset开始读取消息。</strong></p><hr><p>参考:</p><ol><li><a href="http://www.cnblogs.com/smartloli/p/6266453.html" target="_blank" rel="noopener">kafka的offset管理</a></li><li><a href="https://github.com/edenhill/librdkafka/wiki/Consumer-offset-management" target="_blank" rel="noopener">librdkafka的一些说明</a></li><li><a href="https://github.com/arnaud-lb/php-rdkafka/issues/87" target="_blank" rel="noopener">关于high level API手动管理offset的讨论</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-offset管理&quot;&gt;&lt;a href=&quot;#1-offset管理&quot; class=&quot;headerlink&quot; title=&quot;1.offset管理&quot;&gt;&lt;/a&gt;1.offset管理&lt;/h2&gt;&lt;p&gt;kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个&lt;code&gt;__consumer_offsets&lt;/code&gt;的topic中。&lt;br&gt;zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="kafka" scheme="http://suntus.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>iniparser-C 配置解析</title>
    <link href="http://suntus.github.io/2017/11/24/iniparser-C%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://suntus.github.io/2017/11/24/iniparser-C配置解析/</id>
    <published>2017-11-24T02:08:59.000Z</published>
    <updated>2020-04-24T11:59:38.524Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ndevilla/iniparser" target="_blank" rel="noopener">https://github.com/ndevilla/iniparser</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>相当小，4个文件(2个c，2个h)，1500行左右</li><li>不依赖其他库</li><li>可重入，需要自己加锁实现线程安全</li></ul><p>另外，使用也相当简单<br><a id="more"></a></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先准备ini格式的配置文件<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[kafka]</span></span><br><span class="line"><span class="attr">broker</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9092</span></span><br><span class="line"><span class="attr">topic</span> = hello</span><br><span class="line"></span><br><span class="line"><span class="section">[db]</span></span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br></pre></td></tr></table></figure></p><p>解析<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">direcotyr *d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = iniparser_load(<span class="string">"haha.conf"</span>);</span><br><span class="line">iniparser_dump(d,<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// broker</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:broker"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"broker: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// topic</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:topic"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"topic: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.host</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"db:host"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.host: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.port</span></span><br><span class="line">n = iniparser_getint(d, <span class="string">"db:port"</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.port: %d\n"</span>, n);</span><br><span class="line"></span><br><span class="line">iniparser_freedict(d);</span><br></pre></td></tr></table></figure></p><p>主要的API<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取section个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getnsec</span><span class="params">(<span class="keyword">const</span> dictionary * d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第n个section的个数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getsecname</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出配置到文件，可重新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dumpsection_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * s, FILE * f)</span></span>;</span><br><span class="line"><span class="comment">// 导出配置到文件，方便查看，不可从新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getstring</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">const</span> <span class="keyword">char</span> * def)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">iniparser_getlongint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">long</span> <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">iniparser_getdouble</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">double</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getboolean</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置配置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_set</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry, <span class="keyword">const</span> <span class="keyword">char</span> * val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_unset</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_find_entry</span><span class="params">(<span class="keyword">const</span> dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入，清理</span></span><br><span class="line"><span class="function">dictionary * <span class="title">iniparser_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * ininame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_freedict</span><span class="params">(dictionary * d)</span></span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ndevilla/iniparser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ndevilla/iniparser&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相当小，4个文件(2个c，2个h)，1500行左右&lt;/li&gt;
&lt;li&gt;不依赖其他库&lt;/li&gt;
&lt;li&gt;可重入，需要自己加锁实现线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，使用也相当简单&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数组的二分算法模块--bisect</title>
    <link href="http://suntus.github.io/2017/11/03/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9D%97-bisect/"/>
    <id>http://suntus.github.io/2017/11/03/数组的二分算法模块-bisect/</id>
    <published>2017-11-03T06:09:06.000Z</published>
    <updated>2020-04-24T11:59:38.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两点作用："><a href="#1-两点作用：" class="headerlink" title="1.两点作用："></a>1.两点作用：</h2><p>1.插入时就维护好一个排好序的数组<br>2.数组非常大的时候速度较快</p><a id="more"></a><p>用着也很简单，只有2个操作：查找、插入，每个操作各有2个方法，分别是</p><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left(a, x, <span class="attribute">lo</span>=0, <span class="attribute">hi</span>=len(a))</span><br></pre></td></tr></table></figure><p>返回一个数组a的下标i，a[lo… i-1] &lt; x &lt;= a[i…hi]。也就是说在i左边的元素都比x小，在i及i右边的元素，都等于或大于x.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect</span>()</span><br></pre></td></tr></table></figure></p><p>这两个是一样的。<br>返回一个数组a的下标i，a[lo… i-1] &lt;= x &lt;a[i…hi]。也就是说在i左边的元素小于等于x，在i及i右边的元素，都大于x</p><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_left</span>()</span><br></pre></td></tr></table></figure><p>插入的效果跟查找是一样的，不过就是查找然后插入:list.insert(bisect.bisect_left())<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort</span>()</span><br></pre></td></tr></table></figure></p><p>上边四个操作可以用下图帮助理解:<br><img src="/img/python/bisect.png" title="bisect操作"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-两点作用：&quot;&gt;&lt;a href=&quot;#1-两点作用：&quot; class=&quot;headerlink&quot; title=&quot;1.两点作用：&quot;&gt;&lt;/a&gt;1.两点作用：&lt;/h2&gt;&lt;p&gt;1.插入时就维护好一个排好序的数组&lt;br&gt;2.数组非常大的时候速度较快&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python配置解析--ConfigParser</title>
    <link href="http://suntus.github.io/2017/11/02/python%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90-ConfigParser/"/>
    <id>http://suntus.github.io/2017/11/02/python配置解析-ConfigParser/</id>
    <published>2017-11-02T06:32:33.000Z</published>
    <updated>2020-04-24T11:59:38.528Z</updated>
    
    <content type="html"><![CDATA[<p>配置文件的格式<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">bind</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">log</span> = /var/log/haha.log</span><br><span class="line"><span class="attr">workers</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">connect</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9090</span></span><br><span class="line"><span class="attr">log</span> = /var/log/hehe.log</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用的话就相当简单了<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> = ConfigParser.ConfigParser()</span><br><span class="line"><span class="keyword">cp</span>.<span class="keyword">read</span>(<span class="string">"etc/app.conf"</span>)</span><br><span class="line">server.bind = <span class="keyword">cp</span>.<span class="built_in">get</span>(<span class="string">"server"</span>, <span class="string">"bind"</span>)</span><br><span class="line">server.workers = <span class="keyword">cp</span>.getint(<span class="string">"server"</span>,<span class="string">"workers"</span>)</span><br><span class="line"># 另外还有</span><br><span class="line"># <span class="keyword">cp</span>.getboolean()</span><br><span class="line"># <span class="keyword">cp</span>.getfloat()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置文件的格式&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[server]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;bind&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/haha.log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;workers&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[client]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;connect&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9090&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/hehe.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python连接mysql</title>
    <link href="http://suntus.github.io/2017/11/02/python%E8%BF%9E%E6%8E%A5mysql/"/>
    <id>http://suntus.github.io/2017/11/02/python连接mysql/</id>
    <published>2017-11-02T05:57:29.000Z</published>
    <updated>2020-04-24T11:59:38.527Z</updated>
    
    <content type="html"><![CDATA[<p>安装MySQLdb<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> mysql-python</span><br></pre></td></tr></table></figure></p><p>创建连接<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_conn(**dbconfig):</span><br><span class="line">    conn = MySQLdb.<span class="built_in">connect</span>(**dbconfig)</span><br><span class="line">    <span class="built_in">cursor</span> = conn.<span class="built_in">cursor</span>()</span><br><span class="line">    <span class="built_in">return</span> conn, <span class="built_in">cursor</span></span><br><span class="line"></span><br><span class="line">conn, <span class="built_in">cursor</span> = db_get_conn(host=<span class="string">"127.0.0.1"</span>, user=<span class="string">"root"</span>,passwd=“<span class="number">123</span><span class="string">", db=“db_haha"</span>,charset=<span class="string">"utf8"</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建查询<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.<span class="keyword">execute</span>(<span class="string">"select a,b from t_hehe"</span>)</span><br></pre></td></tr></table></figure></p><p>获取结果<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">a</span>, b <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">        print <span class="keyword">a</span>,b</span><br><span class="line"></span><br><span class="line">// 注意：如果只有<span class="number">1</span>个元素，这样才行</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">a</span>,) <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">    print <span class="keyword">a</span></span><br></pre></td></tr></table></figure></p><p>如果结果太大，不想全部拉回来，而是创建好查询，现在服务器端查好结果，再一条条拉回来，要这样创建连接<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_ss_conn(*<span class="number">*dbc</span>onfig):</span><br><span class="line">    ss_conn = MySQLdb.connect(*<span class="number">*dbc</span>onfig)</span><br><span class="line">    ss_cursor = conn.cursor(<span class="attribute">cursorclass</span>=MySQLdb.cursors.SSCursor)</span><br><span class="line">    return ss_conn, ss_cursor</span><br><span class="line"></span><br><span class="line">ss_conn, ss_cursor = db_get_conn(<span class="attribute">host</span>=<span class="string">"127.0.0.1"</span>, <span class="attribute">user</span>=<span class="string">"root"</span>,passwd=“123", <span class="attribute">db</span>=“db_haha",charset="utf8")</span><br></pre></td></tr></table></figure></p><p>然后这样获取结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss_cursor.execute(<span class="string">"select a,b from t_hehe"</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span> <span class="keyword">in</span> ss_cursor:</span><br><span class="line">    print <span class="selector-tag">a</span>, b</span><br></pre></td></tr></table></figure></p><p>最后修改的话，记得提交事务<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">conn</span><span class="selector-class">.commit</span>()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装MySQLdb&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; mysql-python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建连接&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def db_get_conn(**dbconfig):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn = MySQLdb.&lt;span class=&quot;built_in&quot;&gt;connect&lt;/span&gt;(**dbconfig)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = conn.&lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = db_get_conn(host=&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, user=&lt;span class=&quot;string&quot;&gt;&quot;root&quot;&lt;/span&gt;,passwd=“&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;, db=“db_haha&quot;&lt;/span&gt;,charset=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
</feed>
