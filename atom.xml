<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morning~Sun。</title>
  
  <subtitle>ha</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suntus.github.io/"/>
  <updated>2019-05-31T15:35:08.721Z</updated>
  <id>http://suntus.github.io/</id>
  
  <author>
    <name>suntus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECC算法</title>
    <link href="http://suntus.github.io/2019/05/31/ECC%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/05/31/ECC算法/</id>
    <published>2019-05-31T11:04:38.000Z</published>
    <updated>2019-05-31T15:35:08.721Z</updated>
    
    <content type="html"><![CDATA[<p>对TLS1.3中用到的ECC相关算法，比如ECDH, ECDSA, X25519等进行一下基础说明，起码知道group、curve之类的是什么意思。<br><a id="more"></a></p><h2 id="1-椭圆曲线-Elliptic-Curves"><a href="#1-椭圆曲线-Elliptic-Curves" class="headerlink" title="1. 椭圆曲线(Elliptic Curves)"></a>1. 椭圆曲线(Elliptic Curves)</h2><p>椭圆曲线的Weierstrass标准形式：</p><script type="math/tex; mode=display">y^2 = x^3 + ax + b</script><script type="math/tex; mode=display">4a^3 + 27b^2 != 0</script><p>定义0表示椭圆曲线上的无限远点，这样组成的椭圆曲线是这样的：</p><script type="math/tex; mode=display">\left\{ (x, y) \in \mathbb{R}^2\ |\ y^2 = x^3 + ax + b,\ 4 a^3 + 27 b^2 \ne 0 \right\}\ \cup\ \left\{ 0 \right\}</script><h2 id="2-群-Group"><a href="#2-群-Group" class="headerlink" title="2. 群(Group)"></a>2. 群(Group)</h2><p>$\mathbb{G}$是一个集合，在集合中定义一个对两个元素的操作，记为<code>&quot;加&quot;</code>,用<code>+</code>表示，集合中两个元素a和b,<code>&quot;加&quot;</code>操作表示为$a+b$，如果$a+b$这个操作满足一下4个特性，$\mathbb{G}$就是一个群(Group):</p><ul><li>闭合性closure: a, b是$\mathbb{G}$的元素，$a+b$也是；</li><li>结合性associativity: $(a+b)+c=a+(b+c)$</li><li>存在单位元identity element 0, 有$a+0=0+a=a$</li><li>每个元素都有一个相反数，对每个元素a都存在b使$a+b=0$, b就是a的相反数，可以表示为$-a$</li></ul><p>如果再加一条特性：</p><ul><li>交换律：$a+b=b+a$<br>这样的群就要阿贝尔群(Abelian Group)</li></ul><p>这个”加+”操作，也可以用”乘*”来表示，这个操作只是表示集合上两个元素的一个操作，此时</p><ul><li>$a \cdot b$ 也是 $\mathbb{G}$ 上的一个元素；</li><li>$(a \cdot b) \cdot c=a \cdot (b \cdot c)$</li><li>单位元1， $a \cdot 1=1 \cdot a=a$</li><li>$a \cdot b=1$， b可以表示为$a^{-1}$</li></ul><p>在讨论ECC的时候，一些旧的文献通常用<code>+</code>，新的通常用<code>*</code>，另外，在密码学中讨论加密强度的时候，通常按照指数(幂)、读书来讨论，比如长听到取离散对数问题。本文都用<code>+</code>来表示。</p><h2 id="3-椭圆曲线上的群"><a href="#3-椭圆曲线上的群" class="headerlink" title="3. 椭圆曲线上的群"></a>3. 椭圆曲线上的群</h2><p>可以定义一个在椭圆曲线上的群$\mathbb{G}$：</p><ul><li>一个椭圆曲线上的点是$\mathbb{G}$中的元素;</li><li>单位元定义为无穷远处的点0</li><li>一个点P的相反数是关于x轴对称的点</li><li><code>加</code>定义为： $P, Q, R$是斜率相同的点(一条直线跟椭圆曲线相交的3个点)，有$P+Q+R=0$</li></ul><p>这样就有$R=-(P+Q)$，如果要用计算机去算，需要转换成代数的方法计算R的x,y坐标<br>记</p><script type="math/tex; mode=display">P=(x_P, y_P), Q=(x_Q, y_Q), R=(x_R, y_R)</script><p>则:</p><script type="math/tex; mode=display">m = \frac{y_P - y_Q}{x_R - x_Q}</script><script type="math/tex; mode=display">x_R = m^2 - x_P - x_Q</script><script type="math/tex; mode=display">y_R = y_P + m(x_R - x_P)</script><p>这样，就能根据$P, Q$算出$R$了。</p><h2 id="4-标量乘法"><a href="#4-标量乘法" class="headerlink" title="4. 标量乘法"></a>4. 标量乘法</h2><script type="math/tex; mode=display">nP = \underbrace{P + P + \cdots + P}_{n\ \text{times}}</script><p>叫做<code>标量乘法</code>.<br>有个快速算法：<code>double and add</code>，<br>比如 $n = 151$， 用2进制表示为$10010111b$，然后</p><script type="math/tex; mode=display">\begin{array}{rcl}    151 & = & 1 \cdot 2^7 + 0 \cdot 2^6 + 0 \cdot 2^5 + 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 \\    & = & 2^7 + 2^4 + 2^2 + 2^1 + 2^0\end{array}</script><p>就可以很方便的用计算机去算了。</p><h2 id="5-对数"><a href="#5-对数" class="headerlink" title="5. 对数"></a>5. 对数</h2><p>对$Q=nP$,如果知道$n$和$P$，可以很容易算出$Q$(double and add)， 但如果知道$Q$和$P$，却很难算出$n$——数学上没有很快的算法。<br>如果用<code>*</code>来表示，那就是$Q=P^n$,知道$Q$和$P$，很难算出指数$n$，这就是取对数难题，也是密码学中的基石。</p><h2 id="6-有限域-Finite-Field"><a href="#6-有限域-Finite-Field" class="headerlink" title="6. 有限域(Finite Field)"></a>6. 有限域(Finite Field)</h2><p>有限域，就是域中元素是有限个数的域，整个实数域是无限的，如果对实数取$ \text{ mod }  p$，就可以得到元素个数为p的有限域了，<br>域中多一个操作乘，符合结合律：$x \cdot (y+z)=x \cdot y+x \cdot z$</p><p>先了解mod运算</p><script type="math/tex; mode=display">(18+9)  \text{ mod }  23=4</script><script type="math/tex; mode=display">-5  \text{ mod }  23 = 18</script><script type="math/tex; mode=display">9^{-1}  \text{ mod }  23 = 18</script><p>因为在域23上，$9^{-1} = 18$(因为 $9 \cdot 18  \text{ mod }  23 = 1, 9 \cdot 9{^-1} mod 23 = 1$, 域上1个元素有且只有1个倒数，所以$9^{-1} = 18$，9的倒数是18)</p><h2 id="7-mod-p-除法"><a href="#7-mod-p-除法" class="headerlink" title="7. mod p 除法"></a>7. mod p 除法</h2><p>要计算$\frac{x}{y}$，需要计算$x \cdot y^{^-1}$,也是就是我们要先找到y的倒数，然后再乘上x<br>取一个数的倒数用扩展欧几里得算法可以很简单算出来。</p><h2 id="8-有限域-GF-p-中的椭圆曲线"><a href="#8-有限域-GF-p-中的椭圆曲线" class="headerlink" title="8. 有限域$GF(p)$中的椭圆曲线"></a>8. 有限域$GF(p)$中的椭圆曲线</h2><p>先前的椭圆曲线是实数域上的，现在挑选其中在有限域$GF(p)$上的点，就组成了椭圆曲线上的有限域——或者有限域上的椭圆曲线。</p><h2 id="9-有限域上的椭圆曲线的加法"><a href="#9-有限域上的椭圆曲线的加法" class="headerlink" title="9. 有限域上的椭圆曲线的加法"></a>9. 有限域上的椭圆曲线的加法</h2><p>还是$P+Q+R=0$，但$P，Q, R$在有限域上怎么斜率相同呢？——在一条直线上即可。但有限域上的直线跟是实数域上有些不同，只要有限域中的点$(x,y)$符合$ax+by+c ( \text{ mod }  p) = 0 ( \text{ mod }  p)$，就说这些点在同一条直线上——这样的直线画出来可能有很多并行的条，都算同一条直线。</p><p>这样，有限域上的加法用计算机计算，公式是这样的</p><script type="math/tex; mode=display">x_R = (m^2-x_P-x_Q)  \text{ mod }  p</script><script type="math/tex; mode=display">y_R = [y_P + m(x_R-x_P)]  \text{ mod }  p = [y_Q + m(x_R-x_Q)]  \text{ mod }  p</script><p>这样就可以用计算机计算$P + Q = R$了</p><h2 id="10-一个椭圆曲线群的阶order"><a href="#10-一个椭圆曲线群的阶order" class="headerlink" title="10. 一个椭圆曲线群的阶order"></a>10. 一个椭圆曲线群的阶<code>order</code></h2><p>首先，一个群上的点的元素个数，叫做这个群的阶。<br>定义在一个有限域上的一个椭圆曲线的元素个数是多少呢？有个快速的算法可以计算: <code>Schoof’s algorithm</code>。可以方便计算椭圆曲线在有限域上的元素个数。</p><h2 id="11-标量乘法和曲线子群"><a href="#11-标量乘法和曲线子群" class="headerlink" title="11. 标量乘法和曲线子群"></a>11. 标量乘法和曲线子群</h2><p>标量乘法是这样的</p><script type="math/tex; mode=display">n P = \underbrace{P + P + \cdots + P}_{n\ \text{times}}</script><p>但在有限域上，我们可以想象出<br>$1P$<br>$2P$<br>$3P$<br>$…$<br>得出的结果最终会形成一个循环，而且循环中的所有结果都在有限域上，这样，我们根据$P$生成了一个曲线子群，$P$就叫做这个子群的生成因子后者基准点。曲线子群就是ECC和其他加密系统的基础。</p><p>现在我们梳理一下：</p><ul><li>一开始我们有实数群$\mathbb{G}$,</li><li>我们取椭圆曲线，得出椭圆曲线上的点，形成一个小一点的群</li><li>接着定义有限域，然后将椭圆曲线限制到有限域上，这样框出来的椭圆曲线上的点，形成一个更小一点的群</li><li>最后，我们取其中一个点作为基准点，取基准点的向量倍数，生成一个再小一点的子群，这个群，就是我们的ECC要用的群了。</li></ul><h2 id="12-子群的阶"><a href="#12-子群的阶" class="headerlink" title="12. 子群的阶"></a>12. 子群的阶</h2><p>我们想知道，由基准点$P$生成的子群的阶是多少。现在不能用<code>Schoof’s</code>算法，它是工作在整个椭圆曲线上，而不是其中的一个子群。<br>要算子群的阶，需要知道：</p><ol><li>子群的阶就是子群中的元素个数，等价于 $nP=0$，其$n$是正整数，且$n$是其中最小的1个，这个$n$就是子群的阶。</li><li>根据拉格朗日定理，子群$P$的阶，是父群阶的一个因子，比如一个椭圆曲线有$N$个元素，它的一个子群有$n$个元素，$n$能整除$N$</li></ol><p>接着我们开始算子群P的阶：</p><ol><li>用<code>Schoof&#39;s</code>算法计算椭圆曲线的阶$N$</li><li>找出$N$的所有因子</li><li>对$N$的每一个因子$n$，计算$nP$</li><li>找出使$nP=0$的最小的$n$，这个$n$就是子群的阶.</li></ol><p>比如对$GP(37)$有限域上的椭圆曲线 $y^2 = x^3 - x + 3$,  它的阶$N=42$，子群可能有的阶$n = 1, 2, 3, 6, 7, 14, 21, 42$,  如果我们取基准点$P = (2, 3)$，那么</p><script type="math/tex; mode=display">P != 0, 2P !=0, 3P != 0, 6P!= 0, 7P=0</script><p>那么就说，$P$的阶是$n = 7$</p><h2 id="13-找一个基准点"><a href="#13-找一个基准点" class="headerlink" title="13. 找一个基准点"></a>13. 找一个基准点</h2><p>对ECC算法来说，我们希望子群拥有更高的阶。<br>我们先计算椭圆曲线的阶$N$，找一个比较大的因子$n$，然后根据$n$找出一个合适的基准点。<br>也就是说，我们先找子群的阶，再根据子群的阶找其中的基准点。而不是先找基准点，再算子群的阶。</p><p>再加一个信息：根据拉格朗日定理，$h = N/n$肯定是个整数（因为$n$是$N$的一个因子）。这个$h$叫做子群的协因子(cofactor).</p><p>对一个椭圆曲线上的任意一点来说， $NP = 0$,因为$N$总是任何一个$n$的倍数；<br>也就是 $n(hP) = 0$<br>取$n$是素数，点$G = hP$生成一个阶为$n$的子群。<br>这样，我们就根据选择的阶$n$，算出了一个基准点。</p><h2 id="14-离散对数"><a href="#14-离散对数" class="headerlink" title="14. 离散对数"></a>14. 离散对数</h2><p>在连续的椭圆曲线上，我们如果知道$P$和$Q$很难算出$k$，使得$Q = kP$，<br>那么，<br>在有限域上的椭圆曲线，这个也是很多难的，叫做椭圆曲线的离散对数问题。</p><p>ECC有意思的一点是，这个离散对数问题“更难”，也就是要达到相同的加密强度，$k$的位数可以更少。这也是有RSA，还有开发ECC的原因。</p><h2 id="15-定义一个ECC的域需要的参数"><a href="#15-定义一个ECC的域需要的参数" class="headerlink" title="15. 定义一个ECC的域需要的参数"></a>15. 定义一个ECC的域需要的参数</h2><ol><li>有限域的大小是个素数$p$</li><li>椭圆曲线中的系数$a,b$</li><li>子群基准点$G$</li><li>子群的阶$n$</li><li>子群的协因子$h$</li></ol><p>所以，定义一个我们ECC需要的问题域需要6个因子$（p, a, b , G, n, h）$</p><h2 id="16-随机曲线"><a href="#16-随机曲线" class="headerlink" title="16. 随机曲线"></a>16. 随机曲线</h2><p>并不是所有的椭圆曲线上的离散对数都那么难，比如$p = hn$的椭圆曲线就可以用<code>Smart</code>方法攻击。而且我们也不知道还有没有哪些椭圆曲线的攻击方法我们没发现。<br>一个更具密码学强度的方法是，我们选一个随机因子$S$，对$S$取hash，然后衍生出$a、b$或者$G$，或者两者都用$S$生成，那么攻击者就不知道我们用的是什么参数，会更安全些。<br>但是，NIST规定了一些$S$，我们也不知道$S$是不是精心挑选的。。。。。。</p><h2 id="17-ECC算法"><a href="#17-ECC算法" class="headerlink" title="17. ECC算法"></a>17. ECC算法</h2><ol><li>私钥就是从$[1,n-1]$($n$是子群的阶)中随机挑选的一个整数$d$</li><li>公钥就是点$H = dG$($G$是子群的基准点)</li></ol><p>知道$d$和$G$，算出$H$很简单，但反过来就很难。<br>这是个非对称加密算法，基于此，衍生出两个算法ECDH（用于密钥交换），ECDSA（用于签名）</p><h2 id="18-ECDH"><a href="#18-ECDH" class="headerlink" title="18. ECDH"></a>18. ECDH</h2><ol><li>Alice和Bob各自生成自己的公私钥，Alice的私钥是$d_A$, 公钥是$H_A = d_A \cdot G$，Bob的是$d_B$和$H_B=d_B \cdot G$。注意Alice和Bob用的是同一个有限域上的同一个椭圆曲线的同一个基准点$G$</li><li>Alice和bob在一个未加密的通道上交换公钥$H_A$和$H_B$,</li><li>Alice计算$S = d_A \cdot H_B$, Bob计算$S = d_B \cdot H_A$, 两个计算出来的$S$是一样的</li></ol><p>这样Alice和Bob就得出了同一个$S$，就可用于对称加密了。</p><p>一个例子</p><ul><li>$p$ = 0xffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f</li><li>$a$ = 0</li><li>$b$ = 7</li><li>$x_G$ = 0x79be667e f9dcbbac 55a06295 ce870b07 029bfcdb 2dce28d9 59f2815b 16f81798</li><li>$y_G$ = 0x483ada77 26a3c465 5da4fbfc 0e1108a8 fd17b448 a6855419 9c47d08f fb10d4b8</li><li>$n$ = 0xffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141</li><li>$h$ = 1<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Curve: secp256k1</span><br><span class="line">Alice's private key: 0xe<span class="number">32868331</span>fa8ef<span class="number">0138</span>de0de<span class="number">85478346</span>aec5e<span class="number">3912</span>b<span class="number">6029</span>ae<span class="number">7169</span>1c<span class="number">384237</span>a3eeb</span><br><span class="line">Alice's public key: (<span class="number">0</span>x86b1aa5120f079594348c67647679e7ac4c365b2c01330db782b0ba611c1d677, <span class="number">0</span>x5f4376a23eed633657a90f385ba21068ed7e29859a7fab09e953cc5b3e89beba)</span><br><span class="line">Bob's private key: 0xcef<span class="number">147652</span>aa<span class="number">9016</span>2e1fff9cf07f<span class="number">2605</span>ea<span class="number">0552</span>9ca215a<span class="number">0435</span>0a98ecc24aa<span class="number">3434</span>2</span><br><span class="line">Bob's public key: (<span class="number">0</span>x4034127647bb7fdab7f1526c7d10be8b28174e2bba35b06ffd8a26fc2c20134a, <span class="number">0</span>x9e773199edc1ea792b150270ea3317689286c9fe239dd5b9c5cfd9e81b4b632)</span><br><span class="line">Shared secret: (<span class="number">0</span>x3e2ffbc3aa8a2836c1689e55cd169ba638b58a3a18803fcf7de153525b28c3cd, <span class="number">0</span>x43ca148c92af58ebdb525542488a4fe6397809200fe8c61b41a105449507083)</span><br></pre></td></tr></table></figure></li></ul><p>PS：每次都生成新的公私钥，就叫ECDHE，E表示Ephermeral，瞬时的，短暂的</p><h2 id="19-ECDSA"><a href="#19-ECDSA" class="headerlink" title="19. ECDSA"></a>19. ECDSA</h2><p>Alice使用私钥$d_A$签名消息，Bob使用Alice的公钥$H_A$验签。<br>ECDSA需要对消息的摘要进行签名，而不是对任意长度的消息签名。消息摘要需要截断到跟子群的阶$n$一样长度的位数，截断的摘要用作为一个整数$z$</p><p>签名:</p><ol><li>从$[1,n-1]$($n$是子群的阶)中随机选择一个整数$k$</li><li>计算$P=kG$（$G$是子群的基准点）</li><li>计算$r = x_P  \text{ mod }  n$($x_P$是$P$的x坐标)</li><li>如果$r=0$，重新选择$k$</li><li>计算$s = k^{-1}(z + r \cdot d_A)  \text{ mod }  n$（$d_A$是Alice的私钥，$k^{-1}$是$k$的乘法倒数 mod n）</li><li>如果$s=0$，重新选择$k$</li></ol><p>$(r,s)$组成的对儿就是签名</p><p>验签：</p><ol><li>计算$u_1 = s^{-1} \cdot z  \text{ mod }  n$</li><li>计算$u_2 = s^{-1} \cdot r  \text{ mod }  n$</li><li>计算点$P = u_1G+u_2H_A$<br>如果$r = x_P \text{ mod } n$， 就说明签名正确</li></ol><p>例子<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Curve</span>: secp256k1</span><br><span class="line">Private <span class="attribute">key</span>: <span class="number">0</span>x9f4c9eb899bd86e0e83ecca659602a15b2edb648e2ae4ee4a256b17bb29a1a1e</span><br><span class="line">Public <span class="attribute">key</span>: (<span class="number">0</span>xabd9791437093d377ca25ea974ddc099eafa3d97c7250d2ea32af6a1556f92a, <span class="number">0</span>x3fe60f6150b6d87ae8d64b78199b13f26977407c801f233288c97ddc4acca326)</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hello!'</span></span><br><span class="line"><span class="attribute">Signature</span>: (<span class="number">0</span>xddcb8b5abfe46902f2ac54ab9cd5cf205e359c03fdf66ead1130826f79d45478, <span class="number">0</span>x551a5b2cd8465db43254df998ba577cb28e1ee73c5530430395e4fba96610151)</span><br><span class="line"><span class="attribute">Verification</span>: signature matches</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hi there!'</span></span><br><span class="line"><span class="attribute">Verification</span>: invalid signature</span><br><span class="line"></span><br><span class="line"><span class="attribute">Message</span>: b<span class="string">'Hello!'</span></span><br><span class="line">Public <span class="attribute">key</span>: (<span class="number">0</span>xc40572bb38dec72b82b3efb1efc8552588b8774149a32e546fb703021cf3b78a, <span class="number">0</span>x8c6e5c5a9c1ea4cad778072fe955ed1c6a2a92f516f02cab57e0ba7d0765f8bb)</span><br><span class="line"><span class="attribute">Verification</span>: invalid signature</span><br></pre></td></tr></table></figure></p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ </a>: 这个系列非常好.</li><li><a href="https://tools.ietf.org/html/rfc8422" target="_blank" rel="noopener">RFC8442-Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</a>: 定义了TLS1.2及以前的协议使用的ECC曲线都有哪些，比如X25591,secp256r1等.</li><li><a href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener">RFC7748-Elliptic Curves for Security</a>: 具体定义了X25519,X448曲线算法.</li><li><a href="https://tools.ietf.org/html/rfc6090" target="_blank" rel="noopener">RFC6090-Fundamental Elliptic Curve Cryptography Algorithms</a>: ECC基本定义.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对TLS1.3中用到的ECC相关算法，比如ECDH, ECDSA, X25519等进行一下基础说明，起码知道group、curve之类的是什么意思。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>HKDF算法</title>
    <link href="http://suntus.github.io/2019/05/09/HKDF%E7%AE%97%E6%B3%95/"/>
    <id>http://suntus.github.io/2019/05/09/HKDF算法/</id>
    <published>2019-05-09T11:14:44.000Z</published>
    <updated>2019-05-09T15:05:59.166Z</updated>
    
    <content type="html"><![CDATA[<p>　　是tls1.3中关于密钥生成的重要的基础算法，跟密钥推导密切相关。<br><a id="more"></a><br>　　HKDF叫<code>HMAC-based KDF(key derivation function)，基于HMAC的密钥推导函数</code>，所以我们先认识HMAC算法。</p><h2 id="1-HMAC"><a href="#1-HMAC" class="headerlink" title="1. HMAC"></a>1. HMAC</h2><p>　　基于一个共同密钥，在两个对端之间提供消息完整性确认的机制叫<code>&quot;message authentication codes(MAC)，消息认证码&quot;</code>。其实就是将消息进行hash，得到的hash值附加到消息之后，随消息一起发送，对端接收后，同样进行hash，来验证消息是否被篡改——关键点在不同数据得到的hash值一定不同——其中得到的hash值就是MAC（在别的语境里边也叫消息摘要）。另外，为了避免使用同样的hash函数对相同数据进行操作总是得出同样的摘要，额外加入一个密钥，这样使用不同密钥就可以得出不同的MAC，当然，这个密钥是两个对端都知道的。这样，我们就得到了基于加密hash的消息完整性认证的算法——Hash-based MAC。</p><h3 id="1-1-HMAC定义如下："><a href="#1-1-HMAC定义如下：" class="headerlink" title="1.1 HMAC定义如下："></a>1.1 HMAC定义如下：</h3><p>输入：</p><pre><code>1. 使用的加密hash函数H，输出长度为hashLen2. 使用的密钥K,长度hashLen &lt;= Klen &lt;= 64，如果K的长度超过64，则先用hash函数进行一次hash，用得到的值作为K3. 需要认证的数据text</code></pre><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息完整性认证码HMAC</span><br></pre></td></tr></table></figure></p><p>过程：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义 ipad = <span class="number">64</span>个<span class="number">0</span>x36, opad = <span class="number">64</span>个<span class="number">0</span>x5c</span><br><span class="line">HMAC = HMAC-Hash(H, K, <span class="built_in">text</span>) = H(K <span class="built_in">XOR</span> opad, H(K <span class="built_in">XOR</span> ipad, <span class="built_in">text</span>))</span><br></pre></td></tr></table></figure></p><p>目的：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为<span class="built_in">text</span>生成一个HMAC消息完整性认证码，输出长度就是hash函数的输出长度</span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf1.png" alt="HMAC"></p><h2 id="2-HKDF"><a href="#2-HKDF" class="headerlink" title="2. HKDF"></a>2. HKDF</h2><p>　　HKDF的主要目的使用原始的密钥材料,派生出一个或更多个能达到密码学强度的密钥(主要是保证随机性)——就是将较短的密钥材料扩展成较长的密钥材料，过程中需要保证随机性。<br>　　HKDF包含两个基本模块,或者说两个基本使用步骤:<code>1. 提取 Extract, 2. 扩展 Expand</code>。</p><ol><li><strong><em>提取</em></strong>：使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥</li><li><strong><em>扩展</em></strong>：使用第1步骤提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。</li></ol><h3 id="2-1-HKDF-Extract"><a href="#2-1-HKDF-Extract" class="headerlink" title="2.1 HKDF-Extract"></a>2.1 HKDF-Extract</h3><p>输入：</p><pre><code>1. HMAC使用的hash函数H，H输出长度是hashLen2. 原始密钥材料IKM(input keying material)3. 另外的随机源salt, 如果没有，默认是hashLen长度的0串</code></pre><p>输出:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashLen长度的伪随机密钥prk(pseudorandom <span class="built_in">key</span>)</span><br></pre></td></tr></table></figure></p><p>过程:<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prk = HKDF-<span class="keyword">Extract</span>(H, salt, IKM) = HMAC-<span class="keyword">Hash</span>(H, salt, IKM)</span><br><span class="line">其实就相当于用salt作为HMAC-<span class="keyword">Hash</span>的<span class="keyword">K</span>，对IKM进行消息完整性认证</span><br></pre></td></tr></table></figure></p><p>目的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用salt增加IKM的随机性</span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf2.png" alt="HKDF-Extract"></p><h3 id="2-2-HKDF-Expand"><a href="#2-2-HKDF-Expand" class="headerlink" title="2.2 HKDF-Expand"></a>2.2 HKDF-Expand</h3><p>输入：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>HMAC使用的hash函数H，H输出长度是hashLen</span><br><span class="line"><span class="bullet">2. </span>第一步生成的PRK</span><br><span class="line"><span class="bullet">3. </span>另外的随机元info，可以为空</span><br><span class="line"><span class="bullet">4. </span>期望生成的密钥长度L</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L长度的OKM(<span class="keyword">output</span> keying material)</span><br></pre></td></tr></table></figure></p><p>过程:<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">N</span> = ceil(L/hashLen)</span><br><span class="line">    <span class="built_in">T</span> = <span class="built_in">T</span>(<span class="number">1</span>) || <span class="built_in">T</span>(<span class="number">2</span>) || <span class="built_in">T</span>(<span class="number">3</span>) || ... || <span class="built_in">T</span>(<span class="built_in">N</span>)</span><br><span class="line">    OKM = <span class="built_in">T</span>的前L字节</span><br><span class="line"></span><br><span class="line">    <span class="built_in">T</span>(<span class="number">0</span>) = 空</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">1</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">0</span>) || <span class="built_in">info</span> || <span class="number">0</span>x01)</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">2</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">1</span>) || <span class="built_in">info</span> || <span class="number">0</span>x02)</span><br><span class="line">    <span class="built_in">T</span>(<span class="number">3</span>) = HMAC-Hash(PRK, <span class="built_in">T</span>(<span class="number">2</span>) || <span class="built_in">info</span> || <span class="number">0</span>x03)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>目的:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将PRK扩展到指定长度L，同时保持密码学强度<span class="comment">(随机性)</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/hkdf/hkdf3.png" alt="HKDF-Expand"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol><li>HKDF是密钥推导算法，根据一个原始密钥材料，推导出指定长度的密钥；</li><li>HKDF基于HMAC；</li><li>HMAC是基于加密hash函数的消息完整性认证算法，主要目的是认证消息完整性。在这里被用于增加原始密钥材料的随机性；</li><li>HKDF包含两步：(1) 提取Extract, (2) 扩展Expand；</li><li>HKDF-Extract就是HMAC，取IKM的认证码，也就相当于用额外的随机源salt(Key)增加了IKM(text)的随机性；</li><li>HKDf-Expand就是将短密钥变长，同时保证随机性。</li></ol><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc5869" target="_blank" rel="noopener">RFC5869: HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a></li><li><a href="https://www.ietf.org/rfc/rfc2104.txt" target="_blank" rel="noopener">RFC2104: HMAC: Keyed-Hashing for Message Authentication</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　是tls1.3中关于密钥生成的重要的基础算法，跟密钥推导密切相关。&lt;br&gt;
    
    </summary>
    
    
      <category term="tls" scheme="http://suntus.github.io/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>顺时针规则--C语言声明</title>
    <link href="http://suntus.github.io/2017/12/19/%E9%A1%BA%E6%97%B6%E9%92%88%E8%A7%84%E5%88%99--C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/"/>
    <id>http://suntus.github.io/2017/12/19/顺时针规则--C语言声明/</id>
    <published>2017-12-19T05:44:49.000Z</published>
    <updated>2017-12-20T01:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>The “Clockwise/Spiral Rule”<br>By David Anderson</p><p>每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!<br><a id="more"></a><br>该规则只有简单的3步：</p><ol><li><p>从未知元素开始，沿顺时针/螺旋方向移动；当遇到如下元素的时候，用相应的自然语言陈述出来：</p><ul><li>[X] 或者 [] =&gt; 大小为…的数组X 或 未知大小数组的…(Array X size of… or Array undefined size of…)</li><li>(type1, type2) =&gt; 传入type1和type2参数、返回…的函数(function passing type1 and type2 returning…)</li><li>* =&gt; 指向…的指针(pointer(s) to…)</li></ul></li><li><p>一直沿着顺时针往下进行，直到覆盖了所有的元素。</p></li><li>括号内的永远优先!</li></ol><p>其实对英文来说就是不断在后边加定语，但对汉语来说，就需要不断在前边加定语。</p><h2 id="1-简单声明"><a href="#1-简单声明" class="headerlink" title="1.简单声明"></a>1.简单声明</h2><pre><code>                 +-------+                 | +-+   |                 | ^ |   |            char *str[10];             ^   ^   |   |             |   +---+   |             +-----------+</code></pre><p>首先需要问的是：<code>str</code>是什么？</p><blockquote><p>str 是个…(str is an…)</p><ul><li>我们从<code>str</code>开始顺时针移动，碰到的第一个元素是<code>[</code>，这意味着我们碰到了个数组，于是就有…<br>str是个大小是10、…的数组(str is an array 10 of…)</li><li>继续顺时针，下一个遇到的是<code>*</code>,这意味着我们碰到了个指针，就有…<br>str是个大小是10、指向…指针的数组(str is an array 10 of pointers to…)</li><li>继续，下一个是该行结尾<code>;</code>；继续，接下来是<code>char</code>，因此…<br>str是个大小是10、指向字符的指针的数组(str is an array 10 of pointers to char)</li></ul></blockquote><h2 id="2-指向函数的指针的声明"><a href="#2-指向函数的指针的声明" class="headerlink" title="2.指向函数的指针的声明"></a>2.指向函数的指针的声明</h2><pre><code>                 +--------------------+                 | +---+              |                 | |+-+|              |                 | |^ ||              |            char *(*fp)( int, float *);             ^   ^ ^  ||              |             |   | +--+|              |             |   +-----+              |             +------------------------+</code></pre><p>还是一样，首先要问：<code>fp</code>是什么？</p><blockquote><p>fp 是个…(fp is a…)</p><ul><li>顺时针移动，首先看到了<code>)</code>，因此<code>fp</code>就在括号中了，我们在括号中顺时针移动，下一个看到的是<code>*</code>，因此…<br>fp 是个指向…的指针(fp is a pointer to…)</li><li>跳出括号，继续顺时针转动，看到了<code>(</code>，这表明遇到了一个函数，就有…<br>fp 是个指向传入参数是int和指向float的指针、返回值是…的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning…)</li><li>继续顺时针，看到了<code>*</code>，说明…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向…的指针的函数的指针(fp is a pointer to a funciton passing an int and a pointer to float returning a pointer to…)</li><li>继续，遇到<code>;</code>；再继续，遇到了<code>char</code>，因此…<br>fp 是个指向传入参数是int和指向float的指针、返回值是指向char的指针的函数的指针(fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char)</li></ul></blockquote><h2 id="3-终极形态"><a href="#3-终极形态" class="headerlink" title="3.终极形态"></a>3.终极形态</h2><pre><code>                  +-----------------------------+                  |                  +---+      |                  |  +---+           |+-+|      |                  |  ^   |           |^ ||      |            void (*signal(int, void (*fp)(int)))(int);             ^    ^      |      ^    ^  ||      |             |    +------+      |    +--+|      |             |                  +--------+      |             +----------------------------------+</code></pre><p>依然是:<code>signal</code>是什么?<br>注意<code>signal</code>在括号中，需要先解决它</p><ul><li>顺时针移动，首先遇到<code>(</code>，因此…<blockquote><p>signal是个传入参数为int和…,返回…的函数(signal is a function passing an int and a…)</p></blockquote></li><li>接着，我们可以对<code>fp</code>用相同的规则，<code>fp</code>是什么？<code>fp</code>在括号中，首先遇到的是<code>*</code>，于是…<blockquote><p>fp是个指向…的指针(fp is a pointer to…)</p></blockquote></li><li>继续会遇到<code>(</code>，就有…<blockquote><p>fp是个指向传入参数是int、返回…的函数的指针(fp is a pointer to a function passing int returning…)</p></blockquote></li><li>接着，看到了<code>void</code>…<blockquote><p>fp 是个指向传入参数是int、返回值为空(void)的函数的指针(fp is a pointer to a function passing int returning nothing (void))</p></blockquote></li><li>现在结束了对<code>fp</code>的解析，接着看<code>signal</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为…的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning…)</p></blockquote></li><li>现在还在括号内，接着的元素是<code>*</code>…<blockquote><p>signal是个传入参数为int和指向传入参数为int、返回值为空的函数的指针，返回值为指向…的指针的函数(signal is a function passing an int and a pointer to a funciton passing an int returning nothing(void) returning a pointer to…)</p></blockquote></li><li>再继续，碰到了<code>(</code>…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为…的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning…)</p></blockquote></li><li>终于到最后了，我们只剩下<code>void</code>这一个元素了，最终<code>signale</code>的定义为…<blockquote><p>signal是个传入参数为int何指向传入参数为int、返回值为空的函数的指针，返回值为指向一个传入参数为int、返回值为空的函数的指针的指针的函数(signal is a function passing an int and a pointer to a function passing an int returning nothing(void) returning a pointer to a function passing an int and returning nothing(void))</p></blockquote></li></ul><h2 id="const和volatile的例子"><a href="#const和volatile的例子" class="headerlink" title="const和volatile的例子"></a><code>const</code>和<code>volatile</code>的例子</h2><p>规则一样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *chptr:</span><br></pre></td></tr></table></figure></p><p><code>chptr</code>是个指向一个char常量(constant)的指针(chptr is a pointer to a char constant)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向char的常量指针(chptr is a constant pointer to char)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * <span class="keyword">const</span> chptr;</span><br></pre></td></tr></table></figure><p><code>chptr</code>是个指向一个char原子(volatile)的常量指针(chptr is a constant pointer to a char volatile)</p><hr><p>C的复杂声明其实就不断加定语，但是这个定语在修饰的是哪个主语，需要按照顺时针/螺旋规则来解释。熟悉了就好。</p><hr><p>原文: <a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The ``Clockwise/Spiral Rule’’</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The “Clockwise/Spiral Rule”&lt;br&gt;By David Anderson&lt;/p&gt;
&lt;p&gt;每个C程序员在脑袋里解析任何C声明的时候都会用到一种技术——顺时针/螺旋规则!&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="tr" scheme="http://suntus.github.io/tags/tr/"/>
    
  </entry>
  
  <entry>
    <title>软件的12个要素</title>
    <link href="http://suntus.github.io/2017/12/08/%E8%BD%AF%E4%BB%B6%E7%9A%8412%E4%B8%AA%E8%A6%81%E7%B4%A0/"/>
    <id>http://suntus.github.io/2017/12/08/软件的12个要素/</id>
    <published>2017-12-08T09:37:57.000Z</published>
    <updated>2017-12-14T07:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>由Heroku创始人Adam Wiggins在2012年发布。</li><li>是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。</li><li>使用于任意语言和后端服务开发的应用程序。</li><li>最佳阅读人员：服务器开发和运维人员。</li><li>中心思想是隔离。</li></ul><a id="more"></a><h2 id="1-基准代码"><a href="#1-基准代码" class="headerlink" title="1.基准代码"></a>1.基准代码</h2><p>1个模块只有1份基准代码，多个模块组成的是一个分布式系统。基准代码应该用版本管理工具加以控制，每个基准代码应该独占1个库，同属1个系统的多个基准代码库可以加入组。</p><h2 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2.依赖"></a>2.依赖</h2><ul><li>显示声明依赖。</li><li>通过依赖隔离工具来确保程序不会调用系统种存在但清单中未声明的依赖项。这种做法应该统一应用到开发和生产环境。</li></ul><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><ul><li>与代码分离。</li><li>推荐保存到环境变量。</li></ul><h2 id="4-后端服务"><a href="#4-后端服务" class="headerlink" title="4.后端服务"></a>4.后端服务</h2><ul><li>把后端服务当做附加资源。如数据库，MQ,SMTP，缓存等。</li><li>应该保证应用在不改动任何代码的情况下，将本地mysql换成第三方服务(如Amazon RDS)</li></ul><h2 id="5-构建，发布，运行"><a href="#5-构建，发布，运行" class="headerlink" title="5.构建，发布，运行"></a>5.构建，发布，运行</h2><p>严格分离构建和运行<br>基准代码转换成一份部署需要三个阶段：<br>1）构建阶段：将代码转化成可执行包的过程。构建时会使用指定版本的代码，获取和打包依赖项，编译成二进制文件和资源文件<br>2）发布阶段：将构建结果和当前部署所需配置相结合，并能够立即在运行环境中投入使用<br>3）运行阶段：只针对选定的发布版本，在执行环境中启动一系列运行程序进程</p><h2 id="6-进程"><a href="#6-进程" class="headerlink" title="6.进程"></a>6.进程</h2><ul><li>系统可以有1个或多个进程，进程必须无状态且无共享，任何需要持久化的数据都存储在后端服务中（比如数据库）。</li><li>内存和磁盘可以作为进程在进行某种事务型操作时的缓存（比如下载一个很大的文件）。不考虑这些缓存的内容是不是可以保留给之后的请求使用。</li><li>如果需要在内存中保存数据，优先考虑使用redis等内存数据库。</li></ul><h2 id="7-端口绑定"><a href="#7-端口绑定" class="headerlink" title="7.端口绑定"></a>7.端口绑定</h2><ul><li>使用端口提供服务。</li></ul><h2 id="8-并发"><a href="#8-并发" class="headerlink" title="8.并发"></a>8.并发</h2><ul><li>应该更多考虑水平扩展的可能。</li><li>不需要自己设置守护进程，而应交给其他进程托管系统。</li></ul><h2 id="9-易处理"><a href="#9-易处理" class="headerlink" title="9.易处理"></a>9.易处理</h2><ul><li>可以瞬间开启或停止，有利于快速、弹性的伸缩应用</li><li>进程接收到终止信号会优雅的终止。对网络进程，优雅就是停止监听服务的端口，拒绝信的请求，并执行当前已接收到的请求，然后退出。对worker进程，优雅终止就是当前任务退出队列。任务都应该可重复，使重复操作幂等实现。</li><li>应该可以处理 意外的、不优雅的终止。</li></ul><h2 id="10-开发环境与线上环境等价"><a href="#10-开发环境与线上环境等价" class="headerlink" title="10.开发环境与线上环境等价"></a>10.开发环境与线上环境等价</h2><p>尽可能保持开发、预发布、线上环境相同<br>开发环境和线上环境的差异有：</p><ol><li>时间差异：开发的代码可能几天，几周才会上线</li><li>人员差异：开发人员编写代码，运维人员部署代码</li><li>工具差异： 开发人员或许使用nginx，sqlite， osx，线上环境使用apache，mysql，linux</li></ol><h2 id="11-日志"><a href="#11-日志" class="headerlink" title="11.日志"></a>11.日志</h2><p>把日志当做事件流。<br>日志使应用程序运行的动作变得透明。服务器环境中，日志通常被写在文件中，但这只是一种输出格式。<br>日志应该是事件流的汇总，将所有运行中进程和后端服务的数据流按照时间顺序收集起来。<br>应用本身不应考虑存储自己的数据流，不应该试图去写或管理日志文件，都应该直接输出的标准输出（stdout）。最后汇总到统一的日志处理系统中。</p><h2 id="12-管理进程"><a href="#12-管理进程" class="headerlink" title="12.管理进程"></a>12.管理进程</h2><p>后台管理任务当做一次性进程运行。</p><hr><p>参考：<br><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">The Twelve-Factor App</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;由Heroku创始人Adam Wiggins在2012年发布。&lt;/li&gt;
&lt;li&gt;是一个开发服务器应用的方法论。开发运行一个服务器程序，应该考虑这些方面。&lt;/li&gt;
&lt;li&gt;使用于任意语言和后端服务开发的应用程序。&lt;/li&gt;
&lt;li&gt;最佳阅读人员：服务器开发和运维人员。&lt;/li&gt;
&lt;li&gt;中心思想是隔离。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ongoing" scheme="http://suntus.github.io/tags/ongoing/"/>
    
  </entry>
  
  <entry>
    <title>用到的docker</title>
    <link href="http://suntus.github.io/2017/12/08/%E7%94%A8%E5%88%B0%E7%9A%84docker/"/>
    <id>http://suntus.github.io/2017/12/08/用到的docker/</id>
    <published>2017-12-08T00:34:42.000Z</published>
    <updated>2017-12-09T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>都是在ubuntu系统中<br><a id="more"></a></p><h2 id="1-修改container时区"><a href="#1-修改container时区" class="headerlink" title="1.修改container时区"></a>1.修改container时区</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加shell命令</span><br><span class="line">echo <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone </span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span>同步主机时区</span><br><span class="line">启动时挂载`/etc/localtime`文件</span><br></pre></td></tr></table></figure><p>docker run -it -v /etc/localtime:/etc/localtime <img><br>```</p><hr><p>参考</p><ol><li><a href="https://brickyang.github.io/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/" target="_blank" rel="noopener">时区</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是在ubuntu系统中&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>docker search时列出tag</title>
    <link href="http://suntus.github.io/2017/12/07/docker%20search%E6%97%B6%E5%88%97%E5%87%BAtag/"/>
    <id>http://suntus.github.io/2017/12/07/docker search时列出tag/</id>
    <published>2017-12-07T02:24:23.000Z</published>
    <updated>2017-12-12T02:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用这个脚本docker-show-repo-tag.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple script that will display docker repository tags.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#   $ docker-show-repo-tags.sh ubuntu centos</span></span><br><span class="line"><span class="keyword">for</span> Repo <span class="keyword">in</span> $* ; <span class="keyword">do</span></span><br><span class="line">  curl -s -S <span class="string">"https://registry.hub.docker.com/v2/repositories/library/<span class="variable">$Repo</span>/tags/"</span> | \</span><br><span class="line">    sed -e <span class="string">'s/,/,\n/g'</span> -e <span class="string">'s/\[/\[\n/g'</span> | \</span><br><span class="line">    grep <span class="string">'"name"'</span> | \</span><br><span class="line">    awk -F\<span class="string">" '&#123;print <span class="variable">$4</span>;&#125;' | \</span></span><br><span class="line"><span class="string">    sort -fu | \</span></span><br><span class="line"><span class="string">    sed -e "</span>s/^/<span class="variable">$&#123;Repo&#125;</span>:/<span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这样用:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./docker-show-repo-tags.sh ubuntu centos</span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">14.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">16.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span><span class="number">17.04</span></span><br><span class="line"><span class="symbol">ubuntu:</span>latest</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty</span><br><span class="line"><span class="symbol">ubuntu:</span>trusty<span class="number">-20171117</span></span><br><span class="line"><span class="symbol">ubuntu:</span>xenial</span><br><span class="line"><span class="symbol">ubuntu:</span>xenial<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">ubuntu:</span>zesty</span><br><span class="line"><span class="symbol">ubuntu:</span>zesty<span class="number">-20171114</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.6</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.7</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">6.8</span></span><br><span class="line"><span class="symbol">centos:</span><span class="number">7</span></span><br><span class="line"><span class="symbol">centos:</span>centos6</span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.6</span></span><br><span class="line"><span class="symbol">centos:</span>centos6<span class="number">.7</span></span><br><span class="line"><span class="symbol">centos:</span>centos7</span><br><span class="line"><span class="symbol">centos:</span>latest</span><br></pre></td></tr></table></figure></p><hr><p>参考：<a href="https://stackoverflow.com/a/34054903/2955061" target="_blank" rel="noopener">https://stackoverflow.com/a/34054903/2955061</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用这个脚本docker-show-repo-tag.sh&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Simple script that will display docker repository tags.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Usage:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#   $ docker-show-repo-tags.sh ubuntu centos&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; Repo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; $* ; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  curl -s -S &lt;span class=&quot;string&quot;&gt;&quot;https://registry.hub.docker.com/v2/repositories/library/&lt;span class=&quot;variable&quot;&gt;$Repo&lt;/span&gt;/tags/&quot;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sed -e &lt;span class=&quot;string&quot;&gt;&#39;s/,/,\n/g&#39;&lt;/span&gt; -e &lt;span class=&quot;string&quot;&gt;&#39;s/\[/\[\n/g&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grep &lt;span class=&quot;string&quot;&gt;&#39;&quot;name&quot;&#39;&lt;/span&gt; | \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    awk -F\&lt;span class=&quot;string&quot;&gt;&quot; &#39;&amp;#123;print &lt;span class=&quot;variable&quot;&gt;$4&lt;/span&gt;;&amp;#125;&#39; | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sort -fu | \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    sed -e &quot;&lt;/span&gt;s/^/&lt;span class=&quot;variable&quot;&gt;$&amp;#123;Repo&amp;#125;&lt;/span&gt;:/&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker精简镜像体积</title>
    <link href="http://suntus.github.io/2017/12/07/docker%E7%B2%BE%E7%AE%80%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"/>
    <id>http://suntus.github.io/2017/12/07/docker精简镜像体积/</id>
    <published>2017-12-07T01:58:20.000Z</published>
    <updated>2017-12-12T02:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。</li><li>找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。<a id="more"></a></li><li>ubuntu安装软件的时候，区分 build时依赖和runtime时依赖，build的依赖（比如gcc,g++,cmake,make等等）可以在最后删除，runtime的当然就不能删除啦。</li><li>安装时使用<code>--no-install-recommands</code>选项，也就是<code>apt-get install -y --no-install-recommands  cmake3</code>，不安装apt-get推荐的依赖，只相信我们自己 : )</li><li>删除的时候用这个: <code>apt-get purge -y --auto-remove $buildDeps</code>，删的更干净。</li><li>删除apt-get安装时候的一些日志： <code>rm /var/log/dpkg.log /var/log/alternatives.log /var/log/apt/*.log</code>。</li><li>记得把安装时候不需要的源码删掉，能少一点儿是一点儿。</li></ol><hr><p>参考</p><ol><li><a href="http://blog.fleeto.us/translation/refactoring-dockerfile-image-size" target="_blank" rel="noopener">优化 Dockerfile，缩减镜像尺寸</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;命令尽量都写在一行，docker的命令会产生分层，也就是说，每执行一次命令，都会commit一次，然后继续下一次，这样每一次的执行都会记录下来。&lt;/li&gt;
&lt;li&gt;找比较小的基础镜像，当然还是ubuntu最好啊哈哈哈。
    
    </summary>
    
    
      <category term="docker" scheme="http://suntus.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>librdkafka相关</title>
    <link href="http://suntus.github.io/2017/12/04/librdkafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://suntus.github.io/2017/12/04/librdkafka相关/</id>
    <published>2017-12-04T07:59:13.000Z</published>
    <updated>2017-12-13T07:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-offset管理"><a href="#1-offset管理" class="headerlink" title="1.offset管理"></a>1.offset管理</h2><p>kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个<code>__consumer_offsets</code>的topic中。<br>zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。<br><a id="more"></a><br>librdkafka支持两种offset管理方式：</p><ol><li>存放到本地文件</li><li>存放到集群中</li></ol><p>librdkafka consumer的high level API支持存放到broker中，low level API支持存放到本地文件</p><p><strong>存放到集群</strong><br>影响的配置有这么几个：</p><ul><li>group.id: 设置consumer组，因为offset是按组来管理的，所以必须有这个东西</li><li>enable.auto.commit: 设置是否自动保存，[true, false]</li><li>auto.commit.interval.ms: 自动保存的的时间，默认是5000(5s)</li></ul><p>下面是一段示例代码<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conf = rd_kafk<span class="built_in">a_conf</span>_new()<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"group.id"</span>,<span class="string">"hehe"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"enable.auto.commit"</span>,<span class="string">"true"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rd_kafk<span class="built_in">a_conf</span>_set(conf,<span class="string">"auto.commit.interval.ms"</span>,<span class="string">"1000"</span>,errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line">rk = rd_kafk<span class="built_in">a_new</span>(RD_KAFK<span class="built_in">A_CONSUMER</span>, conf, errstr,sizeof(errstr))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 创建个topic_partition list</span><br><span class="line">rtkp_list = rd_kafk<span class="built_in">a_topic</span>_partition_list_new(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"># 将名字为topic_test的topic添加到rtkp_list中，并将offset设置为RD_KAFK<span class="built_in">A_OFFSET</span>_STORED，也就是consumer上次存储在broker中的offset。rd_kafk<span class="built_in">a_topic</span>_partition_list_add()返回的是<span class="number">1</span>个rd_kafk<span class="built_in">a_topic</span>_partition_t。</span><br><span class="line">rd_kafk<span class="built_in">a_topic</span>_partition_list_add(rtkp_list,<span class="string">"topic_test"</span>,<span class="number">0</span>)-&gt;offset = RD_KAFK<span class="built_in">A_OFFSET</span>_STORED<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 这里是确定订阅哪个topic了</span><br><span class="line">rd_kafk<span class="built_in">a_assign</span>(rk, rtkp_list)<span class="comment">;</span></span><br><span class="line">while(<span class="number">1</span>)&#123;</span><br><span class="line">    msg  = rd_kafk<span class="built_in">a_consumer</span>_poll(rk, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用这个去查看存储的offset到哪儿了<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-consumer-offset-checker.sh --zookeeper localhost:2181 --topic topic_test  --group hehe</span><br><span class="line"></span><br><span class="line">Group           Topic                          Pid Offset          logSize         Lag             Owner</span><br><span class="line">hehe            topic_test                    0   6483667         1674985741      1668502074      none</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset就是当前存储的offset，logSize是当前最大的offset，lag是还没消费的msg个数</span></span><br></pre></td></tr></table></figure></p><p><strong>存放到本地</strong><br>诶，参考上边吧</p><h2 id="2-high-level-API多topic操作"><a href="#2-high-level-API多topic操作" class="headerlink" title="2.high level API多topic操作"></a>2.high level API多topic操作</h2><p>有时候需要在一个进程中订阅多个topic，并且每个topic需要单独操作，这时候就可以多申请几个<code>rd_kafka_topic_partition_list_t</code>，分别在每个<code>rd_kafka_topic_partition_list_t</code>中加入各自的topic，在订阅消息的时候，使用<code>rd_kafka_assign(rk, rktp_list);</code>来切换各个topic。就可以了。</p><h2 id="3-high-level-API手动存储consumer的offset"><a href="#3-high-level-API手动存储consumer的offset" class="headerlink" title="3.high level API手动存储consumer的offset"></a>3.high level API手动存储consumer的offset</h2><p>先设置这几个参数<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rk_conf的配置</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.offset.store = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 一般还会设置这个配置，指示在broker没有存储offset(最开始时候)或offset出现错误的时候，系统应该初始化的offset位置，默认是latest</span></span><br><span class="line"><span class="literal">auto</span>.offset.reset = [earliest, latest, <span class="literal">none</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始时候topic_conf的几个配置会让人迷惑，auto.commit.enable 只针对 low level API, high level API需要使用rk_conf的全局配置，enable.autom.commit是auto.commit.enable的别名</span></span><br><span class="line"><span class="literal">auto</span>.commit.enable = <span class="literal">false</span></span><br><span class="line">enable.<span class="literal">auto</span>.commit = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>操作的话，需要用到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个是实际将offset提交到broker的操作，async为false的时候，该操作阻塞。</span></span><br><span class="line"><span class="comment">// 两个的区别是，第一个可以控制提交的offset的具体值，第二个只能提交msg的offset，不能手动控制。</span></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_topic_partition_list_t</span> *offsets, <span class="keyword">int</span> async);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_commit_message(</span><br><span class="line">    <span class="keyword">rd_kafka_t</span> *rk, <span class="keyword">const</span> <span class="keyword">rd_kafka_message_t</span> *rkmessage, <span class="keyword">int</span> async);</span><br></pre></td></tr></table></figure></p><p>另外，还有个跟offset相关的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rd_kafka_resp_err_t</span> rd_kafka_offset_store(<span class="keyword">rd_kafka_topic_t</span> *rkt,</span><br><span class="line">                                          <span class="keyword">int32_t</span> partition, <span class="keyword">int64_t</span> offset);</span><br></pre></td></tr></table></figure></p><p>这个函数只是把offset提交到内存，并不是提交到broker存储起来，所以还是需要调用*commit()函数</p><p><strong>注意：如果多topic切换的时候，需要先commit，再切换，否则切换回来还是会从原先的offset开始读取消息。</strong></p><hr><p>参考:</p><ol><li><a href="http://www.cnblogs.com/smartloli/p/6266453.html" target="_blank" rel="noopener">kafka的offset管理</a></li><li><a href="https://github.com/edenhill/librdkafka/wiki/Consumer-offset-management" target="_blank" rel="noopener">librdkafka的一些说明</a></li><li><a href="https://github.com/arnaud-lb/php-rdkafka/issues/87" target="_blank" rel="noopener">关于high level API手动管理offset的讨论</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-offset管理&quot;&gt;&lt;a href=&quot;#1-offset管理&quot; class=&quot;headerlink&quot; title=&quot;1.offset管理&quot;&gt;&lt;/a&gt;1.offset管理&lt;/h2&gt;&lt;p&gt;kafka支持将consumer消费的offset存放到集群中，在0.8.2.2版本，默认存放到zookeeper中，在0.10.1.1中就默认存放到broker中的一个&lt;code&gt;__consumer_offsets&lt;/code&gt;的topic中。&lt;br&gt;zookeeper并不是用来做大规模读写管理的，因此放到这里会对系统造成瓶颈。&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
      <category term="kafka" scheme="http://suntus.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>iniparser-C 配置解析</title>
    <link href="http://suntus.github.io/2017/11/24/iniparser-C%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://suntus.github.io/2017/11/24/iniparser-C配置解析/</id>
    <published>2017-11-24T02:08:59.000Z</published>
    <updated>2017-11-24T03:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ndevilla/iniparser" target="_blank" rel="noopener">https://github.com/ndevilla/iniparser</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>相当小，4个文件(2个c，2个h)，1500行左右</li><li>不依赖其他库</li><li>可重入，需要自己加锁实现线程安全</li></ul><p>另外，使用也相当简单<br><a id="more"></a></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先准备ini格式的配置文件<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[kafka]</span></span><br><span class="line"><span class="attr">broker</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9092</span></span><br><span class="line"><span class="attr">topic</span> = hello</span><br><span class="line"></span><br><span class="line"><span class="section">[db]</span></span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br></pre></td></tr></table></figure></p><p>解析<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">direcotyr *d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = iniparser_load(<span class="string">"haha.conf"</span>);</span><br><span class="line">iniparser_dump(d,<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// broker</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:broker"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"broker: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// topic</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"kafka:topic"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"topic: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.host</span></span><br><span class="line">s = iniparser_getstring(d, <span class="string">"db:host"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.host: %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.port</span></span><br><span class="line">n = iniparser_getint(d, <span class="string">"db:port"</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"db.port: %d\n"</span>, n);</span><br><span class="line"></span><br><span class="line">iniparser_freedict(d);</span><br></pre></td></tr></table></figure></p><p>主要的API<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取section个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getnsec</span><span class="params">(<span class="keyword">const</span> dictionary * d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第n个section的个数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getsecname</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出配置到文件，可重新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dumpsection_ini</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * s, FILE * f)</span></span>;</span><br><span class="line"><span class="comment">// 导出配置到文件，方便查看，不可从新导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_dump</span><span class="params">(<span class="keyword">const</span> dictionary * d, FILE * f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">iniparser_getstring</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">const</span> <span class="keyword">char</span> * def)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">iniparser_getlongint</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">long</span> <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">iniparser_getdouble</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">double</span> notfound)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_getboolean</span><span class="params">(<span class="keyword">const</span> dictionary * d, <span class="keyword">const</span> <span class="keyword">char</span> * key, <span class="keyword">int</span> notfound)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置配置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_set</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry, <span class="keyword">const</span> <span class="keyword">char</span> * val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_unset</span><span class="params">(dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iniparser_find_entry</span><span class="params">(<span class="keyword">const</span> dictionary * ini, <span class="keyword">const</span> <span class="keyword">char</span> * entry)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入，清理</span></span><br><span class="line"><span class="function">dictionary * <span class="title">iniparser_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * ininame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iniparser_freedict</span><span class="params">(dictionary * d)</span></span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ndevilla/iniparser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ndevilla/iniparser&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相当小，4个文件(2个c，2个h)，1500行左右&lt;/li&gt;
&lt;li&gt;不依赖其他库&lt;/li&gt;
&lt;li&gt;可重入，需要自己加锁实现线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，使用也相当简单&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="http://suntus.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数组的二分算法模块--bisect</title>
    <link href="http://suntus.github.io/2017/11/03/%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9D%97-bisect/"/>
    <id>http://suntus.github.io/2017/11/03/数组的二分算法模块-bisect/</id>
    <published>2017-11-03T06:09:06.000Z</published>
    <updated>2017-11-03T06:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两点作用："><a href="#1-两点作用：" class="headerlink" title="1.两点作用："></a>1.两点作用：</h2><p>1.插入时就维护好一个排好序的数组<br>2.数组非常大的时候速度较快</p><a id="more"></a><p>用着也很简单，只有2个操作：查找、插入，每个操作各有2个方法，分别是</p><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left(a, x, <span class="attribute">lo</span>=0, <span class="attribute">hi</span>=len(a))</span><br></pre></td></tr></table></figure><p>返回一个数组a的下标i，a[lo… i-1] &lt; x &lt;= a[i…hi]。也就是说在i左边的元素都比x小，在i及i右边的元素，都等于或大于x.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.bisect</span>()</span><br></pre></td></tr></table></figure></p><p>这两个是一样的。<br>返回一个数组a的下标i，a[lo… i-1] &lt;= x &lt;a[i…hi]。也就是说在i左边的元素小于等于x，在i及i右边的元素，都大于x</p><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_left</span>()</span><br></pre></td></tr></table></figure><p>插入的效果跟查找是一样的，不过就是查找然后插入:list.insert(bisect.bisect_left())<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort_right</span>()</span><br><span class="line"><span class="selector-tag">bisect</span><span class="selector-class">.insort</span>()</span><br></pre></td></tr></table></figure></p><p>上边四个操作可以用下图帮助理解:<br><img src="/img/python/bisect.png" title="bisect操作"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-两点作用：&quot;&gt;&lt;a href=&quot;#1-两点作用：&quot; class=&quot;headerlink&quot; title=&quot;1.两点作用：&quot;&gt;&lt;/a&gt;1.两点作用：&lt;/h2&gt;&lt;p&gt;1.插入时就维护好一个排好序的数组&lt;br&gt;2.数组非常大的时候速度较快&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python配置解析--ConfigParser</title>
    <link href="http://suntus.github.io/2017/11/02/python%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90-ConfigParser/"/>
    <id>http://suntus.github.io/2017/11/02/python配置解析-ConfigParser/</id>
    <published>2017-11-02T06:32:33.000Z</published>
    <updated>2017-11-02T06:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>配置文件的格式<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">bind</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">log</span> = /var/log/haha.log</span><br><span class="line"><span class="attr">workers</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">connect</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9090</span></span><br><span class="line"><span class="attr">log</span> = /var/log/hehe.log</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用的话就相当简单了<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> = ConfigParser.ConfigParser()</span><br><span class="line"><span class="keyword">cp</span>.<span class="keyword">read</span>(<span class="string">"etc/app.conf"</span>)</span><br><span class="line">server.bind = <span class="keyword">cp</span>.<span class="built_in">get</span>(<span class="string">"server"</span>, <span class="string">"bind"</span>)</span><br><span class="line">server.workers = <span class="keyword">cp</span>.getint(<span class="string">"server"</span>,<span class="string">"workers"</span>)</span><br><span class="line"># 另外还有</span><br><span class="line"># <span class="keyword">cp</span>.getboolean()</span><br><span class="line"># <span class="keyword">cp</span>.getfloat()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置文件的格式&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[server]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;bind&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/haha.log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;workers&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[client]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;connect&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9090&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log&lt;/span&gt; = /var/log/hehe.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python连接mysql</title>
    <link href="http://suntus.github.io/2017/11/02/python%E8%BF%9E%E6%8E%A5mysql/"/>
    <id>http://suntus.github.io/2017/11/02/python连接mysql/</id>
    <published>2017-11-02T05:57:29.000Z</published>
    <updated>2017-11-02T06:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装MySQLdb<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> mysql-python</span><br></pre></td></tr></table></figure></p><p>创建连接<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_conn(**dbconfig):</span><br><span class="line">    conn = MySQLdb.<span class="built_in">connect</span>(**dbconfig)</span><br><span class="line">    <span class="built_in">cursor</span> = conn.<span class="built_in">cursor</span>()</span><br><span class="line">    <span class="built_in">return</span> conn, <span class="built_in">cursor</span></span><br><span class="line"></span><br><span class="line">conn, <span class="built_in">cursor</span> = db_get_conn(host=<span class="string">"127.0.0.1"</span>, user=<span class="string">"root"</span>,passwd=“<span class="number">123</span><span class="string">", db=“db_haha"</span>,charset=<span class="string">"utf8"</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建查询<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.<span class="keyword">execute</span>(<span class="string">"select a,b from t_hehe"</span>)</span><br></pre></td></tr></table></figure></p><p>获取结果<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">a</span>, b <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">        print <span class="keyword">a</span>,b</span><br><span class="line"></span><br><span class="line">// 注意：如果只有<span class="number">1</span>个元素，这样才行</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">a</span>,) <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">    print <span class="keyword">a</span></span><br></pre></td></tr></table></figure></p><p>如果结果太大，不想全部拉回来，而是创建好查询，现在服务器端查好结果，再一条条拉回来，要这样创建连接<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def db_get_ss_conn(*<span class="number">*dbc</span>onfig):</span><br><span class="line">    ss_conn = MySQLdb.connect(*<span class="number">*dbc</span>onfig)</span><br><span class="line">    ss_cursor = conn.cursor(<span class="attribute">cursorclass</span>=MySQLdb.cursors.SSCursor)</span><br><span class="line">    return ss_conn, ss_cursor</span><br><span class="line"></span><br><span class="line">ss_conn, ss_cursor = db_get_conn(<span class="attribute">host</span>=<span class="string">"127.0.0.1"</span>, <span class="attribute">user</span>=<span class="string">"root"</span>,passwd=“123", <span class="attribute">db</span>=“db_haha",charset="utf8")</span><br></pre></td></tr></table></figure></p><p>然后这样获取结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss_cursor.execute(<span class="string">"select a,b from t_hehe"</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span> <span class="keyword">in</span> ss_cursor:</span><br><span class="line">    print <span class="selector-tag">a</span>, b</span><br></pre></td></tr></table></figure></p><p>最后修改的话，记得提交事务<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">conn</span><span class="selector-class">.commit</span>()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装MySQLdb&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; mysql-python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建连接&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def db_get_conn(**dbconfig):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn = MySQLdb.&lt;span class=&quot;built_in&quot;&gt;connect&lt;/span&gt;(**dbconfig)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = conn.&lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn, &lt;span class=&quot;built_in&quot;&gt;cursor&lt;/span&gt; = db_get_conn(host=&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, user=&lt;span class=&quot;string&quot;&gt;&quot;root&quot;&lt;/span&gt;,passwd=“&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;, db=“db_haha&quot;&lt;/span&gt;,charset=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://suntus.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>nginx图集</title>
    <link href="http://suntus.github.io/2017/10/20/nginx%E5%9B%BE%E9%9B%86/"/>
    <id>http://suntus.github.io/2017/10/20/nginx图集/</id>
    <published>2017-10-20T09:02:33.000Z</published>
    <updated>2017-10-30T08:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx的代码组织相当简洁明了。<br><a id="more"></a><br><img src="/img/nginx/ngx_src_1.png" title="模块的组织"></p><p><img src="/img/nginx/ngx_src_2.png" title="头文件的组织,可以帮助理解整体结构"></p><p>原来是想写一下nginx的启动流程的，但发现把这个图做出来，就没什么好说的了，即使写出来也都是大白话，还不如仔细看看这个图。<br><img src="/img/nginx/ngx_src_3.png" title="nginx主体框架启动流程"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx的代码组织相当简洁明了。&lt;br&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://suntus.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>命令_nc</title>
    <link href="http://suntus.github.io/2017/09/22/%E5%91%BD%E4%BB%A4-nc/"/>
    <id>http://suntus.github.io/2017/09/22/命令-nc/</id>
    <published>2017-09-22T08:19:37.000Z</published>
    <updated>2017-09-22T08:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>netcat——瑞士军刀</p><h1 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h1><ol><li>TCP服务端客户端</li><li>网络测试</li><li>ssh的SOCKS或HTTP代理</li><li>简单的端口扫描<br>…<a id="more"></a></li></ol><h1 id="2-一些命令"><a href="#2-一些命令" class="headerlink" title="2. 一些命令"></a>2. 一些命令</h1><ul><li>-4：只使用IPv4地址</li><li>-6：只是用IPv6地址</li><li>-b：允许广播</li><li>-C：使用CRLF作为行的结尾</li><li>-D：启动debug</li><li>-d：不从标准输入中读取</li><li>-I length：设置TCP接收缓冲区大小</li><li>-i interval：在发送和接收数据包之间设置时间间隔，也在连接到多个端口的时候设置时间间隔</li><li>-k: 强制nc在连接到1个端口之后监听等待1个连接到来。跟-l配合使用</li><li>-l: 监听模式</li><li>-n：不在任何地址、主机名、端口上做DNS（直接是数字形式的）</li><li>-O length: 设置TCP发送缓冲区大小</li><li>-P proxy_username: 连接到proxy的时候提供用户名来验证</li><li>-p source_port：设置源端口</li><li>-q seconds: 在标准输入发送EOF后，等待这些秒，如果是负数，就一直等下去</li><li>-r: 让源/目的端口随机，不让在一个范围内分配</li><li>-S：开启RFC 2385 TCP MD5 signature option</li><li>-s source: 设置源地址，如果是unix domain socket，就指定文件</li><li>-T toskeyword：改变IPv4的TOS字段</li><li>-U：使用unix domain socket</li><li>-u：使用udp，而不是默认的TCP。不用-s指定的话，会在/tmp目录下新建临时文件</li><li>-V rtable: 设置使用的路由表</li><li>-v: verbose输出</li><li>-w timeout: 向外连接的时候设置超时时间</li><li>-X proxy_protocol: 设置代理协议，4” (SOCKS v.4), “5” (SOCKS v.5) and “connect”(HTTPS proxy)。默认是5</li><li>-x proxy_address[:port]：设置连接的代理地址</li><li>-Z:DCCP模式</li><li>-z: 只是扫描一下监听端口，而不发送任何数据。</li></ul><h1 id="3-简单的用法"><a href="#3-简单的用法" class="headerlink" title="3. 简单的用法"></a>3. 简单的用法</h1><h2 id="1-设置TCP服务端和客户端"><a href="#1-设置TCP服务端和客户端" class="headerlink" title="1. 设置TCP服务端和客户端"></a>1. 设置TCP服务端和客户端</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line"># rm -f /tmp/f; mkfifo /tmp/f</span><br><span class="line"># cat /tmp/f | /bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span> | nc -l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1234</span> &gt; /tmp/f</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line">$ nc host.example.com <span class="number">1234</span></span><br><span class="line">$ (shell prompt from host.example.com)</span><br></pre></td></tr></table></figure><h2 id="2-文件传输"><a href="#2-文件传输" class="headerlink" title="2. 文件传输"></a>2. 文件传输</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一端</span><br><span class="line">$ nc -l <span class="number">1234</span> &gt; filename.out</span><br><span class="line"></span><br><span class="line">另一端：</span><br><span class="line">$ nc host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">1234</span> &lt; filename.<span class="keyword">in</span></span><br></pre></td></tr></table></figure><h2 id="3-连接服务器"><a href="#3-连接服务器" class="headerlink" title="3. 连接服务器"></a>3. 连接服务器</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nc [-C] localhost <span class="number">25</span> &lt;&lt; EOF</span><br><span class="line">HELO host<span class="selector-class">.example</span><span class="selector-class">.com</span></span><br><span class="line">MAIL FROM:&lt;user@host<span class="selector-class">.example</span><span class="selector-class">.com</span>&gt;</span><br><span class="line">RCPT TO:&lt;user2@host<span class="selector-class">.example</span><span class="selector-class">.com</span>&gt;</span><br><span class="line">DATA</span><br><span class="line">Body of email.</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="4-端口扫描"><a href="#4-端口扫描" class="headerlink" title="4. 端口扫描"></a>4. 端口扫描</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nc -zv host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">20</span>-<span class="number">30</span></span><br><span class="line">$ nc -zv host<span class="selector-class">.example</span><span class="selector-class">.com</span> <span class="number">80</span> <span class="number">20</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><hr><p>参考:</p><ol><li>man nc</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;netcat——瑞士军刀&lt;/p&gt;
&lt;h1 id=&quot;1-功能&quot;&gt;&lt;a href=&quot;#1-功能&quot; class=&quot;headerlink&quot; title=&quot;1. 功能&quot;&gt;&lt;/a&gt;1. 功能&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;TCP服务端客户端&lt;/li&gt;
&lt;li&gt;网络测试&lt;/li&gt;
&lt;li&gt;ssh的SOCKS或HTTP代理&lt;/li&gt;
&lt;li&gt;简单的端口扫描&lt;br&gt;…
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
      <category term="cli" scheme="http://suntus.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>shell IO重定向</title>
    <link href="http://suntus.github.io/2017/09/22/shell%20IO%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://suntus.github.io/2017/09/22/shell IO重定向/</id>
    <published>2017-09-22T03:49:02.000Z</published>
    <updated>2017-09-25T04:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>重定向没什么难理解的，只是有些命令会不熟悉，这里列出了一些常用的命令，以备后查。</p><p>标准输入：键盘，0<br>标准输出：屏幕，1<br>标准错误：屏幕，2<br><a id="more"></a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> 1&gt; <span class="selector-tag">haha</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将标准输出1重定向到文件haha.txt。注意1和&gt;之间没有空格。1可以省略，就成了常用的 ls &gt; haha.txt</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="number">1</span><span class="meta">&gt;&gt;</span>haha.txt</span><br></pre></td></tr></table></figure><p>1个&gt;是先清空haha.txt，再写入；两个&gt;是追加到haha.txt后边</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> <span class="selector-tag">-qw</span> 2&gt; <span class="selector-tag">haha</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将标准错误重定向到haha.txt</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="meta">&amp;&gt; haha.txt</span></span><br></pre></td></tr></table></figure><p>将标准输出、标准错误都重定向到haha.txt</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">i</span>&gt;&amp;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>将文件描述符i重定向到描述符j，也就是现在j也具有了i的能力，应用到i上的IO操作都可以应用到j上，效果一样。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#echo <span class="number">123456789</span> &gt;filename   把字符串写到文件filename中</span><br><span class="line">#exec <span class="number">3</span>&lt;&gt;filename           把文件filename打开，并指定文件标识符为<span class="number">3</span></span><br><span class="line">#read -n <span class="number">4</span> &lt;&amp;<span class="number">3</span>              从文件中读<span class="number">4</span>个字符，句柄已经指到第四个字符末尾</span><br><span class="line">#echo -n . &gt;&amp;<span class="number">3</span>              在第<span class="number">5</span>个字符处写一个点，覆盖第<span class="number">5</span>个字符，-n表示不换行</span><br><span class="line">#exec <span class="number">3</span>&gt;&amp;-                 关闭文件标识符<span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>3&lt;&gt;filename</code> 表示用描述符3打开filename<br><code>3&gt;&amp;-</code> 表示关闭输出描述符的文件</p><p><code>3&lt;&amp;-</code> 表示关闭输入描述符的文件</p><hr><p>参考</p><ol><li>IBM的资料：<a href="https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html</a></li><li>不知道这个跟上个是谁抄谁的一部分：<a href="http://manual.51yip.com/shell/io-redirection.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重定向没什么难理解的，只是有些命令会不熟悉，这里列出了一些常用的命令，以备后查。&lt;/p&gt;
&lt;p&gt;标准输入：键盘，0&lt;br&gt;标准输出：屏幕，1&lt;br&gt;标准错误：屏幕，2&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>命令_date</title>
    <link href="http://suntus.github.io/2017/09/20/%E5%91%BD%E4%BB%A4_date/"/>
    <id>http://suntus.github.io/2017/09/20/命令_date/</id>
    <published>2017-09-20T08:31:57.000Z</published>
    <updated>2017-09-22T08:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-显示和设置系统日期和时间"><a href="#1-显示和设置系统日期和时间" class="headerlink" title="1. 显示和设置系统日期和时间"></a>1. 显示和设置系统日期和时间</h2><p>date [OPTION]… [+FORMAT]<br>date [-u| —utc| -universal] [MMDDhhmm[[CC]UYY][.ss]]</p><h2 id="2-其实核心的只有1个功能："><a href="#2-其实核心的只有1个功能：" class="headerlink" title="2. 其实核心的只有1个功能："></a>2. 其实核心的只有1个功能：</h2><p><strong><em>输入特定格式的时间，转换成自己想要的时间格式</em></strong></p><a id="more"></a><h3 id="2-1-输入使用-d，后边跟描述时间的文字"><a href="#2-1-输入使用-d，后边跟描述时间的文字" class="headerlink" title="2.1 输入使用-d，后边跟描述时间的文字"></a>2.1 输入使用-d，后边跟描述时间的文字</h3><p>比如<br>“Sun, 29 Feb 2004 16:21:42 -0800”, “2004-02-29 16:21:42” , “next Thursday”, “-10day”, “+10min”等等，该描述性的文字由指示日历的日期，时间的天，时间的时区，天的星期，相对时间，相对日期和数字组成。空字符串表示这天的开始。</p><h3 id="2-2-输出使用-FORMAT，后边跟各种格式："><a href="#2-2-输出使用-FORMAT，后边跟各种格式：" class="headerlink" title="2.2 输出使用+FORMAT，后边跟各种格式："></a>2.2 输出使用+FORMAT，后边跟各种格式：</h3><p>%%: 符号%<br>%a: 本地星期缩写， Sun<br>%A: 本地星期全称， Sunday<br>%b: 本地月份缩写, Jan<br>%B: 本地月份全称, January<br>%c: 本地日期和时间, Thu Mar 3 23:-5:25 2005<br>%C: 世纪，类似%Y，DNA没有后两位, 20<br>%d: 月的第几天, 01<br>%D: 日期，%m/%d/%y<br>%e: 月的天数，用空格填充，类似%<em>d<br>%F: 完整的日期格式，类似%F-%m-%d<br>%g: ISO格式年的后两位<br>%G: ISO格式的年<br>%h: 跟%b一样<br>%H: 小时(00..23)<br>%I: 小时(01..12)<br>%j: 年的第几天(001..366)<br>%k: 小时，用空格填充(0..23); 类似%_H<br>%l: 小时，用空格填充(1..12) ； 类似%_I<br>%m: 月(01..12)<br>%M: 分钟(00..59)<br>%n: 换行<br>%N: 纳秒,nanoseconds(0000000000..999999999)<br>%p: 本地的AM或者PM<br>%P: 类似%p，但是是小写<br>%r：本地12小时制时钟时间  11:11:04 PM<br>%R: 24小时制的小时跟分钟，类似%H:%M<br>%s: 从1970-01-01 00:00:00 UTC开始的秒数，时间戳<br>%S: 秒(00..60)<br>%t: tab字符<br>%T: 时间，类似%H:%M:%S<br>%u: 星期的第几天(1..7),1是星期一<br>%U: 年的第几个星期(00..53)，周日是星期的开始<br>%V: ISO星期制，星期一是星期的开始（01..53）<br>%w: 星期的第几天(0..6)，0是星期天<br>%W: 年的第几个星期(00..53)，周一是星期的开始<br>%x:  本地日期表示(12/31/99)<br>%X: 本地时间表示(23:13:48)<br>%y: 年的后两位数字(00..99)<br>%Y: 年<br>另外还有几个符号，用于修饰<br>-  不填充</em> 用空格填充<br>0 用0填充<br>^ 用大写<br>#  用相反的大小写</p><h2 id="3-几个例子："><a href="#3-几个例子：" class="headerlink" title="3. 几个例子："></a>3. 几个例子：</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出今天开始时间</span></span><br><span class="line">date -d <span class="string">""</span></span><br><span class="line"><span class="comment"># 当前时间戳</span></span><br><span class="line">date +%s</span><br><span class="line"><span class="comment"># 输出好看的时间：2017-9-20 16:21:42</span></span><br><span class="line">date +<span class="string">"%F %T"</span></span><br><span class="line"><span class="comment"># 将时间戳转换成可读时间，对这里的时间戳前边要加@</span></span><br><span class="line">date -d @1505896166 +<span class="string">"%F %T"</span></span><br><span class="line"><span class="comment"># 输出10分钟前的时间戳</span></span><br><span class="line">date -d <span class="string">"-10min"</span> +%s</span><br></pre></td></tr></table></figure><p>至于设置系统时间，加个-s就行了。</p><hr><p>参考：</p><ol><li>man date</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-显示和设置系统日期和时间&quot;&gt;&lt;a href=&quot;#1-显示和设置系统日期和时间&quot; class=&quot;headerlink&quot; title=&quot;1. 显示和设置系统日期和时间&quot;&gt;&lt;/a&gt;1. 显示和设置系统日期和时间&lt;/h2&gt;&lt;p&gt;date [OPTION]… [+FORMAT]&lt;br&gt;date [-u| —utc| -universal] [MMDDhhmm[[CC]UYY][.ss]]&lt;/p&gt;
&lt;h2 id=&quot;2-其实核心的只有1个功能：&quot;&gt;&lt;a href=&quot;#2-其实核心的只有1个功能：&quot; class=&quot;headerlink&quot; title=&quot;2. 其实核心的只有1个功能：&quot;&gt;&lt;/a&gt;2. 其实核心的只有1个功能：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;输入特定格式的时间，转换成自己想要的时间格式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://suntus.github.io/tags/linux/"/>
    
      <category term="cli" scheme="http://suntus.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>用到的tmux</title>
    <link href="http://suntus.github.io/2017/09/19/%E7%94%A8%E5%88%B0%E7%9A%84tmux/"/>
    <id>http://suntus.github.io/2017/09/19/用到的tmux/</id>
    <published>2017-09-19T09:15:10.000Z</published>
    <updated>2019-05-09T11:41:33.895Z</updated>
    
    <content type="html"><![CDATA[<p>终端复用软件，跟screen一样，但是要强大的多。</p><h2 id="1-典型应用场景"><a href="#1-典型应用场景" class="headerlink" title="1. 典型应用场景"></a>1. 典型应用场景</h2><p>自己电脑是客户端，平常ssh到linux服务器上编译运行调试软件，网络断开或者自己电脑挂掉之后，不想服务器上运行的程序也挂掉，这时候就可以用tmux了。还有就是tmux能方便的多开好几个窗口。tmux的作用是代理终端，以前你直接通过ssh通道来操作服务器的终端，现在通过ssh通道启动了1个tmux程序，由tmux程序代替你控制多个终端，这样你就拥有了一组终端，所以是个服务器开发神器。这个神器差不多长这样：<br><img src="/img/tmux-1.png" alt="image.png"></p><a id="more"></a><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>跟vim差不多，也是要在服务器本用户主目录下边放一个配置文件<code>.tmux.conf</code>，直接用这个吧，有些东西自己想调整可以看着改：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># (‑●‑●)&gt; released under the WTFPL v2 license, by Gregory Pakosz (@gpakosz)</span></span><br><span class="line">unbind C-b</span><br><span class="line"><span class="keyword">set</span> -g prefix C-a</span><br><span class="line"></span><br><span class="line"><span class="meta">#up</span></span><br><span class="line">bind-key k select-pane -U</span><br><span class="line"><span class="meta">#down</span></span><br><span class="line">bind-key j select-pane -D</span><br><span class="line"><span class="meta">#left</span></span><br><span class="line">bind-key h select-pane -L</span><br><span class="line"><span class="meta">#right</span></span><br><span class="line">bind-key l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#select last window</span></span><br><span class="line">bind-key C-l select-window -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#copy-mode 将快捷键设置为vi 模式</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"><span class="meta"># use the powerline patched font variant of the theme, possible values are:</span></span><br><span class="line"><span class="meta"># - default</span></span><br><span class="line"><span class="meta"># - powerline</span></span><br><span class="line">tmux_conf_theme=<span class="keyword">default</span></span><br><span class="line"><span class="meta">#tmux_conf_theme=powerline</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display an indicator in the status line when the prefix key has been pressed,</span></span><br><span class="line"><span class="meta"># possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_prefix=disabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_prefix=enabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the battery information in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_battery=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_battery=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># style to use for the battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - bar</span></span><br><span class="line"><span class="meta"># - percentage</span></span><br><span class="line">tmux_conf_battery_style=bar</span><br><span class="line"><span class="meta">#tmux_conf_battery_style=percentage</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># symbols to use for battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - block</span></span><br><span class="line"><span class="meta"># - heart</span></span><br><span class="line">tmux_conf_battery_symbol=block</span><br><span class="line"><span class="meta">#tmux_conf_battery_symbol=heart</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># number of symbols to use for battery status</span></span><br><span class="line">tmux_conf_battery_symbol_count=auto</span><br><span class="line"><span class="meta">#tmux_conf_battery_symbol_count=5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># palette used for the battery status, possible values are:</span></span><br><span class="line"><span class="meta"># - 'colour_full_fg,colour_empty_fg,colour_bg'</span></span><br><span class="line"><span class="meta"># - heat</span></span><br><span class="line"><span class="meta"># - gradient</span></span><br><span class="line">tmux_conf_battery_palette=<span class="string">'#d70000,#e4e4e4,#000000'</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=colour160,colour254,colour16</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=heat</span></span><br><span class="line"><span class="meta">#tmux_conf_battery_palette=gradient</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the battery status: charging (U+26A1) / discharging (U+1F50B)</span></span><br><span class="line">tmux_conf_battery_status=enabled</span><br><span class="line"><span class="meta">#tmux_conf_battery_status=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># or alternatively use an external tool, e.g. [https://github.com/Goles/Battery](https://github.com/Goles/Battery)</span></span><br><span class="line"><span class="meta">#tmux_conf_battery='#(battery -t) '</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the time in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_time=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_time=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the date in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_date=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_date=disabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the username in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line"><span class="meta"># - ssh</span></span><br><span class="line">tmux_conf_theme_username=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_username=disabled</span></span><br><span class="line"><span class="meta">#tmux_conf_theme_username=ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># display the hostname in the status line, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line"><span class="meta"># - ssh</span></span><br><span class="line">tmux_conf_theme_hostname=enabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_hostname=disabled</span></span><br><span class="line"><span class="meta">#tmux_conf_theme_hostname=ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># highlight focuse pane, possible values are:</span></span><br><span class="line"><span class="meta"># - enabled</span></span><br><span class="line"><span class="meta"># - disabled</span></span><br><span class="line">tmux_conf_theme_highlight_focused_pane=disabled</span><br><span class="line"><span class="meta">#tmux_conf_theme_highlight_focused_pane=enabled</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># should new windows retain current path, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_windows_retain_current_path=<span class="literal">false</span></span><br><span class="line"><span class="meta">#tmux_conf_new_windows_retain_current_path=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># should new panes reatin current path, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_panes_retain_current_path=<span class="literal">true</span></span><br><span class="line"><span class="meta">#tmux_conf_new_panes_retain_current_path=false</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># prompt for session name when creating a new session, possible values are:</span></span><br><span class="line"><span class="meta"># - true</span></span><br><span class="line"><span class="meta"># - false</span></span><br><span class="line">tmux_conf_new_session_prompt=<span class="literal">false</span></span><br><span class="line"><span class="meta">#tmux_conf_new_session_prompt=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># if you're running tmux within iTerm2</span></span><br><span class="line"><span class="meta"># - and tmux is 1.9 or 1.9a</span></span><br><span class="line"><span class="meta"># - and iTerm2 is configured to let option key act as +Esc</span></span><br><span class="line"><span class="meta"># - and iTerm2 is configured to send [1;9A -&gt; [1;9D for option + arrow keys</span></span><br><span class="line"><span class="meta"># then uncomment the following line to make Meta + arrow keys mapping work</span></span><br><span class="line"><span class="meta">#set -g terminal-overrides "*:kUP3=\e[1;9A,*:kDN3=\e[1;9B,*:kRIT3=\e[1;9C,*:kLFT3=\e[1;9D"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta"># this is the place to further customize tmux's configuration</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#set -g history-limit 10000</span></span><br></pre></td></tr></table></figure></p><h2 id="3-几个概念"><a href="#3-几个概念" class="headerlink" title="3. 几个概念"></a>3. 几个概念</h2><ol><li>session，会话</li><li>window，窗口</li><li>panel，面板</li></ol><p>关系是“1个会话会包含几个窗口，1个窗口会包含几个面板”<br>当然，1个ssh通道可以启动好几个会话，每个会话都可以detach和attach，从而一下子恢复一组工作空间。网络断开之后也会恢复哦，不过服务器重启就没办法了，毕竟tmux是跑在服务器上的软件。</p><h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h2><p><strong>4.1 在tmux之外的命令</strong><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 新建1个名叫hello的session</span></span><br><span class="line">tmux <span class="keyword">new</span> -s hello</span><br><span class="line"></span><br><span class="line"><span class="meta"># 列出当前有几个session</span></span><br><span class="line">tmux ls</span><br><span class="line"></span><br><span class="line"><span class="meta"># 挂接到名叫hello的session，恢复先前的工作空间</span></span><br><span class="line">tmux at -t hello</span><br></pre></td></tr></table></figure></p><p><strong>4.2 进入tmux后的命令</strong>。一般来说在tmux内部的常用命令都是组合键，先按下前缀键，再按下后边跟着的那个键。默认的前缀键是ctrl+b，上边的配置修改成了ctrl+a，因为a距离更近啊：）<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 退出当前panel；如果当前panel是该window的最后一个，就退出该window；如果该window是该session的最后1个，就退出该session。这个不带前缀键。</span></span><br><span class="line">ctrl+d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 安全退出当前session(detach)，这样你以后还能重新挂接(attach)上来恢复工作空间。</span></span><br><span class="line">ctrl+a, d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览并切换session</span></span><br><span class="line">ctrl+a, s</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览当前配置使用的快捷键列表，按q退出</span></span><br><span class="line">ctrl+a, ?</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建一个window</span></span><br><span class="line">ctrl+a, c</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在前后两个window之间跳转</span></span><br><span class="line">ctrl+a, ctrl+l</span><br><span class="line"></span><br><span class="line"><span class="meta"># 跳转到相应编号的window</span></span><br><span class="line">ctrl+a, <span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta"># 修改当前window的名称，默认都是个'bash'。是个逗号哈。</span></span><br><span class="line">ctrl+a, ,</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建垂直切分的panel</span></span><br><span class="line">ctrl+a, %</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建水平切分的panel</span></span><br><span class="line">ctrl+a, <span class="string">"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在panel之间切换啊，跟vim的方向一样，不过都需要加个前缀</span></span><br><span class="line"><span class="meta"># 向左</span></span><br><span class="line">ctrl+a, h</span><br><span class="line"><span class="meta"># 向右</span></span><br><span class="line">ctrl+a, l</span><br><span class="line"><span class="meta"># 向下</span></span><br><span class="line">ctrl+a, j</span><br><span class="line"><span class="meta"># 向上</span></span><br><span class="line">ctrl+a, k</span><br><span class="line"></span><br><span class="line"><span class="meta"># 暂时将当前panel占据整个window，再按一次就切换回去，在复制的时候很有用。</span></span><br><span class="line">ctrl+a, z</span><br><span class="line"></span><br><span class="line"><span class="meta"># 浏览历史，进入后就可以按vim的进行操作了，常用的是j,k, ctrl+b(向上翻页)，ctrl+f(向下翻页)</span></span><br><span class="line">ctrl+a, [</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制关闭当前panel</span></span><br><span class="line">ctrl+a, x</span><br><span class="line"></span><br><span class="line"><span class="meta"># 强制关闭当前window</span></span><br><span class="line">ctrl+a, <span class="meta">&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 切换panel布局，比如横向分屏变竖向</span></span><br><span class="line">ctrl+a, space</span><br><span class="line"></span><br><span class="line"><span class="meta"># 旋转panel布局，比如左1右2，变为左2右1</span></span><br><span class="line">ctrl+a, ctlr+o</span><br><span class="line"></span><br><span class="line"><span class="meta"># 微调panel大小，这个试一下就知道了</span></span><br><span class="line">ctrl+a, ctrl+方向键</span><br></pre></td></tr></table></figure></p><p>好了，常用的就是这些了。</p><hr><p>参考：</p><ol><li><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终端复用软件，跟screen一样，但是要强大的多。&lt;/p&gt;
&lt;h2 id=&quot;1-典型应用场景&quot;&gt;&lt;a href=&quot;#1-典型应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. 典型应用场景&quot;&gt;&lt;/a&gt;1. 典型应用场景&lt;/h2&gt;&lt;p&gt;自己电脑是客户端，平常ssh到linux服务器上编译运行调试软件，网络断开或者自己电脑挂掉之后，不想服务器上运行的程序也挂掉，这时候就可以用tmux了。还有就是tmux能方便的多开好几个窗口。tmux的作用是代理终端，以前你直接通过ssh通道来操作服务器的终端，现在通过ssh通道启动了1个tmux程序，由tmux程序代替你控制多个终端，这样你就拥有了一组终端，所以是个服务器开发神器。这个神器差不多长这样：&lt;br&gt;&lt;img src=&quot;/img/tmux-1.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>用到的calibre</title>
    <link href="http://suntus.github.io/2017/09/13/%E7%94%A8%E5%88%B0%E7%9A%84calibre/"/>
    <id>http://suntus.github.io/2017/09/13/用到的calibre/</id>
    <published>2017-09-12T22:06:04.000Z</published>
    <updated>2017-09-21T08:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">calibre</a>是一个电子书管理器，最好的，没有之一。而且免费。</p><p>大概长这样：<br><img src="/img/calibre/1.png" alt="界面预览"></p><a id="more"></a><p>基本的导入导出就不再说了，主要介绍下用到的功能。</p><h1 id="1-多级目录管理"><a href="#1-多级目录管理" class="headerlink" title="1. 多级目录管理"></a>1. 多级目录管理</h1><p>建立像这样自定义的多级目录：<br><img src="/img/calibre/2.png" alt="多级目录"></p><p><strong>首先</strong>，首选项—&gt;添加栏目—&gt;添加自定义栏目—&gt;</p><p><img src="/img/calibre/3.png" alt="添加属性"><br><em>参考值</em>：是搜索的时候用到的词，最好是英文<br><em>栏目标题</em>：就是显示出来的顶级目录名<br><em>栏目类型</em>：这里选择第二个：<br><img src="/img/calibre/4.png" alt="添加属性"><br>确定—-&gt;应用—&gt;重启calibre。</p><p><img src="/img/calibre/5.png" alt="调整标签的层级属性"></p><p><strong>然后</strong>，首选项—&gt;界面外观—&gt;标签浏览器，将刚刚定义的”suntus”定义为具有层次关系的分类。应用。<br>现在只是定义了顶层目录，还不会显示下级目录，下级目录在哪儿添加呢？</p><p><strong>再然后</strong>，导入一本书，编辑该书的元数据—&gt;自定义元数据，<br><img src="/img/calibre/6.png" alt="编辑元数据"></p><p>添加<code>这里是吃饭的.编程语言.python</code>。calibre中的层级关系使用点来表示，这个就会形成这样的目录结构：<br><img src="/img/calibre/7.png" alt="多级目录结构"></p><p>你可以同时批量编辑好多书的元数据，把它们放到同一个目录下。好吧，其他更快捷的办法我暂时没找到。</p><h1 id="2-筛选"><a href="#2-筛选" class="headerlink" title="2. 筛选"></a>2. 筛选</h1><p>点击某个具有下级分类的分类的时候，calibre会有4中筛选的方法，依次显示为：</p><p><img src="/img/calibre/8.png" alt="加号"><br><strong>加号</strong>：只显示该分组中的书籍。</p><p><img src="/img/calibre/9.png" alt="加加号"><br><strong>加加号</strong>：显示该分组及以下分组的所有书籍。</p><p><img src="/img/calibre/10.png" alt="减号"><br><strong>减号</strong>：显示除该分组外的所有书籍，包括该分组以下分组的。</p><p><img src="/img/calibre/11.png" alt="减减号"></p><p><strong>减减号</strong>：显示除该分组及该分组以下分组外的所有书籍。</p><h1 id="3-同步"><a href="#3-同步" class="headerlink" title="3. 同步"></a>3. 同步</h1><p>收集到这么多的书，肯定不想丢啊，那就全都放到谷歌硬盘(15G免费空间)上吧。直接把书库放到同步盘上就好了，到另外的环境安装个calibre，导入书库，就什么都一模一样了，简直绝配。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://calibre-ebook.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;calibre&lt;/a&gt;是一个电子书管理器，最好的，没有之一。而且免费。&lt;/p&gt;
&lt;p&gt;大概长这样：&lt;br&gt;&lt;img src=&quot;/img/calibre/1.png&quot; alt=&quot;界面预览&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://suntus.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>逻辑地址，线性地址，物理地址</title>
    <link href="http://suntus.github.io/2017/08/14/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"/>
    <id>http://suntus.github.io/2017/08/14/逻辑地址，线性地址，物理地址/</id>
    <published>2017-08-14T01:46:51.000Z</published>
    <updated>2018-01-09T07:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>。。。<br><a id="more"></a><br>首先，我们有1块物理内存，比如4G的DDR3，如果CPU想要找这个内存里边的一块区域存储的东西(0、1)，需要知道这块区域在哪里，最简单的就是把物理内存的一个个存储单元都编号，比如位置在最开头的就编号为0x00，接下来一个单元就编号0x01，…，这里每个单元都是1位，也就是只能存1个0或1个1，就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/280482-8bea53f7396c69e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>但是这样每一位都进行编号，整个地址编号就太多了，如果我们约定每8位编一个号，那整个地址就是原先的1/8，就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/280482-fb27017f9d421d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>为了方便，我们把每8位的一个单元叫做1个字节，0x00指向的就是物理内存中的第1个存储单元，也就是第1个字节，字节是物理内存的最小存储单元。如果想拿到第1个字节第3位中的数字1（标红的位置），那就需要把整个字节都先拿到，再去找里边的数字。</p><p>这里给物理内存编的1个号码就是1个物理地址，所有给物理内存编的号码就叫物理地址的地址空间。</p><p>CPU如果想拿到某个物理内存中的数字，需要发送一组电信号给物理内存芯片，芯片根据这组电信号查找相应地址，然后返回给CPU，这组电信号编码成数字就是物理地址了，就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/280482-99c05ac3dceedabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中CPU到内存控制芯片的这几根线叫地址线，比如常说的某个架构有20根地址线或者32根、36根地址线，就表明CPU可以寻址到的地址空间，比如32根地址线就可以最高寻址到2^32，也就是4G。我们这里画了4根，就可以寻址到2^4，也即是16个字节。</p><p>我们需要编写程序控制CPU进行逻辑处理、计算、存储等动作，当需要读写内存中的数据的时候，最简单的当然是用物理地址去指示CPU问内存控制芯片要哪个地址的数据了，比如：<br><img src="http://upload-images.jianshu.io/upload_images/280482-63214309b60c45e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们想要把0x00中的数据放到寄存器ax中，就把0x00这个地址给CPU，这就可以了，多简单。当然如果真的这么简单，大家都轻松了🙃。事实上，CPU为了能处理多任务，同时在一个任务中区分代码、数据、栈，就需要对内存进行划分，分别存放不同的内容，这样一是为了区分，二是为了保护（比如代码段不允许修改，某些数据只读）。先来想象一下可能的解决办法，我们的目的是想把一段处理逻辑控制在内存0x00~0x07这个段之间，让CPU在运行的时候不能超出这个内存范围去获取代码或数据，超过就要报错。一个简单的方法是设置一个标志位，该标志位表明指令中的地址都需要在0x00~0x07之间，不能超过。在指示0x08~0x15之间的内存的时候，再设置另一个标志位，起到同样的作用。这样就可以将整个内存分为2个段：0x00~0x07，0x08~0x15。每个段的长度是8个字节。每个段都设置一个标志位的方法有点儿笨，我们用每个段的首地址来表示这个段：0x00表示第1个段，0x08表示第2个段，再用跟段的首地址的偏移量来确认段内某个字节的地址。现在我们确定第1个段中第2个字节的地址就是0x00:1(第1个字节的地址是0)。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-7e0a876d7d50009e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>现在我们指令中用到的0x00:1就是逻辑地址，因为它在逻辑上将内存划分为了多个不同的段。我们要做的只是输入0x00:1这个地址，CPU会帮我们把逻辑地址翻译成0x01的物理地址🙂。</p><p>除了使用分段的方式划分内存外，还可以将物理内存直接划分为多个不同的页，称为页帧，一个物理页一般是4K大小，这样控制一页内的内存属性相同，多个不同的页可以使用不同的属性，就跟分段类似了，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-ad183344059e0d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这时候会出现个新问题：CPU已经使用逻辑地址来划分段了，如何去实现分页呢？其实肯定也想到了，在逻辑地址和物理地址之间加一个抽象层接口，也就是我们要说的最后一个地址：线性地址，也叫虚拟地址。线性地址的位置在逻辑地址和物理地址之间，比如在讲linux内核的书里边常见有这样的图：<br><img src="http://upload-images.jianshu.io/upload_images/280482-e88812256a74ff18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>CPU将逻辑地址按照分段逻辑转换成线性地址，再按分页逻辑转换成物理地址。这里的转换都是依靠CPU电路完成的，但是怎样分段，怎样分页是需要内核程序先规定好才行。CPU怎样进行分段和分页的就不细说了，<a href="http://ilinuxkernel.com/?p=1276" target="_blank" rel="noopener">这里</a>讲的真好，可以去看看。<br>我们来对比一下分段和分页：</p><div class="table-container"><table><thead><tr><th></th><th>分段</th><th>分页</th></tr></thead><tbody><tr><td>目的</td><td>将内存按照不同的属性分隔，实现隔离和保护</td><td>将内存按照不同的属性分隔，实现隔离和保护</td></tr><tr><td>对象</td><td>对线性地址进行分隔</td><td>对物理页帧进行分隔</td></tr><tr><td>方法</td><td>使用逻辑地址（段基址:偏移）分隔不同的段</td><td>将线性地址分隔成不同的部分，一步步去寻找页对应的物理页帧，进而找到对应的物理地址</td></tr><tr><td>程序需要事先做好的准备</td><td>准备好GDT,LDT,IDT，也就是个个不同的段</td><td>准备好页目录，页表，也就是各个不同的页</td></tr><tr><td>大小</td><td>段大小可变，程序控制</td><td>页大小固定的几个值，4K,4M,2M，CPU规定好的</td></tr></tbody></table></div><p>好了，现在我们的CPU中地址关系如下：<br><img src="http://upload-images.jianshu.io/upload_images/280482-947492f9b5636b64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>看上去很复杂吧，其实理解了就没那么多东西，我画画的水平有限😅。</p><p>有个问题很多人都想知道，我一开始看内存这部分的时候也很着急：linux用户程序里边用的是什么地址？我先说答案：是逻辑地址。但很多书里边讲linux虚拟内存的分布，跟程序里用到的地址是一模一样的啊？其实linux用户程序中的地址是逻辑地址中的偏移，只不过linux把所有段的基址都设为0，这样段内偏移就跟线性地址一样了（因为段基址都是0啊，段偏移加上0还是段偏移）。为什么linux要把所有段基址都设为0呢？其实分段和分页都是对内存的分隔和保护，从用途上来说是重复的，分页更简单些，所有linux就只用了分页来实现内存保护。</p><p>还有另一个问题：linux中用户进程看到的内存都是一样的，0~4G，这是如何实现的？答案是基于分页，linux给每个进程都维护一个分页映射规则，每个分页规则对应一种线性地址到物理地址的映射，这样每个进程看到的都是同样的线性地址，但是后边对应的物理地址各不相同。</p><p>内存管理是linux内核中最复杂的系统之一，除了逻辑地址到线性地址再到物理地址的映射外，还有很多其他的特性辅助操作系统对物理内存实现管理，比如分段逻辑实现时用到的GDT、LDT、IDT、TSS、6个段寄存器，分页逻辑实现时用到的页目录、页表、页帧、CR3、PAE，CPU和物理内存之间的高速缓存等。骨架已经理清楚了，其他的理解就慢慢往里加吧。</p><hr><p>参考：</p><ol><li><a href="http://ilinuxkernel.com/?p=1276，讲linux内核的大牛，思路清晰，文笔优美。" target="_blank" rel="noopener">http://ilinuxkernel.com/?p=1276，讲linux内核的大牛，思路清晰，文笔优美。</a></li><li>《Linux内核设计与实现》Robert Love，极好的内核入门书。</li><li>《深入Linux内核架构》(德)Wolfgang.Mauerer，深入细节1。</li><li>《Understanding the Linux Kernel 》3rd_Edition，Daniel P. Bovet and Marco Cesati，深入细节2。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;。。。&lt;br&gt;
    
    </summary>
    
    
      <category term="os" scheme="http://suntus.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>《题龙阳县青草湖》  ——唐温如</title>
    <link href="http://suntus.github.io/2017/08/12/%E3%80%8A%E9%A2%98%E9%BE%99%E9%98%B3%E5%8E%BF%E9%9D%92%E8%8D%89%E6%B9%96%E3%80%8B%E2%80%94%E2%80%94%E5%94%90%E6%B8%A9%E5%A6%82/"/>
    <id>http://suntus.github.io/2017/08/12/《题龙阳县青草湖》——唐温如/</id>
    <published>2017-08-12T15:03:43.000Z</published>
    <updated>2017-09-02T08:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>西风垂老洞庭波，<br>一夜湘君白发多。<br>醉后不知天在水，<br>满船清梦压星河。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;西风垂老洞庭波，&lt;br&gt;一夜湘君白发多。&lt;br&gt;醉后不知天在水，&lt;br&gt;满船清梦压星河。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读过的书" scheme="http://suntus.github.io/tags/%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/"/>
    
  </entry>
  
</feed>
